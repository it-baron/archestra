This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: issues_*/*, **/*.log, c4_map.json, **/tsconfig.json, nextnet-avsync-core-node-client/*, pdl-simulator/*, ota-service/*, streaming-service/*, docs/agent-book.md, .cursor/**, **/*.md, **/*.txt, **/*.json, **/*.yaml, **/*.yml, **/*.xml, **/*.tgz, LICENSE, **/.cursor/**, platform/shared/hey-api
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  commitlint.config.js
docs/
  assets/
    automated_screenshots/
      platform_add_tool_call_policy.png
      platform_add_tool_result_policy.png
      platform_chat_interface.png
      platform_cost_limits.png
      platform_cost_optimization.png
      platform_cost_statistics.png
      platform_dual_llm_configuration.png
      platform_dynamic_tools_edit_popup.png
      platform_logs_viewer.png
      platform_mcp_registry.png
      platform_profiles_management.png
      platform_prompts_create_modal.png
      platform_prompts_library.png
      platform_settings_gateways.png
      platform_tools_management.png
      platform-single-sign-on_sign-in-with-sso.png
      platform-single-sign-on_sso-providers-overview.png
    old_docs/
      platfrom/
        add-tool-call-policy.png
        add-tool-result-policy.png
        agents-page.png
        archestra-decision-tree.png
        dual-llm-1.png
        dual-llm-2.png
        dynamic-tools.png
        mastra-attack-prevented.png
        mastra-attack-success.png
        mastra-platform-logs.png
        n8n-1.png
        n8n-2.png
        n8n-3.png
        openwebui-image1.png
        openwebui-image2.png
        openwebui-image3.png
        openwebui-image4.png
        openwebui-image5.png
        openwebui-image6.png
        policy-get_file.png
        quickstart-1.png
        tool-blocked.png
      a-group-of-people-building-an-archery-hall.png
      a-scientific-discussion.png
      architecture.png
      desktop_screenshot.png
      one-person-is-handling-a-box-for-the-other-over.png
    chat.png
    cncf-logo.png
    cost.png
    dual-llm.png
    fast.png
    linux-foundation-logo.png
    mcp-registry.png
    observability.png
    observibility.png
    orchestrator.png
    screenshot.png
platform/
  backend/
    src/
      auth/
        fastify-plugin/
          index.ts
          middleware.test.ts
          middleware.ts
          plugin.test.ts
          plugin.ts
        better-auth.ts
        index.ts
        member-deletion.test.ts
        utils.test.ts
        utils.ts
      clients/
        chat-mcp-client.test.ts
        chat-mcp-client.ts
        k8s-attach-transport.ts
        mcp-client.test.ts
        mcp-client.ts
      database/
        migrations/
          0000_lush_spiral.sql
          0001_jittery_union_jack.sql
          0002_update_tool_invocation_policy_actions.sql
          0003_peaceful_ultimo.sql
          0004_secret_inertia.sql
          0005_stormy_hammerhead.sql
          0006_military_electro.sql
          0007_smart_hemingway.sql
          0008_curved_shen.sql
          0009_misty_goliath.sql
          0010_neat_zombie.sql
          0011_salty_zodiak.sql
          0012_lame_hammerhead.sql
          0013_curved_lethal_legion.sql
          0014_steady_sprite.sql
          0015_strange_karen_page.sql
          0016_jazzy_jubilee.sql
          0017_talented_iron_fist.sql
          0018_wet_power_man.sql
          0019_curvy_screwball.sql
          0020_ancient_sprite.sql
          0021_fresh_daredevil.sql
          0022_complete_cassandra_nova.sql
          0023_misty_black_bolt.sql
          0024_strange_xavin.sql
          0025_violet_lady_mastermind.sql
          0026_perpetual_proemial_gods.sql
          0027_blue_komodo.sql
          0028_red_adam_destine.sql
          0029_rare_fantastic_four.sql
          0030_groovy_newton_destine.sql
          0031_flaky_kate_bishop.sql
          0032_serious_meggan.sql
          0033_wooden_viper.sql
          0034_fine_loa.sql
          0035_flashy_speed_demon.sql
          0036_massive_sauron.sql
          0037_fluffy_imperial_guard.sql
          0038_great_gamma_corps.sql
          0039_thin_bloodstrike.sql
          0040_foamy_toad_men.sql
          0041_deep_big_bertha.sql
          0042_dear_microbe.sql
          0043_rainy_slayback.sql
          0044_regular_stephen_strange.sql
          0045_puzzling_crystal.sql
          0046_huge_karnak.sql
          0047_opposite_mandarin.sql
          0048_demonic_power_man.sql
          0049_round_human_fly.sql
          0050_steady_talisman.sql
          0051_clever_misty_knight.sql
          0052_amusing_tag.sql
          0053_mature_the_hood.sql
          0054_aberrant_mikhail_rasputin.sql
          0055_green_mockingbird.sql
          0056_clever_forgotten_one.sql
          0057_damp_monster_badoon.sql
          0058_large_firedrake.sql
          0059_nebulous_james_howlett.sql
          0060_demonic_jimmy_woo.sql
          0061_toon_compressor.sql
          0062_burly_shatterstar.sql
          0063_glorious_storm.sql
          0064_interactions_add_toon_cost_savings.sql
          0065_keen_moondragon.sql
          0066_tan_sprite.sql
          0067_many_bloodstorm.sql
          0068_sour_iron_patriot.sql
          0069_magical_king_bedlam.sql
          0070_vault secrets manager.sql
        schemas/
          account.ts
          agent-label.ts
          agent-team.ts
          agent-tool.ts
          agent.ts
          api-key.ts
          chat-settings.ts
          conversation.ts
          dual-llm-config.ts
          dual-llm-result.ts
          index.ts
          interaction.ts
          internal-mcp-catalog.ts
          invitation.ts
          label-key.ts
          label-value.ts
          limit-model-usage.ts
          limit.ts
          mcp-server-installation-request.ts
          mcp-server-team.ts
          mcp-server-user.ts
          mcp-server.ts
          mcp-tool-call.ts
          member.ts
          message.ts
          optimization-rule.ts
          organization-role.ts
          organization.ts
          prompt.ts
          secret.ts
          session.ts
          sso-provider.ts
          team.ts
          token-price.ts
          tool-invocation-policy.ts
          tool.ts
          trusted-data-policy.ts
          two-factor.ts
          user.ts
          verification.ts
        utils/
          pagination.test.ts
          pagination.ts
        index.ts
        seed.ts
      mcp-server-runtime/
        index.ts
        k8s-pod.test.ts
        k8s-pod.ts
        manager.test.ts
        manager.ts
        schemas.ts
      models/
        account.test.ts
        account.ts
        agent-label.test.ts
        agent-label.ts
        agent-team.test.ts
        agent-team.ts
        agent-tool.test.ts
        agent-tool.ts
        agent.test.ts
        agent.ts
        chat-settings.test.ts
        chat-settings.ts
        conversation.test.ts
        conversation.ts
        dual-llm-config.ts
        dual-llm-result.ts
        index.ts
        interaction.test.ts
        interaction.ts
        internal-mcp-catalog.test.ts
        internal-mcp-catalog.ts
        invitation.test.ts
        invitation.ts
        limit.test.ts
        limit.ts
        mcp-server-installation-request.ts
        mcp-server-team.test.ts
        mcp-server-team.ts
        mcp-server-user.test.ts
        mcp-server-user.ts
        mcp-server.ts
        mcp-tool-call.ts
        member.test.ts
        member.ts
        message.ts
        optimization-rule.ts
        organization-role.test.ts
        organization-role.ts
        organization.ts
        prompt.fix.test.ts
        prompt.test.ts
        prompt.ts
        secret.ts
        session.test.ts
        session.ts
        sso-provider.test.ts
        sso-provider.ts
        statistics.test.ts
        statistics.ts
        team.ts
        token-price.test.ts
        token-price.ts
        tool-archestra-assignment.test.ts
        tool-invocation-policy.test.ts
        tool-invocation-policy.ts
        tool.test.ts
        tool.ts
        trusted-data-policy.test.ts
        trusted-data-policy.ts
        user.test.ts
        user.ts
      routes/
        proxy/
          utils/
            adapters/
              anthropic.test.ts
              anthropic.ts
              gemini.ts
              index.ts
              openai.test.ts
              openai.ts
            cost-optimization.ts
            dual-llm-client.ts
            dual-llm-subagent.ts
            index.ts
            tool-invocation.ts
            tools.ts
            toon-conversion.ts
            tracing.ts
            trusted-data.test.ts
            trusted-data.ts
          anthropic.test.ts
          anthropic.ts
          common.ts
          gemini.ts
          mock-anthropic-client.ts
          mock-openai-client.ts
          openai.test.ts
          openai.ts
        agent-tool.ts
        agent.ts
        auth.ts
        autonomy-policies.ts
        chat-settings.ts
        chat.ts
        dual-llm-config.ts
        dual-llm-result.ts
        features.ts
        index.ts
        interaction.ts
        internal-mcp-catalog.ts
        invitation.ts
        limits.ts
        mcp-gateway.ts
        mcp-server-installation-requests.ts
        mcp-server.ts
        mcp-tool-call.ts
        oauth.ts
        optimization-rule.ts
        organization-role.ts
        organization.ts
        prompts.ts
        sso-provider.ts
        statistics.ts
        team.ts
        token-price.ts
        tool.ts
        user.ts
      standalone-scripts/
        mocks/
          agents.ts
          index.ts
          interactions.ts
          tools.ts
          utils.ts
        clean-db-on-dev.ts
        codegen-access-control-docs.ts
        seed-mock-data.ts
      test/
        fixtures.ts
        index.ts
        setup.ts
      tokenizers/
        anthropic.ts
        base.ts
        index.ts
        tiktoken.ts
        tokenizers.test.ts
      types/
        autonomy-policies/
          index.ts
          operator.ts
          tool-invocation.ts
          trusted-data.ts
        llm-providers/
          anthropic/
            api.ts
            index.ts
            messages.ts
            tools.ts
          gemini/
            api.ts
            index.ts
            messages.ts
            tools.ts
          openai/
            api.ts
            index.ts
            messages.ts
            tools.ts
          index.ts
        account.ts
        agent-tool.ts
        agent.ts
        api.ts
        chat-settings.ts
        conversation.ts
        dual-llm-config.ts
        dual-llm-result.ts
        fastify.d.ts
        index.ts
        interaction.ts
        invitation.ts
        label.ts
        limit.ts
        llm-proxy.ts
        mcp-catalog.ts
        mcp-server-installation-request.ts
        mcp-server.ts
        mcp-tool-call.ts
        member.ts
        message.ts
        optimization-rule.ts
        organization.ts
        prompt.ts
        role.ts
        secret.ts
        session.ts
        sso-provider.ts
        statistics.ts
        team.ts
        token-price.ts
        tool-execution.ts
        tool.ts
        user.ts
        websocket.ts
      archestra-mcp-server.test.ts
      archestra-mcp-server.ts
      config.test.ts
      config.ts
      default-model-prices.ts
      llm-metrics.test.ts
      llm-metrics.ts
      logging.ts
      secretsmanager.test.ts
      secretsmanager.ts
      sentry.ts
      server.test.ts
      server.ts
      templating.test.ts
      templating.ts
      tracing.ts
      websocket.ts
    drizzle.config.ts
    knip.config.ts
    tsdown.config.ts
    vitest.config.ts
  benchmarks/
    .env.example
    .gitignore
    cleanup-gcp-benchmark.sh
    run-benchmark.sh
    setup-gcp-benchmark.sh
  dev/
    kubectl
    Tiltfile.database
    Tiltfile.dev
    Tiltfile.integrations
    Tiltfile.test
  e2e-tests/
    tests/
      api/
        access-control.spec.ts
        agents.spec.ts
        auth-permissions.spec.ts
        fixtures.ts
        llm-proxy.spec.ts
        mcp-gateway.spec.ts
        mcp-server-installation-requests.spec.ts
        metrics.spec.ts
        orchestrator.spec.ts
        prompts.spec.ts
        sso-providers.spec.ts
      ui/
        agents.spec.ts
        fixtures.ts
        invitation.spec.ts
        sso-providers.spec.ts
    .gitignore
    auth.setup.ts
    consts.ts
    knip.config.ts
    playwright.config.ts
  examples/
    ai-sdk-express/
      src/
        server.ts
      .env.example
      .gitignore
    mastra-ai/
      src/
        mastra/
          agents/
            github-agent.ts
          tools/
            github-tool.ts
          index.ts
      .env.example
      .gitignore
    pydantic-ai/
      .env.example
      .gitignore
      Dockerfile
      main.py
  experiments/
    dummy_email_mcp_server/
      Dockerfile
      main.py
    src/
      cli-chat.ts
      index.ts
      interceptor.ts
      logger.ts
      main.ts
  frontend/
    public/
      icons/
        gitlab.png
        google.png
        microsoft.png
        okta.png
      logo.png
    src/
      app/
        _parts/
          chat-sidebar-section.tsx
          error-boundary.tsx
          forbidden-page.tsx
          posthog-provider.tsx
          query-client-provider.tsx
          sidebar.tsx
          theme-provider.tsx
          websocket-initializer.tsx
          with-auth-check.test.tsx
          with-auth-check.tsx
          with-page-permissions.tsx
        account/
          [path]/
            page.tsx
        api/
          chat-demo/
            route.ts
        auth/
          _components/
            auth-view-with-error-handling.tsx
          [path]/
            auth-page-with-invitation-check.tsx
            page.tsx
          sign-up-with-invitation/
            page.tsx
          auth-provider.tsx
        chat/
          page.tsx
        cost/
          compression/
            page.tsx
          limits/
            page.tsx
          optimization-rules/
            page.tsx
          statistics/
            page.tsx
          token-price/
            page.tsx
          layout.tsx
          page.tsx
        logs/
          [id]/
            page.client.tsx
            page.tsx
          llm-proxy/
            page.client.tsx
            page.tsx
          mcp-gateway/
            page.client.tsx
            page.tsx
          layout.tsx
          page.tsx
        mcp-catalog/
          _parts/
            archestra-catalog-tab.tsx
            bulk-assign-agent-dialog.tsx
            CatalogFilters.tsx
            create-catalog-dialog.tsx
            custom-server-request-dialog.tsx
            delete-catalog-dialog.tsx
            details-dialog.tsx
            docker-args-parser.ts
            edit-catalog-dialog.tsx
            InternalMCPCatalog.tsx
            local-server-install-dialog.tsx
            manage-local-installations-dialog.tsx
            manage-teams-dialog.tsx
            manage-users-dialog.tsx
            mcp-catalog-form.test.ts
            mcp-catalog-form.tsx
            mcp-catalog-form.types.ts
            mcp-catalog-form.utils.ts
            mcp-logs-dialog.tsx
            mcp-server-card.tsx
            mcp-tools-dialog.tsx
            no-auth-install-dialog.tsx
            reinstall-confirmation-dialog.tsx
            remote-server-install-dialog.tsx
            request-installation-dialog.tsx
            transport-badges.tsx
            uninstall-server-dialog.tsx
          installation-requests/
            [id]/
              page.tsx
            page.tsx
          registry/
            page.client.tsx
            page.tsx
          layout.tsx
          page.tsx
        oauth-callback/
          page.tsx
        organization/
          [path]/
            page.tsx
        profiles/
          agent-actions.tsx
          assign-tools-dialog.tsx
          page.client.tsx
          page.tsx
        settings/
          account/
            page.tsx
          appearance/
            _components/
              font-selector.tsx
              light-dark-toggle.tsx
              logo-upload.tsx
              theme-selector.tsx
            page.tsx
          chat/
            page.tsx
          dual-llm/
            page.tsx
          gateways/
            page.tsx
          members/
            page.tsx
          roles/
            page.tsx
          sso-providers/
            _parts/
              create-sso-provider-dialog.tsx
              edit-sso-provider-dialog.tsx
              oidc-config-form.tsx
              saml-config-form.tsx
            page.tsx
          teams/
            page.tsx
          layout.tsx
          page.tsx
        tools/
          _parts/
            assign-agent-dialog.tsx
            assigned-tools-table.tsx
            policy-card.tsx
            response-modifier-editor.tsx
            tool-call-policies.tsx
            tool-details-dialog.tsx
            tool-readonly-details.tsx
            tool-result-policies.tsx
          layout.tsx
          page.client.tsx
          page.tsx
        favicon.ico
        global-error.tsx
        globals.css
        layout.tsx
        page.tsx
        themes.css
      components/
        ai-elements/
          actions.tsx
          code-block.tsx
          conversation.tsx
          loader.tsx
          message.tsx
          prompt-input.tsx
          reasoning.tsx
          response.tsx
          sources.tsx
          tool.tsx
        chat/
          chat-error.tsx
          chat-messages.tsx
          mcp-tools-display.tsx
          prompt-dialog.tsx
          prompt-library-grid.tsx
          prompt-version-history-dialog.tsx
          stream-timeout-warning.tsx
        roles/
          role-permission-builder.tsx
          roles-list.tsx
          with-permissions.tsx
        teams/
          team-members-dialog.tsx
          teams-list.tsx
        ui/
          accordion.tsx
          alert-dialog.tsx
          alert.tsx
          avatar.tsx
          badge.tsx
          button-group.tsx
          button.tsx
          calendar.tsx
          card.tsx
          checkbox.tsx
          collapsible.tsx
          data-table-pagination.tsx
          data-table.tsx
          dialog.tsx
          dropdown-menu.tsx
          form.tsx
          input.tsx
          label.tsx
          multi-select.tsx
          permission-button.tsx
          popover.tsx
          progress.tsx
          radio-group.tsx
          scroll-area.tsx
          searchable-select.tsx
          select.tsx
          separator.tsx
          sheet.tsx
          sidebar.tsx
          skeleton.tsx
          sonner.tsx
          switch.tsx
          table.tsx
          tabs.tsx
          textarea.tsx
          tooltip-button.tsx
          tooltip.tsx
        agent-labels.tsx
        archestra-architecture-diagram.tsx
        button-with-tooltip.tsx
        chatbot-demo.tsx
        code-text.tsx
        connection-options.tsx
        cost.tsx
        debounced-input.tsx
        default-credentials-warning.tsx
        divider.tsx
        editor.tsx
        environment-variables-form-field.tsx
        error-fallback.tsx
        installation-select.tsx
        invitations-list.tsx
        invite-by-link-card.tsx
        loading.tsx
        mcp-connection-instructions.tsx
        mermaid-diagram.tsx
        mermaid-wrapper.tsx
        oauth-confirmation-dialog.tsx
        onboarding-dialog-wrapper.tsx
        onboarding-dialog.tsx
        org-theme-loader.tsx
        page-layout.tsx
        proxy-connection-instructions.tsx
        savings.tsx
        sso-provider-icons.tsx
        sso-provider-selector.tsx
        token-select.tsx
        truncated-text.tsx
        version.tsx
      config/
        themes.ts
      contexts/
        global-chat-context.tsx
      lib/
        clients/
          auth/
            auth-client.ts
        llmProviders/
          anthropic.ts
          common.ts
          gemini.ts
          openai.ts
        agent-tools.query.ts
        agent.query.ts
        auth.hook.test.ts
        auth.hook.ts
        auth.query.test.tsx
        auth.query.ts
        auth.utils.test.ts
        auth.utils.ts
        chat-settings.query.ts
        chat.query.ts
        config.test.ts
        config.ts
        dialog.hook.ts
        dual-llm-config.query.ts
        dual-llm-result.query.ts
        external-mcp-catalog.query.ts
        features.hook.ts
        features.query.ts
        github.query.ts
        health.query.ts
        interaction.query.ts
        interaction.utils.ts
        internal-mcp-catalog.query.ts
        invitation.query.ts
        lifecycle.hook.ts
        limits.query.ts
        mcp-server-installation-request.query.ts
        mcp-server.query.ts
        mcp-tool-call.query.ts
        optimization-rule.query.ts
        organization.query.ts
        policy.query.ts
        prompts.query.ts
        role.query.ts
        server-utils.ts
        sso-provider.query.ts
        statistics.query.ts
        team.query.ts
        theme.hook.ts
        token-price.query.ts
        tool.query.ts
        tool.utils.ts
        use-mobile.hook.ts
        utils.ts
        websocket.ts
      consts.ts
      instrumentation-client.ts
      instrumentation.ts
    knip.config.ts
    next.config.ts
    postcss.config.mjs
    sentry.edge.config.ts
    sentry.server.config.ts
    vitest-setup.ts
    vitest.config.ts
  helm/
    archestra/
      templates/
        _helpers.tpl
      .helmignore
      Chart.lock
  mcp_server_docker_image/
    Dockerfile
  shared/
    themes/
      generate-theme-css.ts
      theme-config.ts
      theme-utils.ts
    access-control.ts
    consts.ts
    index.ts
    knip.config.ts
    types.ts
    zod-schemas.ts
  .cursorrules
  .dockerignore
  .editorconfig
  .env.example
  .gitignore
  .npmrc
  docker-banner.sh
  Dockerfile
  LICENSE
  Tiltfile
.gitignore
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/commitlint.config.js">

</file>

<file path="platform/backend/src/auth/fastify-plugin/index.ts">

</file>

<file path="platform/backend/src/auth/fastify-plugin/plugin.test.ts">
import type { FastifyInstance, FastifyReply, FastifyRequest } from "fastify";
import { vi } from "vitest";
import {
  beforeEach,
  describe,
  expect,
  type MockedFunction,
  test,
} from "@/test";
⋮----
import { betterAuth, hasPermission } from "@/auth";
import { UserModel } from "@/models";
⋮----
import { Authnz } from "./middleware";
import { authPlugin } from "./plugin";
type Session = Awaited<ReturnType<typeof betterAuth.api.getSession>>;
type User = Awaited<ReturnType<typeof UserModel.getById>>;
type ApiKey = Awaited<ReturnType<typeof betterAuth.api.verifyApiKey>>["key"];
</file>

<file path="platform/backend/src/auth/fastify-plugin/plugin.ts">
import type { FastifyInstance } from "fastify";
import fp from "fastify-plugin";
import { Authnz } from "./middleware";
</file>

<file path="platform/backend/src/auth/index.ts">

</file>

<file path="platform/backend/src/auth/utils.test.ts">
import type { IncomingHttpHeaders } from "node:http";
import type { Permissions } from "@shared";
import { vi } from "vitest";
import {
  beforeEach,
  describe,
  expect,
  type MockedFunction,
  test,
} from "@/test";
import { hasPermission } from "./utils";
⋮----
import { auth as betterAuth } from "./better-auth";
⋮----
type ApiKey = Awaited<ReturnType<typeof betterAuth.api.verifyApiKey>>["key"];
</file>

<file path="platform/backend/src/auth/utils.ts">
import type { IncomingHttpHeaders } from "node:http";
import type { Permissions } from "@shared";
import { auth as betterAuth } from "./better-auth";
export const hasPermission = async (
  permissions: Permissions,
  requestHeaders: IncomingHttpHeaders,
): Promise<
</file>

<file path="platform/backend/src/clients/k8s-attach-transport.ts">
import { Readable, Writable } from "node:stream";
import type { Attach } from "@kubernetes/client-node";
import {
  ReadBuffer,
  serializeMessage,
} from "@modelcontextprotocol/sdk/shared/stdio.js";
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import type { JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
import type WebSocket from "ws";
import logger from "@/logging";
export interface K8sAttachTransportParams {
  k8sAttach: Attach;
  namespace: string;
  podName: string;
  containerName: string;
}
export class K8sAttachTransport implements Transport
⋮----
constructor(private params: K8sAttachTransportParams)
async start(): Promise<void>
⋮----
read()
⋮----
async send(message: JSONRPCMessage): Promise<void>
async close(): Promise<void>
</file>

<file path="platform/backend/src/database/migrations/0000_lush_spiral.sql">
CREATE TABLE "agent_tool_invocation_policies" (
	"agent_id" uuid NOT NULL,
	"policy_id" uuid NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_tool_invocation_policies_agent_id_policy_id_pk" PRIMARY KEY("agent_id","policy_id")
);
CREATE TABLE "agent_trusted_data_policies" (
	"agent_id" uuid NOT NULL,
	"policy_id" uuid NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_trusted_data_policies_agent_id_policy_id_pk" PRIMARY KEY("agent_id","policy_id")
);
CREATE TABLE "agents" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"name" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "chats" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "interactions" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"chat_id" uuid NOT NULL,
	"content" jsonb NOT NULL,
	"tainted" boolean DEFAULT false NOT NULL,
	"taint_reason" text,
	"created_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "tool_invocation_policies" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"tool_id" uuid NOT NULL,
	"description" text NOT NULL,
	"argument_name" text NOT NULL,
	"operator" text NOT NULL,
	"value" text NOT NULL,
	"action" text NOT NULL,
	"block_prompt" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "tools" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"name" text NOT NULL,
	"parameters" jsonb DEFAULT '{}'::jsonb NOT NULL,
	"description" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "tools_name_unique" UNIQUE("name")
);
CREATE TABLE "trusted_data_policies" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"tool_id" uuid NOT NULL,
	"description" text NOT NULL,
	"attribute_path" text NOT NULL,
	"operator" text NOT NULL,
	"value" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "agent_tool_invocation_policies" ADD CONSTRAINT "agent_tool_invocation_policies_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_tool_invocation_policies" ADD CONSTRAINT "agent_tool_invocation_policies_policy_id_tool_invocation_policies_id_fk" FOREIGN KEY ("policy_id") REFERENCES "public"."tool_invocation_policies"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_trusted_data_policies" ADD CONSTRAINT "agent_trusted_data_policies_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_trusted_data_policies" ADD CONSTRAINT "agent_trusted_data_policies_policy_id_trusted_data_policies_id_fk" FOREIGN KEY ("policy_id") REFERENCES "public"."trusted_data_policies"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "chats" ADD CONSTRAINT "chats_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "interactions" ADD CONSTRAINT "interactions_chat_id_chats_id_fk" FOREIGN KEY ("chat_id") REFERENCES "public"."chats"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "tool_invocation_policies" ADD CONSTRAINT "tool_invocation_policies_tool_id_tools_id_fk" FOREIGN KEY ("tool_id") REFERENCES "public"."tools"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "tools" ADD CONSTRAINT "tools_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "trusted_data_policies" ADD CONSTRAINT "trusted_data_policies_tool_id_tools_id_fk" FOREIGN KEY ("tool_id") REFERENCES "public"."tools"("id") ON DELETE cascade ON UPDATE no action;
CREATE INDEX "interactions_chat_id_idx" ON "interactions" USING btree ("chat_id");
</file>

<file path="platform/backend/src/database/migrations/0001_jittery_union_jack.sql">
ALTER TABLE "chats" ADD COLUMN "hash_for_id" text;
</file>

<file path="platform/backend/src/database/migrations/0002_update_tool_invocation_policy_actions.sql">
UPDATE "tool_invocation_policies"
SET "action" = 'allow_when_context_is_untrusted'
WHERE "action" = 'allow';
UPDATE "tool_invocation_policies"
SET "action" = 'block_always'
WHERE "action" = 'block';
</file>

<file path="platform/backend/src/database/migrations/0003_peaceful_ultimo.sql">
ALTER TABLE "tool_invocation_policies" RENAME COLUMN "block_prompt" TO "reason";
ALTER TABLE "tool_invocation_policies" DROP COLUMN "description";
</file>

<file path="platform/backend/src/database/migrations/0004_secret_inertia.sql">
ALTER TABLE "tools" ADD COLUMN "allow_usage_when_untrusted_data_is_present" boolean DEFAULT false NOT NULL;
ALTER TABLE "tools" ADD COLUMN "data_is_trusted_by_default" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0005_stormy_hammerhead.sql">
ALTER TABLE "interactions" RENAME COLUMN "taint_reason" TO "reason";
ALTER TABLE "interactions" ADD COLUMN "blocked" boolean DEFAULT false NOT NULL;
ALTER TABLE "trusted_data_policies" ADD COLUMN "action" text DEFAULT 'allow' NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0006_military_electro.sql">
ALTER TABLE "interactions" RENAME COLUMN "tainted" TO "trusted";
UPDATE "interactions" SET "trusted" = NOT "trusted";
</file>

<file path="platform/backend/src/database/migrations/0007_smart_hemingway.sql">
ALTER TABLE "agent_tool_invocation_policies" DISABLE ROW LEVEL SECURITY;
ALTER TABLE "agent_trusted_data_policies" DISABLE ROW LEVEL SECURITY;
DROP TABLE "agent_tool_invocation_policies" CASCADE;
DROP TABLE "agent_trusted_data_policies" CASCADE;
ALTER TABLE "trusted_data_policies" ALTER COLUMN "action" SET DEFAULT 'mark_as_trusted';
</file>

<file path="platform/backend/src/database/migrations/0008_curved_shen.sql">
ALTER TABLE "chats" DISABLE ROW LEVEL SECURITY;
DROP TABLE "chats" CASCADE;
DROP INDEX "interactions_chat_id_idx";
ALTER TABLE "interactions" ADD COLUMN "agent_id" uuid NOT NULL;
ALTER TABLE "interactions" ADD COLUMN "request" jsonb NOT NULL;
ALTER TABLE "interactions" ADD COLUMN "response" jsonb NOT NULL;
ALTER TABLE "interactions" ADD CONSTRAINT "interactions_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
CREATE INDEX "interactions_agent_id_idx" ON "interactions" USING btree ("agent_id");
ALTER TABLE "interactions" DROP COLUMN "chat_id";
ALTER TABLE "interactions" DROP COLUMN "content";
ALTER TABLE "interactions" DROP COLUMN "trusted";
ALTER TABLE "interactions" DROP COLUMN "blocked";
ALTER TABLE "interactions" DROP COLUMN "reason";
</file>

<file path="platform/backend/src/database/migrations/0009_misty_goliath.sql">
ALTER TABLE "agents" ADD COLUMN "is_demo" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0010_neat_zombie.sql">
ALTER TABLE "tools" DROP CONSTRAINT "tools_name_unique";
ALTER TABLE "tools" ADD CONSTRAINT "tools_agent_id_name_unique" UNIQUE("agent_id","name");
</file>

<file path="platform/backend/src/database/migrations/0011_salty_zodiak.sql">
CREATE TABLE "dual_llm_config" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"main_agent_prompt" text NOT NULL,
	"quarantined_agent_prompt" text NOT NULL,
	"summary_prompt" text NOT NULL,
	"max_rounds" integer DEFAULT 5 NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
</file>

<file path="platform/backend/src/database/migrations/0012_lame_hammerhead.sql">
CREATE TABLE "dual_llm_results" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"tool_call_id" text NOT NULL,
	"conversations" jsonb NOT NULL,
	"result" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "dual_llm_results" ADD CONSTRAINT "dual_llm_results_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
CREATE INDEX "dual_llm_results_agent_id_idx" ON "dual_llm_results" USING btree ("agent_id");
</file>

<file path="platform/backend/src/database/migrations/0013_curved_lethal_legion.sql">
ALTER TABLE "dual_llm_config" ADD COLUMN "enabled" boolean DEFAULT true NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0014_steady_sprite.sql">
ALTER TABLE "dual_llm_config" ALTER COLUMN "enabled" SET DEFAULT false;
</file>

<file path="platform/backend/src/database/migrations/0015_strange_karen_page.sql">
ALTER TABLE "interactions" ADD COLUMN "type" varchar NOT NULL DEFAULT 'openai:chatCompletions';
</file>

<file path="platform/backend/src/database/migrations/0016_jazzy_jubilee.sql">
CREATE TABLE "account" (
	"id" text PRIMARY KEY NOT NULL,
	"account_id" text NOT NULL,
	"provider_id" text NOT NULL,
	"user_id" text NOT NULL,
	"access_token" text,
	"refresh_token" text,
	"id_token" text,
	"access_token_expires_at" timestamp,
	"refresh_token_expires_at" timestamp,
	"scope" text,
	"password" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL
);
CREATE TABLE "invitation" (
	"id" text PRIMARY KEY NOT NULL,
	"organization_id" text NOT NULL,
	"email" text NOT NULL,
	"role" text,
	"status" text DEFAULT 'pending' NOT NULL,
	"expires_at" timestamp NOT NULL,
	"inviter_id" text NOT NULL
);
CREATE TABLE "member" (
	"id" text PRIMARY KEY NOT NULL,
	"organization_id" text NOT NULL,
	"user_id" text NOT NULL,
	"role" text DEFAULT 'member' NOT NULL,
	"created_at" timestamp NOT NULL
);
CREATE TABLE "organization" (
	"id" text PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"slug" text NOT NULL,
	"logo" text,
	"created_at" timestamp NOT NULL,
	"metadata" text,
	CONSTRAINT "organization_slug_unique" UNIQUE("slug")
);
CREATE TABLE "session" (
	"id" text PRIMARY KEY NOT NULL,
	"expires_at" timestamp NOT NULL,
	"token" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL,
	"ip_address" text,
	"user_agent" text,
	"user_id" text NOT NULL,
	"active_organization_id" text,
	"impersonated_by" text,
	CONSTRAINT "session_token_unique" UNIQUE("token")
);
CREATE TABLE "user" (
	"id" text PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"email" text NOT NULL,
	"email_verified" boolean DEFAULT false NOT NULL,
	"image" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	"role" text,
	"banned" boolean DEFAULT false,
	"ban_reason" text,
	"ban_expires" timestamp,
	CONSTRAINT "user_email_unique" UNIQUE("email")
);
CREATE TABLE "verification" (
	"id" text PRIMARY KEY NOT NULL,
	"identifier" text NOT NULL,
	"value" text NOT NULL,
	"expires_at" timestamp NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "account" ADD CONSTRAINT "account_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "invitation" ADD CONSTRAINT "invitation_organization_id_organization_id_fk" FOREIGN KEY ("organization_id") REFERENCES "public"."organization"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "invitation" ADD CONSTRAINT "invitation_inviter_id_user_id_fk" FOREIGN KEY ("inviter_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "member" ADD CONSTRAINT "member_organization_id_organization_id_fk" FOREIGN KEY ("organization_id") REFERENCES "public"."organization"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "member" ADD CONSTRAINT "member_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "session" ADD CONSTRAINT "session_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0017_talented_iron_fist.sql">
CREATE TABLE "agent_access_control" (
	"agent_id" uuid NOT NULL,
	"user_id" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_access_control_agent_id_user_id_pk" PRIMARY KEY("agent_id","user_id")
);
ALTER TABLE "agent_access_control" ADD CONSTRAINT "agent_access_control_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_access_control" ADD CONSTRAINT "agent_access_control_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0018_wet_power_man.sql">
ALTER TABLE "tools" ADD COLUMN "tool_result_treatment" text DEFAULT 'untrusted' NOT NULL;
ALTER TABLE "tools" DROP COLUMN "data_is_trusted_by_default";
</file>

<file path="platform/backend/src/database/migrations/0019_curvy_screwball.sql">
CREATE TABLE "mcp_catalog" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"name" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "mcp_server" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"name" text NOT NULL,
	"catalog_id" uuid,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "organization" ADD COLUMN "has_seeded_mcp_catalog" boolean DEFAULT false NOT NULL;
ALTER TABLE "mcp_server" ADD CONSTRAINT "mcp_server_catalog_id_mcp_catalog_id_fk" FOREIGN KEY ("catalog_id") REFERENCES "public"."mcp_catalog"("id") ON DELETE set null ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0020_ancient_sprite.sql">
CREATE TABLE "apikey" (
	"id" text PRIMARY KEY NOT NULL,
	"name" text,
	"start" text,
	"prefix" text,
	"key" text NOT NULL,
	"user_id" text NOT NULL,
	"refill_interval" integer,
	"refill_amount" integer,
	"last_refill_at" timestamp,
	"enabled" boolean DEFAULT true,
	"rate_limit_enabled" boolean DEFAULT true,
	"rate_limit_time_window" integer DEFAULT 86400000,
	"rate_limit_max" integer DEFAULT 10,
	"request_count" integer DEFAULT 0,
	"remaining" integer,
	"last_request" timestamp,
	"expires_at" timestamp,
	"created_at" timestamp NOT NULL,
	"updated_at" timestamp NOT NULL,
	"permissions" text,
	"metadata" text
);
ALTER TABLE "apikey" ADD CONSTRAINT "apikey_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0021_fresh_daredevil.sql">
CREATE TABLE "agent_tools" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"tool_id" uuid NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_tools_agent_id_tool_id_unique" UNIQUE("agent_id","tool_id")
);
ALTER TABLE "tools" ALTER COLUMN "agent_id" DROP NOT NULL;
ALTER TABLE "tools" ADD COLUMN "source" text DEFAULT 'proxy' NOT NULL;
ALTER TABLE "tools" ADD COLUMN "mcp_server_id" uuid;
ALTER TABLE "agent_tools" ADD CONSTRAINT "agent_tools_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_tools" ADD CONSTRAINT "agent_tools_tool_id_tools_id_fk" FOREIGN KEY ("tool_id") REFERENCES "public"."tools"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "tools" ADD CONSTRAINT "tools_mcp_server_id_mcp_server_id_fk" FOREIGN KEY ("mcp_server_id") REFERENCES "public"."mcp_server"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0022_complete_cassandra_nova.sql">
ALTER TABLE "mcp_server" ADD COLUMN "metadata" jsonb DEFAULT '{}'::jsonb NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0023_misty_black_bolt.sql">
ALTER TABLE "mcp_catalog" ADD COLUMN "description" text;
ALTER TABLE "mcp_catalog" ADD COLUMN "repository" text;
ALTER TABLE "mcp_catalog" ADD COLUMN "installation_command" text;
ALTER TABLE "mcp_catalog" ADD COLUMN "requires_auth" boolean DEFAULT false NOT NULL;
ALTER TABLE "mcp_catalog" ADD COLUMN "auth_description" text;
ALTER TABLE "mcp_catalog" ADD COLUMN "auth_fields" jsonb DEFAULT '[]'::jsonb;
</file>

<file path="platform/backend/src/database/migrations/0024_strange_xavin.sql">
ALTER TABLE "tool_invocation_policies" RENAME COLUMN "tool_id" TO "agent_tool_id";
ALTER TABLE "trusted_data_policies" RENAME COLUMN "tool_id" TO "agent_tool_id";
ALTER TABLE "tool_invocation_policies" DROP CONSTRAINT "tool_invocation_policies_tool_id_tools_id_fk";
ALTER TABLE "trusted_data_policies" DROP CONSTRAINT "trusted_data_policies_tool_id_tools_id_fk";
ALTER TABLE "agent_tools" ADD COLUMN "allow_usage_when_untrusted_data_is_present" boolean DEFAULT false NOT NULL;
ALTER TABLE "agent_tools" ADD COLUMN "tool_result_treatment" text DEFAULT 'untrusted' NOT NULL;
ALTER TABLE "tool_invocation_policies" ADD CONSTRAINT "tool_invocation_policies_agent_tool_id_agent_tools_id_fk" FOREIGN KEY ("agent_tool_id") REFERENCES "public"."agent_tools"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "trusted_data_policies" ADD CONSTRAINT "trusted_data_policies_agent_tool_id_agent_tools_id_fk" FOREIGN KEY ("agent_tool_id") REFERENCES "public"."agent_tools"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "tools" DROP COLUMN "source";
ALTER TABLE "tools" DROP COLUMN "allow_usage_when_untrusted_data_is_present";
ALTER TABLE "tools" DROP COLUMN "tool_result_treatment";
</file>

<file path="platform/backend/src/database/migrations/0025_violet_lady_mastermind.sql">
ALTER TABLE "mcp_catalog" ADD COLUMN "version" text;
</file>

<file path="platform/backend/src/database/migrations/0026_perpetual_proemial_gods.sql">
ALTER TABLE "mcp_catalog" RENAME TO "internal_mcp_catalog";
ALTER TABLE "mcp_server" DROP CONSTRAINT "mcp_server_catalog_id_mcp_catalog_id_fk";
ALTER TABLE "mcp_server" ADD CONSTRAINT "mcp_server_catalog_id_internal_mcp_catalog_id_fk" FOREIGN KEY ("catalog_id") REFERENCES "public"."internal_mcp_catalog"("id") ON DELETE set null ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0027_blue_komodo.sql">
ALTER TABLE "agent_tools" ADD COLUMN "response_modifier_template" text;
</file>

<file path="platform/backend/src/database/migrations/0028_red_adam_destine.sql">
ALTER TABLE "agents" ADD COLUMN "is_default" boolean DEFAULT false NOT NULL;
UPDATE "agents" SET "is_default" = true WHERE "name" = 'Default Agent with Archestra';
</file>

<file path="platform/backend/src/database/migrations/0029_rare_fantastic_four.sql">
CREATE TABLE "agent_team" (
	"agent_id" uuid NOT NULL,
	"team_id" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_team_agent_id_team_id_pk" PRIMARY KEY("agent_id","team_id")
);
CREATE TABLE "mcp_server_team" (
	"mcp_server_id" uuid NOT NULL,
	"team_id" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "mcp_server_team_mcp_server_id_team_id_pk" PRIMARY KEY("mcp_server_id","team_id")
);
CREATE TABLE "team" (
	"id" text PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"description" text,
	"organization_id" text NOT NULL,
	"created_by" text NOT NULL,
	"created_at" timestamp NOT NULL,
	"updated_at" timestamp NOT NULL
);
CREATE TABLE "team_member" (
	"id" text PRIMARY KEY NOT NULL,
	"team_id" text NOT NULL,
	"user_id" text NOT NULL,
	"role" text DEFAULT 'member' NOT NULL,
	"created_at" timestamp NOT NULL
);
DROP TABLE "agent_access_control" CASCADE;
ALTER TABLE "agent_team" ADD CONSTRAINT "agent_team_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_team" ADD CONSTRAINT "agent_team_team_id_team_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."team"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "mcp_server_team" ADD CONSTRAINT "mcp_server_team_mcp_server_id_mcp_server_id_fk" FOREIGN KEY ("mcp_server_id") REFERENCES "public"."mcp_server"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "mcp_server_team" ADD CONSTRAINT "mcp_server_team_team_id_team_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."team"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "team" ADD CONSTRAINT "team_organization_id_organization_id_fk" FOREIGN KEY ("organization_id") REFERENCES "public"."organization"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "team" ADD CONSTRAINT "team_created_by_user_id_fk" FOREIGN KEY ("created_by") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "team_member" ADD CONSTRAINT "team_member_team_id_team_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."team"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "team_member" ADD CONSTRAINT "team_member_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0030_groovy_newton_destine.sql">
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "label" text;
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "server_type" text;
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "server_url" text;
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "docs_url" text;
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "user_config" jsonb DEFAULT '{}'::jsonb;
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "oauth_config" jsonb;
</file>

<file path="platform/backend/src/database/migrations/0031_flaky_kate_bishop.sql">
CREATE TABLE "secret" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"secret" jsonb DEFAULT '{}'::jsonb NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "mcp_server" ADD COLUMN "secret_id" uuid;
ALTER TABLE "mcp_server" ADD CONSTRAINT "mcp_server_secret_id_secret_id_fk" FOREIGN KEY ("secret_id") REFERENCES "public"."secret"("id") ON DELETE set null ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0032_serious_meggan.sql">
ALTER TABLE "mcp_server" DROP COLUMN "metadata";
</file>

<file path="platform/backend/src/database/migrations/0033_wooden_viper.sql">
ALTER TABLE "mcp_server" ADD COLUMN "reinstall_required" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0034_fine_loa.sql">
CREATE TABLE "mcp_server_installation_request" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"external_catalog_id" text,
	"requested_by" text NOT NULL,
	"status" text DEFAULT 'pending' NOT NULL,
	"request_reason" text,
	"custom_server_config" jsonb DEFAULT 'null'::jsonb,
	"admin_response" text,
	"reviewed_by" text,
	"reviewed_at" timestamp,
	"notes" jsonb DEFAULT '[]'::jsonb,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "mcp_server_installation_request" ADD CONSTRAINT "mcp_server_installation_request_requested_by_user_id_fk" FOREIGN KEY ("requested_by") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "mcp_server_installation_request" ADD CONSTRAINT "mcp_server_installation_request_reviewed_by_user_id_fk" FOREIGN KEY ("reviewed_by") REFERENCES "public"."user"("id") ON DELETE set null ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0035_flashy_speed_demon.sql">
ALTER TABLE "internal_mcp_catalog" ALTER COLUMN "server_type" SET NOT NULL;
ALTER TABLE "mcp_server" ALTER COLUMN "catalog_id" SET NOT NULL;
ALTER TABLE "internal_mcp_catalog" ADD COLUMN "local_config" jsonb;
ALTER TABLE "mcp_server" ADD COLUMN "local_installation_status" text DEFAULT 'idle' NOT NULL;
ALTER TABLE "mcp_server" ADD COLUMN "local_installation_error" text;
</file>

<file path="platform/backend/src/database/migrations/0036_massive_sauron.sql">
CREATE TABLE "mcp_tool_calls" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"mcp_server_name" varchar(255) NOT NULL,
	"tool_call" jsonb NOT NULL,
	"tool_result" jsonb NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "mcp_tool_calls" ADD CONSTRAINT "mcp_tool_calls_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
CREATE INDEX "mcp_tool_calls_agent_id_idx" ON "mcp_tool_calls" USING btree ("agent_id");
CREATE INDEX "mcp_tool_calls_created_at_idx" ON "mcp_tool_calls" USING btree ("created_at");
</file>

<file path="platform/backend/src/database/migrations/0037_fluffy_imperial_guard.sql">
CREATE TABLE "agent_labels" (
	"agent_id" uuid NOT NULL,
	"key_id" uuid NOT NULL,
	"value_id" uuid NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_labels_agent_id_key_id_pk" PRIMARY KEY("agent_id","key_id")
);
CREATE TABLE "label_keys" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"key" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "label_keys_key_unique" UNIQUE("key")
);
CREATE TABLE "label_values" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"value" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "label_values_value_unique" UNIQUE("value")
);
ALTER TABLE "agent_labels" ADD CONSTRAINT "agent_labels_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_labels" ADD CONSTRAINT "agent_labels_key_id_label_keys_id_fk" FOREIGN KEY ("key_id") REFERENCES "public"."label_keys"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_labels" ADD CONSTRAINT "agent_labels_value_id_label_values_id_fk" FOREIGN KEY ("value_id") REFERENCES "public"."label_values"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0038_great_gamma_corps.sql">
ALTER TABLE "internal_mcp_catalog" DROP COLUMN "label";
</file>

<file path="platform/backend/src/database/migrations/0039_thin_bloodstrike.sql">
CREATE TABLE "mcp_server_user" (
	"mcp_server_id" uuid NOT NULL,
	"user_id" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "mcp_server_user_mcp_server_id_user_id_pk" PRIMARY KEY("mcp_server_id","user_id")
);
ALTER TABLE "agent_tools" ADD COLUMN "credential_source_mcp_server_id" uuid;
ALTER TABLE "mcp_server" ADD COLUMN "owner_id" text;
ALTER TABLE "mcp_server" ADD COLUMN "auth_type" text;
ALTER TABLE "mcp_server_user" ADD CONSTRAINT "mcp_server_user_mcp_server_id_mcp_server_id_fk" FOREIGN KEY ("mcp_server_id") REFERENCES "public"."mcp_server"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "mcp_server_user" ADD CONSTRAINT "mcp_server_user_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_tools" ADD CONSTRAINT "agent_tools_credential_source_mcp_server_id_mcp_server_id_fk" FOREIGN KEY ("credential_source_mcp_server_id") REFERENCES "public"."mcp_server"("id") ON DELETE set null ON UPDATE no action;
ALTER TABLE "mcp_server" ADD CONSTRAINT "mcp_server_owner_id_user_id_fk" FOREIGN KEY ("owner_id") REFERENCES "public"."user"("id") ON DELETE set null ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0040_foamy_toad_men.sql">
ALTER TABLE "interactions" ADD COLUMN "input_tokens" integer;
ALTER TABLE "interactions" ADD COLUMN "output_tokens" integer;
</file>

<file path="platform/backend/src/database/migrations/0041_deep_big_bertha.sql">
ALTER TABLE "interactions" ADD COLUMN "model" varchar;
</file>

<file path="platform/backend/src/database/migrations/0042_dear_microbe.sql">
ALTER TABLE "organization" ADD COLUMN "theme" text DEFAULT 'cosmic-night' NOT NULL;
ALTER TABLE "organization" ADD COLUMN "custom_font" text DEFAULT 'lato' NOT NULL;
ALTER TABLE "organization" ADD COLUMN "logo_type" text DEFAULT 'default' NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0043_rainy_slayback.sql">
CREATE TABLE "limits" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"entity_type" varchar NOT NULL,
	"entity_id" text NOT NULL,
	"limit_type" varchar NOT NULL,
	"limit_value" integer NOT NULL,
	"current_usage_tokens_in" integer DEFAULT 0 NOT NULL,
	"current_usage_tokens_out" integer DEFAULT 0 NOT NULL,
	"mcp_server_name" varchar(255),
	"tool_name" varchar(255),
	"model" varchar(255),
	"last_cleanup" timestamp,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "token_price" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"model" varchar(255) NOT NULL,
	"price_per_million_input" numeric(10, 2) NOT NULL,
	"price_per_million_output" numeric(10, 2) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "token_price_model_unique" UNIQUE("model")
);
ALTER TABLE "organization" ADD COLUMN "limit_cleanup_interval" varchar DEFAULT '1h';
CREATE INDEX "limits_entity_idx" ON "limits" USING btree ("entity_type","entity_id");
CREATE INDEX "limits_type_idx" ON "limits" USING btree ("limit_type");
CREATE INDEX "token_price_model_idx" ON "token_price" USING btree ("model");
</file>

<file path="platform/backend/src/database/migrations/0044_regular_stephen_strange.sql">
CREATE TABLE "conversations" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"user_id" text NOT NULL,
	"organization_id" text NOT NULL,
	"title" text,
	"selected_model" text DEFAULT 'gpt-4o' NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
CREATE TABLE "messages" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"conversation_id" uuid NOT NULL,
	"role" text NOT NULL,
	"content" jsonb NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "messages" ADD CONSTRAINT "messages_conversation_id_conversations_id_fk" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0045_puzzling_crystal.sql">
CREATE TABLE "two_factor" (
	"id" text PRIMARY KEY NOT NULL,
	"secret" text NOT NULL,
	"backup_codes" text NOT NULL,
	"user_id" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "user" ADD COLUMN "two_factor_enabled" boolean DEFAULT false;
ALTER TABLE "two_factor" ADD CONSTRAINT "two_factor_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0046_huge_karnak.sql">
ALTER TABLE "tools" DROP CONSTRAINT "tools_agent_id_name_unique";
ALTER TABLE "tools" DROP CONSTRAINT "tools_mcp_server_id_mcp_server_id_fk";
ALTER TABLE "agent_tools" ADD COLUMN "execution_source_mcp_server_id" uuid;
ALTER TABLE "mcp_server" ADD COLUMN "server_type" text NOT NULL DEFAULT 'local';
ALTER TABLE "tools" ADD COLUMN "catalog_id" uuid;
ALTER TABLE "agent_tools" ADD CONSTRAINT "agent_tools_execution_source_mcp_server_id_mcp_server_id_fk" FOREIGN KEY ("execution_source_mcp_server_id") REFERENCES "public"."mcp_server"("id") ON DELETE set null ON UPDATE no action;
ALTER TABLE "tools" ADD CONSTRAINT "tools_catalog_id_internal_mcp_catalog_id_fk" FOREIGN KEY ("catalog_id") REFERENCES "public"."internal_mcp_catalog"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "tools" ADD CONSTRAINT "tools_mcp_server_id_mcp_server_id_fk" FOREIGN KEY ("mcp_server_id") REFERENCES "public"."mcp_server"("id") ON DELETE set null ON UPDATE no action;
ALTER TABLE "tools" ADD CONSTRAINT "tools_catalog_id_name_agent_id_unique" UNIQUE("catalog_id","name","agent_id");
</file>

<file path="platform/backend/src/database/migrations/0047_opposite_mandarin.sql">
CREATE TABLE "organization_role" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"organization_id" text NOT NULL,
	"name" text NOT NULL,
	"permission" jsonb NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp,
	CONSTRAINT "organization_role_organization_id_name_unique" UNIQUE("organization_id","name")
);
ALTER TABLE "organization_role" ADD CONSTRAINT "organization_role_organization_id_organization_id_fk" FOREIGN KEY ("organization_id") REFERENCES "public"."organization"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0048_demonic_power_man.sql">
ALTER TABLE "organization" DROP COLUMN "has_seeded_mcp_catalog";
ALTER TABLE "organization" DROP COLUMN "logo_type";
</file>

<file path="platform/backend/src/database/migrations/0049_round_human_fly.sql">
ALTER TABLE "mcp_tool_calls" ALTER COLUMN "tool_call" DROP NOT NULL;
ALTER TABLE "mcp_tool_calls" ALTER COLUMN "tool_result" DROP NOT NULL;
ALTER TABLE "mcp_tool_calls" ADD COLUMN "method" varchar(255);
UPDATE "mcp_tool_calls" SET "method" = 'tools/call' WHERE "method" IS NULL;
ALTER TABLE "mcp_tool_calls" ALTER COLUMN "method" SET NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0050_steady_talisman.sql">
ALTER TABLE "conversations" ADD COLUMN "agent_id" uuid;
INSERT INTO "agents" (id, name, is_demo, is_default, created_at, updated_at)
SELECT gen_random_uuid(), 'Default Agent', false, true, now(), now()
WHERE NOT EXISTS (
  SELECT 1 FROM "agents" WHERE is_default = true
);
UPDATE "conversations"
SET "agent_id" = (SELECT id FROM "agents" WHERE is_default = true LIMIT 1)
WHERE "agent_id" IS NULL;
ALTER TABLE "conversations" ALTER COLUMN "agent_id" SET NOT NULL;
ALTER TABLE "conversations" ADD CONSTRAINT "conversations_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0051_clever_misty_knight.sql">
CREATE TABLE "agent_prompts" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"prompt_id" uuid NOT NULL,
	"order" integer DEFAULT 0 NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "agent_prompts_agent_id_prompt_id_unique" UNIQUE("agent_id","prompt_id")
);
CREATE TABLE "chat_settings" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"organization_id" text NOT NULL,
	"anthropic_api_key_secret_id" uuid,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "chat_settings_organization_id_unique" UNIQUE("organization_id")
);
CREATE TABLE "prompts" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"organization_id" text NOT NULL,
	"name" text NOT NULL,
	"type" text NOT NULL,
	"content" text NOT NULL,
	"version" integer DEFAULT 1 NOT NULL,
	"parent_prompt_id" uuid,
	"is_active" boolean DEFAULT true NOT NULL,
	"created_by" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "agent_prompts" ADD CONSTRAINT "agent_prompts_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "agent_prompts" ADD CONSTRAINT "agent_prompts_prompt_id_prompts_id_fk" FOREIGN KEY ("prompt_id") REFERENCES "public"."prompts"("id") ON DELETE cascade ON UPDATE no action;
ALTER TABLE "chat_settings" ADD CONSTRAINT "chat_settings_anthropic_api_key_secret_id_secret_id_fk" FOREIGN KEY ("anthropic_api_key_secret_id") REFERENCES "public"."secret"("id") ON DELETE set null ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0052_amusing_tag.sql">
CREATE TABLE "optimization_rules" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"agent_id" uuid NOT NULL,
	"rule_type" text NOT NULL,
	"conditions" jsonb NOT NULL,
	"provider" text NOT NULL,
	"target_model" text NOT NULL,
	"priority" integer DEFAULT 0 NOT NULL,
	"enabled" boolean DEFAULT true NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "mcp_server" ALTER COLUMN "server_type" DROP DEFAULT;
ALTER TABLE "agents" ADD COLUMN "optimize_cost" boolean DEFAULT false NOT NULL;
ALTER TABLE "interactions" ADD COLUMN "baseline_cost" numeric(13, 10);
ALTER TABLE "interactions" ADD COLUMN "cost" numeric(13, 10);
ALTER TABLE "optimization_rules" ADD CONSTRAINT "optimization_rules_agent_id_agents_id_fk" FOREIGN KEY ("agent_id") REFERENCES "public"."agents"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0053_mature_the_hood.sql">
ALTER TABLE "agents" ADD COLUMN "consider_context_untrusted" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0054_aberrant_mikhail_rasputin.sql">
DELETE FROM "tools" WHERE "name" LIKE 'archestra__%';
</file>

<file path="platform/backend/src/database/migrations/0055_green_mockingbird.sql">
ALTER TABLE "organization" ADD COLUMN "onboarding_complete" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0056_clever_forgotten_one.sql">
ALTER TABLE "agents" ADD COLUMN "use_in_chat" boolean DEFAULT true NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0057_damp_monster_badoon.sql">
ALTER TABLE "organization_role" ALTER COLUMN "permission" SET DATA TYPE text;
</file>

<file path="platform/backend/src/database/migrations/0058_large_firedrake.sql">
UPDATE "limits"
SET "model" = jsonb_build_array("model"::text)
WHERE "model" IS NOT NULL AND "model" != '' AND limit_type = 'token_cost';
ALTER TABLE "limits" ALTER COLUMN "model" SET DATA TYPE jsonb USING "model"::jsonb;
CREATE TABLE "limit_model_usage" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"limit_id" uuid NOT NULL,
	"model" varchar(255) NOT NULL,
	"current_usage_tokens_in" integer DEFAULT 0 NOT NULL,
	"current_usage_tokens_out" integer DEFAULT 0 NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);
ALTER TABLE "limit_model_usage" ADD CONSTRAINT "limit_model_usage_limit_id_limits_id_fk" FOREIGN KEY ("limit_id") REFERENCES "public"."limits"("id") ON DELETE cascade ON UPDATE no action;
CREATE INDEX "limit_model_usage_limit_id_idx" ON "limit_model_usage" USING btree ("limit_id");
CREATE INDEX "limit_model_usage_limit_model_idx" ON "limit_model_usage" USING btree ("limit_id","model");
ALTER TABLE "limit_model_usage" ADD CONSTRAINT "limit_model_usage_limit_id_model_unique" UNIQUE("limit_id", "model");
</file>

<file path="platform/backend/src/database/migrations/0059_nebulous_james_howlett.sql">
ALTER TABLE "limits" DROP COLUMN "current_usage_tokens_in";
ALTER TABLE "limits" DROP COLUMN "current_usage_tokens_out";
</file>

<file path="platform/backend/src/database/schemas/account.ts">
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/agent-label.ts">
import { pgTable, primaryKey, timestamp, uuid } from "drizzle-orm/pg-core";
import agentsTable from "./agent";
import labelKeyTable from "./label-key";
import labelValueTable from "./label-value";
</file>

<file path="platform/backend/src/database/schemas/agent-team.ts">
import {
  pgTable,
  primaryKey,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import agentsTable from "./agent";
import { team } from "./team";
</file>

<file path="platform/backend/src/database/schemas/api-key.ts">
import {
  boolean,
  integer,
  pgTable,
  text,
  timestamp,
} from "drizzle-orm/pg-core";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/chat-settings.ts">
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import secretsTable from "./secret";
</file>

<file path="platform/backend/src/database/schemas/dual-llm-config.ts">
import {
  boolean,
  integer,
  pgTable,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/schemas/dual-llm-result.ts">
import {
  index,
  jsonb,
  pgTable,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import type { DualLlmMessage } from "@/types";
import agentsTable from "./agent";
</file>

<file path="platform/backend/src/database/schemas/label-key.ts">
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/schemas/label-value.ts">
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/schemas/limit-model-usage.ts">
import {
  index,
  integer,
  pgTable,
  timestamp,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import limitsTable from "./limit";
</file>

<file path="platform/backend/src/database/schemas/limit.ts">
import {
  index,
  integer,
  jsonb,
  pgTable,
  text,
  timestamp,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import type { LimitEntityType, LimitType } from "@/types";
</file>

<file path="platform/backend/src/database/schemas/mcp-server-installation-request.ts">
import { jsonb, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import type {
  McpServerInstallationRequestCustomServerConfig,
  McpServerInstallationRequestNote,
  McpServerInstallationRequestStatus,
} from "@/types";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/mcp-server-team.ts">
import {
  pgTable,
  primaryKey,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import mcpServerTable from "./mcp-server";
import { team } from "./team";
</file>

<file path="platform/backend/src/database/schemas/mcp-server-user.ts">
import {
  pgTable,
  primaryKey,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import mcpServerTable from "./mcp-server";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/mcp-server.ts">
import { boolean, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import type {
  InternalMcpCatalogServerType,
  LocalMcpServerInstallationStatus,
} from "@/types";
import mcpCatalogTable from "./internal-mcp-catalog";
import secretTable from "./secret";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/mcp-tool-call.ts">
import {
  index,
  jsonb,
  pgTable,
  timestamp,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import type { CommonToolCall } from "@/types";
import agentsTable from "./agent";
</file>

<file path="platform/backend/src/database/schemas/message.ts">
import { jsonb, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import conversationsTable from "./conversation";
</file>

<file path="platform/backend/src/database/schemas/session.ts">
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/token-price.ts">
import {
  index,
  numeric,
  pgTable,
  timestamp,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/schemas/tool.ts">
import {
  jsonb,
  pgTable,
  text,
  timestamp,
  unique,
  uuid,
} from "drizzle-orm/pg-core";
import type { ToolParametersContent } from "@/types";
import agentsTable from "./agent";
import mcpCatalogTable from "./internal-mcp-catalog";
import mcpServerTable from "./mcp-server";
</file>

<file path="platform/backend/src/database/schemas/two-factor.ts">
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/verification.ts">
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/utils/pagination.test.ts">
import { describe, expect, test } from "@/test";
import { calculatePaginationMeta, createPaginatedResult } from "./pagination";
⋮----
interface TestItem {
        id: string;
        value: number;
      }
</file>

<file path="platform/backend/src/database/utils/pagination.ts">
import type { PgSelect } from "drizzle-orm/pg-core";
import type { PaginationMeta, PaginationQuery } from "@/types";
export interface PaginatedResult<T> {
  data: T[];
  pagination: PaginationMeta;
}
export function applyPagination<T extends PgSelect>(
  queryBuilder: T,
  params: PaginationQuery,
): T
export function calculatePaginationMeta(
  total: number,
  params: PaginationQuery,
): PaginationMeta
export function createPaginatedResult<T>(
  data: T[],
  total: number,
  params: PaginationQuery,
): PaginatedResult<T>
</file>

<file path="platform/backend/src/database/index.ts">
import { instrumentDrizzleClient } from "@kubiks/otel-drizzle";
import { drizzle } from "drizzle-orm/node-postgres";
import config from "@/config";
</file>

<file path="platform/backend/src/mcp-server-runtime/index.ts">

</file>

<file path="platform/backend/src/mcp-server-runtime/manager.test.ts">
import { vi } from "vitest";
⋮----
import { beforeEach, describe, expect, test } from "@/test";
</file>

<file path="platform/backend/src/mcp-server-runtime/schemas.ts">
import { z } from "zod";
export type K8sRuntimeStatus =
  | "not_initialized"
  | "initializing"
  | "running"
  | "error"
  | "stopped";
export type K8sPodState =
  | "not_created"
  | "pending"
  | "running"
  | "failed"
  | "succeeded";
export interface K8sPodStatusSummary {
  state: K8sPodState;
  message: string;
  error: string | null;
  podName: string | null;
  namespace: string;
}
export interface K8sRuntimeStatusSummary {
  status: K8sRuntimeStatus;
  mcpServers: Record<string, K8sPodStatusSummary>;
}
⋮----
export type AvailableTool = z.infer<typeof AvailableToolSchema>;
⋮----
export type McpServerContainerLogs = z.infer<
  typeof McpServerContainerLogsSchema
>;
</file>

<file path="platform/backend/src/models/account.test.ts">
import { describe, expect, test } from "@/test";
import AccountModel from "./account";
</file>

<file path="platform/backend/src/models/account.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
class AccountModel
⋮----
static async getByUserId(userId: string)
</file>

<file path="platform/backend/src/models/agent-label.test.ts">
import { describe, expect, test } from "@/test";
import AgentLabelModel from "./agent-label";
⋮----
// Verify keys and values exist
⋮----
// Remove labels from agent1
⋮----
// Verify "environment" key is still present (used by agent2)
⋮----
// agent3 has no labels
</file>

<file path="platform/backend/src/models/agent-label.ts">
import { asc, eq, inArray, isNull } from "drizzle-orm";
import db, { schema } from "@/database";
import type { AgentLabelWithDetails } from "@/types";
class AgentLabelModel
⋮----
static async getLabelsForAgent(
    agentId: string,
): Promise<AgentLabelWithDetails[]>
/**
   * Get or create a label key
   */
static async getOrCreateKey(key: string): Promise<string>
⋮----
// Try to find existing key
⋮----
// Create new key
⋮----
/**
   * Get or create a label value
   */
static async getOrCreateValue(value: string): Promise<string>
⋮----
// Try to find existing value
⋮----
// Create new value
⋮----
/**
   * Sync labels for an agent (replaces all existing labels)
   */
static async syncAgentLabels(
    agentId: string,
    labels: AgentLabelWithDetails[],
): Promise<void>
⋮----
// Process labels outside of transaction to avoid deadlocks
⋮----
// Process each label to get or create keys/values
⋮----
// Delete all existing labels for this agent
⋮----
// Insert new labels (if any provided)
⋮----
/**
   * Prune orphaned label keys and values that are no longer referenced
   * by any agent labels
   */
static async pruneKeysAndValues(): Promise<
⋮----
// Find orphaned keys (not referenced in agent_labels)
⋮----
// Find orphaned values (not referenced in agent_labels)
⋮----
// Delete orphaned keys
⋮----
// Delete orphaned values
⋮----
/**
   * Get all available label keys
   */
static async getAllKeys(): Promise<string[]>
/**
   * Get all available label values
   */
static async getAllValues(): Promise<string[]>
/**
   * Get labels for multiple agents in one query to avoid N+1
   */
static async getLabelsForAgents(
    agentIds: string[],
): Promise<Map<string, AgentLabelWithDetails[]>>
⋮----
// Initialize all agent IDs with empty arrays
⋮----
// Populate the map with labels
⋮----
static async getValuesByKey(key: string): Promise<string[]>
</file>

<file path="platform/backend/src/models/agent-team.test.ts">
import { describe, expect, test } from "@/test";
import AgentTeamModel from "./agent-team";
</file>

<file path="platform/backend/src/models/chat-settings.test.ts">
import { describe, expect, test } from "@/test";
import ChatSettingsModel from "./chat-settings";
</file>

<file path="platform/backend/src/models/chat-settings.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type {
  ChatSettings,
  InsertChatSettings,
  UpdateChatSettings,
} from "@/types";
class ChatSettingsModel
⋮----
static async create(data: InsertChatSettings): Promise<ChatSettings>
static async findByOrganizationId(
    organizationId: string,
): Promise<ChatSettings | null>
static async getOrCreate(organizationId: string): Promise<ChatSettings>
static async update(
    organizationId: string,
    data: UpdateChatSettings,
): Promise<ChatSettings | null>
</file>

<file path="platform/backend/src/models/conversation.test.ts">
import { describe, expect, test } from "@/test";
import ConversationModel from "./conversation";
</file>

<file path="platform/backend/src/models/conversation.ts">
import { and, desc, eq, getTableColumns } from "drizzle-orm";
import db, { schema } from "@/database";
import type {
  Conversation,
  InsertConversation,
  UpdateConversation,
} from "@/types";
class ConversationModel
⋮----
static async create(data: InsertConversation): Promise<Conversation>
static async findAll(
    userId: string,
    organizationId: string,
): Promise<Conversation[]>
static async findById(
    id: string,
    userId: string,
    organizationId: string,
): Promise<Conversation | null>
static async update(
    id: string,
    userId: string,
    organizationId: string,
    data: UpdateConversation,
): Promise<Conversation | null>
static async delete(
    id: string,
    userId: string,
    organizationId: string,
): Promise<void>
</file>

<file path="platform/backend/src/models/dual-llm-config.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { DualLlmConfig, InsertDualLlmConfig } from "@/types";
class DualLlmConfigModel
⋮----
static async create(config: InsertDualLlmConfig): Promise<DualLlmConfig>
static async findAll(): Promise<DualLlmConfig[]>
static async findById(id: string): Promise<DualLlmConfig | null>
static async getDefault(): Promise<DualLlmConfig>
static async update(
    id: string,
    config: Partial<InsertDualLlmConfig>,
): Promise<DualLlmConfig | null>
static async delete(id: string): Promise<boolean>
</file>

<file path="platform/backend/src/models/dual-llm-result.ts">
import { desc, eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { DualLlmResult, InsertDualLlmResult } from "@/types";
class DualLlmResultModel
⋮----
static async create(data: InsertDualLlmResult): Promise<DualLlmResult>
static async findByToolCallId(
    toolCallId: string,
): Promise<DualLlmResult | null>
static async findByAgentId(agentId: string): Promise<DualLlmResult[]>
static async findAll(): Promise<DualLlmResult[]>
</file>

<file path="platform/backend/src/models/interaction.test.ts">
import { beforeEach, describe, expect, test } from "@/test";
import AgentModel from "./agent";
import InteractionModel from "./interaction";
import TeamModel from "./team";
</file>

<file path="platform/backend/src/models/interaction.ts">
import { and, asc, count, desc, eq, inArray, type SQL, sql } from "drizzle-orm";
import db, { schema } from "@/database";
import {
  createPaginatedResult,
  type PaginatedResult,
} from "@/database/utils/pagination";
import logger from "@/logging";
import type {
  InsertInteraction,
  Interaction,
  PaginationQuery,
  SortingQuery,
} from "@/types";
import AgentTeamModel from "./agent-team";
import LimitModel from "./limit";
class InteractionModel
⋮----
static async create(data: InsertInteraction)
static async findAllPaginated(
    pagination: PaginationQuery,
    sorting?: SortingQuery,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<PaginatedResult<Interaction>>
private static getOrderByClause(sorting?: SortingQuery)
⋮----
// Default: newest first
⋮----
static async findById(
    id: string,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<Interaction | null>
⋮----
// Check access control for non-agent admins
⋮----
static async getAllInteractionsForAgent(
    agentId: string,
    whereClauses?: SQL[],
)
/**
   * Get all interactions for an agent with pagination and sorting support
   */
static async getAllInteractionsForAgentPaginated(
    agentId: string,
    pagination: PaginationQuery,
    sorting?: SortingQuery,
    whereClauses?: SQL[],
): Promise<PaginatedResult<Interaction>>
static async getCount()
/**
   * Update usage limits after an interaction is created
   */
static async updateUsageAfterInteraction(
    interaction: InsertInteraction & { id: string },
): Promise<void>
⋮----
// Calculate token usage for this interaction
⋮----
// No tokens used, nothing to update
</file>

<file path="platform/backend/src/models/invitation.test.ts">
import { ADMIN_ROLE_NAME, MEMBER_ROLE_NAME } from "@shared";
import { describe, expect, test } from "@/test";
import type { BetterAuthSession, BetterAuthSessionUser } from "@/types";
import InvitationModel from "./invitation";
import MemberModel from "./member";
</file>

<file path="platform/backend/src/models/limit.test.ts">
import { and, eq } from "drizzle-orm";
import db, { schema } from "@/database";
import { describe, expect, test } from "@/test";
import LimitModel, { LimitValidationService } from "./limit";
</file>

<file path="platform/backend/src/models/limit.ts">
import { and, eq, inArray, isNull, lt, or, type SQL, sql } from "drizzle-orm";
import db, { schema } from "@/database";
import logger from "@/logging";
import type {
  CreateLimit,
  Limit,
  LimitEntityType,
  LimitType,
  UpdateLimit,
} from "@/types";
import AgentTeamModel from "./agent-team";
import TokenPriceModel from "./token-price";
class LimitModel
⋮----
static async create(data: CreateLimit): Promise<Limit>
static async initializeModelUsageRecords(
    limitId: string,
    models: string[],
): Promise<void>
static async findAll(
    entityType?: LimitEntityType,
    entityId?: string,
    limitType?: LimitType,
): Promise<Limit[]>
static async getModelUsageBreakdown(
    limitId: string,
  ): Promise<
    Array<{ model: string; tokensIn: number; tokensOut: number; cost: number }>
  > {
    const modelUsages = await db
      .select()
      .from(schema.limitModelUsageTable)
      .where(eq(schema.limitModelUsageTable.limitId, limitId));
static async findById(id: string): Promise<Limit | null>
static async patch(
    id: string,
    data: Partial<UpdateLimit>,
): Promise<Limit | null>
static async delete(id: string): Promise<boolean>
static async getAgentTokenUsage(agentId: string): Promise<
static async updateTokenLimitUsage(
    entityType: LimitEntityType,
    entityId: string,
    model: string,
    inputTokens: number,
    outputTokens: number,
): Promise<void>
⋮----
// Update model usage for each limit
⋮----
static async findLimitsNeedingCleanup(
    organizationId: string,
    cutoffTime: Date,
): Promise<Limit[]>
static async resetLimitUsage(id: string): Promise<Limit | null>
static async findLimitsForValidation(
    entityType: LimitEntityType,
    entityId: string,
    limitType: LimitType = "token_cost",
): Promise<Limit[]>
static async cleanupLimitsIfNeeded(organizationId: string): Promise<void>
⋮----
export class LimitValidationService
⋮----
static async checkLimitsBeforeRequest(
    agentId: string,
): Promise<null | [string, string]>
⋮----
// Run cleanup if we have an organization ID
⋮----
// Check agent-level limits first (highest priority)
⋮----
// Check team-level limits
⋮----
// Check organization-level limits
⋮----
private static async checkEntityLimits(
    entityType: "organization" | "team" | "agent",
    entityId: string,
): Promise<null | [string, string]>
</file>

<file path="platform/backend/src/models/mcp-server-user.test.ts">
import { describe, expect, test } from "@/test";
import McpServerUserModel from "./mcp-server-user";
</file>

<file path="platform/backend/src/models/mcp-server-user.ts">
import { and, eq, inArray } from "drizzle-orm";
import db, { schema } from "@/database";
class McpServerUserModel
⋮----
static async getUserPersonalMcpServerIds(userId: string): Promise<string[]>
static async userHasPersonalMcpServerAccess(
    userId: string,
    mcpServerId: string,
): Promise<boolean>
static async getUserDetailsForMcpServer(mcpServerId: string): Promise<
    Array<{
      userId: string;
      email: string;
      createdAt: Date;
    }>
  > {
    const result = await db
      .select({
        userId: schema.mcpServerUsersTable.userId,
        email: schema.usersTable.email,
        createdAt: schema.mcpServerUsersTable.createdAt,
      })
      .from(schema.mcpServerUsersTable)
      .innerJoin(
        schema.usersTable,
        eq(schema.mcpServerUsersTable.userId, schema.usersTable.id),
      )
      .where(eq(schema.mcpServerUsersTable.mcpServerId, mcpServerId));
static async getUserDetailsForMcpServers(mcpServerIds: string[]): Promise<
    Map<
      string,
      Array<{
        userId: string;
        email: string;
        createdAt: Date;
      }>
    >
  > {
if (mcpServerIds.length === 0)
static async assignUserToMcpServer(
    mcpServerId: string,
    userId: string,
): Promise<void>
</file>

<file path="platform/backend/src/models/mcp-tool-call.ts">
import { and, asc, count, desc, eq, inArray, type SQL } from "drizzle-orm";
import db, { schema } from "@/database";
import {
  createPaginatedResult,
  type PaginatedResult,
} from "@/database/utils/pagination";
import type {
  InsertMcpToolCall,
  McpToolCall,
  PaginationQuery,
  SortingQuery,
} from "@/types";
import AgentTeamModel from "./agent-team";
class McpToolCallModel
⋮----
static async create(data: InsertMcpToolCall)
static async findAllPaginated(
    pagination: PaginationQuery,
    sorting?: SortingQuery,
    userId?: string,
    isMcpServerAdmin?: boolean,
): Promise<PaginatedResult<McpToolCall>>
private static getOrderByClause(sorting?: SortingQuery)
static async findById(
    id: string,
    userId?: string,
    isMcpServerAdmin?: boolean,
): Promise<McpToolCall | null>
static async getAllMcpToolCallsForAgent(
    agentId: string,
    whereClauses?: SQL[],
)
static async getAllMcpToolCallsForAgentPaginated(
    agentId: string,
    pagination: PaginationQuery,
    sorting?: SortingQuery,
    whereClauses?: SQL[],
): Promise<PaginatedResult<McpToolCall>>
static async getCount()
</file>

<file path="platform/backend/src/models/member.test.ts">
import { ADMIN_ROLE_NAME, MEMBER_ROLE_NAME } from "@shared";
import { describe, expect, test } from "@/test";
import MemberModel from "./member";
</file>

<file path="platform/backend/src/models/member.ts">
import type { AnyRoleName } from "@shared";
import { and, eq } from "drizzle-orm";
import db, { schema } from "@/database";
class MemberModel
⋮----
static async create(
    userId: string,
    organizationId: string,
    role: AnyRoleName,
)
static async getByUserId(userId: string)
static async deleteByMemberOrUserId(
    memberIdOrUserId: string,
    organizationId: string,
)
</file>

<file path="platform/backend/src/models/message.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { InsertMessage, Message } from "@/types";
class MessageModel
⋮----
static async create(data: InsertMessage): Promise<Message>
static async bulkCreate(messages: InsertMessage[]): Promise<void>
static async findByConversation(conversationId: string): Promise<Message[]>
static async delete(id: string): Promise<void>
static async deleteByConversation(conversationId: string): Promise<void>
</file>

<file path="platform/backend/src/models/organization.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { Organization, UpdateOrganization } from "@/types";
class OrganizationModel
⋮----
static async getOrCreateDefaultOrganization(): Promise<Organization>
static async patch(
    id: string,
    data: Partial<UpdateOrganization>,
): Promise<Organization | null>
static async getById(id: string): Promise<Organization | null>
</file>

<file path="platform/backend/src/models/session.test.ts">
import { beforeEach, describe, expect, test } from "@/test";
import SessionModel from "./session";
</file>

<file path="platform/backend/src/models/session.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { InsertSession, UpdateSession } from "@/types";
class SessionModel
⋮----
static async getAll()
static async getByUserId(userId: string)
static async getById(id: string)
static async create(data: InsertSession)
static async patch(sessionId: string, data: Partial<UpdateSession>)
static async deleteAllByUserId(userId: string)
</file>

<file path="platform/backend/src/models/statistics.test.ts">
import type { StatisticsTimeFrame } from "@shared";
import { describe, expect, test } from "@/test";
import StatisticsModel from "./statistics";
</file>

<file path="platform/backend/src/models/tool-archestra-assignment.test.ts">
import { getArchestraMcpTools } from "@/archestra-mcp-server";
import { describe, expect, test } from "@/test";
import AgentToolModel from "./agent-tool";
import ToolModel from "./tool";
</file>

<file path="platform/backend/src/models/user.ts">
import {
  ADMIN_ROLE_NAME,
  DEFAULT_ADMIN_EMAIL,
  type Permissions,
  type PredefinedRoleName,
} from "@shared";
import { and, eq, getTableColumns } from "drizzle-orm";
import { betterAuth } from "@/auth";
import config from "@/config";
import db, { schema } from "@/database";
import logger from "@/logging";
import type { UpdateUser } from "@/types";
import OrganizationRoleModel from "./organization-role";
class UserModel
⋮----
static async createOrGetExistingDefaultAdminUser({
    email = config.auth.adminDefaultEmail,
    password = config.auth.adminDefaultPassword,
    role = ADMIN_ROLE_NAME,
    name = "Admin",
  }: {
    email?: string;
    password?: string;
    role?: PredefinedRoleName;
    name?: string;
} =
static async getById(id: string)
static async getUserPermissions(
    userId: string,
    organizationId: string,
): Promise<Permissions>
static async getUserWithByDefaultEmail()
static async patch(userId: string, data: Partial<UpdateUser>)
</file>

<file path="platform/backend/src/routes/proxy/utils/adapters/anthropic.test.ts">
import { describe, expect, test } from "@/test";
import { toolCallsToCommon, toolResultsToMessages } from "./anthropic";
</file>

<file path="platform/backend/src/routes/proxy/utils/adapters/gemini.ts">
import type { CommonMessage, Gemini, ToolResultUpdates } from "@/types";
type GeminiContents = Gemini.Types.GenerateContentRequest["contents"];
export function toCommonFormat(_contents: GeminiContents): CommonMessage[]
export function applyUpdates(
  contents: GeminiContents,
  updates: ToolResultUpdates,
): GeminiContents
function _generateToolCallId(functionName: string): string
export function extractUserRequest(_contents: GeminiContents): string
type GeminiUsage = Pick<
  Gemini.Types.UsageMetadata,
  "promptTokenCount" | "candidatesTokenCount"
>;
export function getUsageTokens(usage: GeminiUsage)
</file>

<file path="platform/backend/src/routes/proxy/utils/adapters/index.ts">

</file>

<file path="platform/backend/src/routes/proxy/utils/adapters/openai.test.ts">
import { describe, expect, test } from "@/test";
import { toolCallsToCommon, toolResultsToMessages } from "./openai";
</file>

<file path="platform/backend/src/routes/proxy/utils/dual-llm-client.ts">
import Anthropic from "@anthropic-ai/sdk";
import OpenAI from "openai";
import config from "@/config";
import type { DualLlmMessage, SupportedProvider } from "@/types";
export interface DualLlmClient {
  chat(messages: DualLlmMessage[], temperature?: number): Promise<string>;
  chatWithSchema<T>(
    messages: DualLlmMessage[],
    schema: {
      name: string;
      schema: {
        type: string;
        properties: Record<string, unknown>;
        required: string[];
        additionalProperties: boolean;
      };
    },
    temperature?: number,
  ): Promise<T>;
}
⋮----
chat(messages: DualLlmMessage[], temperature?: number): Promise<string>;
chatWithSchema<T>(
    messages: DualLlmMessage[],
    schema: {
      name: string;
      schema: {
        type: string;
        properties: Record<string, unknown>;
        required: string[];
        additionalProperties: boolean;
      };
    },
    temperature?: number,
  ): Promise<T>;
⋮----
export class OpenAiDualLlmClient implements DualLlmClient
⋮----
constructor(apiKey: string, model = "gpt-4o")
async chat(messages: DualLlmMessage[], temperature = 0): Promise<string>
async chatWithSchema<T>(
    messages: DualLlmMessage[],
    schema: {
      name: string;
      schema: {
        type: string;
        properties: Record<string, unknown>;
        required: string[];
        additionalProperties: boolean;
      };
    },
    temperature = 0,
): Promise<T>
⋮----
/**
 * Anthropic implementation of DualLlmClient
 */
export class AnthropicDualLlmClient implements DualLlmClient
⋮----
constructor(apiKey: string, model = "claude-sonnet-4-5-20250929")
⋮----
// Anthropic doesn't have native structured output yet
// We'll use a prompt-based approach with JSON mode
⋮----
// Prepend the schema instruction to the first user message
⋮----
// Parse JSON response
// Try to extract JSON from markdown code blocks if present
⋮----
/**
 * Factory function to create the appropriate LLM client
 */
export function createDualLlmClient(
  provider: SupportedProvider,
  apiKey: string,
): DualLlmClient
</file>

<file path="platform/backend/src/routes/proxy/utils/dual-llm-subagent.ts">
import logger from "@/logging";
import { DualLlmConfigModel, DualLlmResultModel } from "@/models";
import type {
  CommonDualLlmParams,
  DualLlmConfig,
  DualLlmMessage,
  SupportedProvider,
} from "@/types";
import { createDualLlmClient, type DualLlmClient } from "./dual-llm-client";
export class DualLlmSubagent
⋮----
private constructor(
    config: DualLlmConfig,
    agentId: string,
    toolCallId: string,
    llmClient: DualLlmClient,
    originalUserRequest: string,
    toolResult: unknown,
)
static async create(
    params: CommonDualLlmParams,
    agentId: string,
    apiKey: string,
    provider: SupportedProvider,
): Promise<DualLlmSubagent>
async processWithMainAgent(
    onProgress?: (progress: {
      question: string;
      options: string[];
      answer: string;
    }) => void,
): Promise<string>
⋮----
// Step 3: Quarantined agent answers the question (can see untrusted data)
⋮----
// Stream progress if callback provided
⋮----
// Step 4: Feed the answer back to the main agent
⋮----
private async answerQuestion(
    question: string,
    options: string[],
): Promise<number>
private async generateSummary(
    conversation: DualLlmMessage[],
): Promise<string>
</file>

<file path="platform/backend/src/routes/proxy/utils/tool-invocation.ts">
import { ToolInvocationPolicyModel } from "@/models";
export const evaluatePolicies = async (
  toolCalls: Array<{ toolCallName: string; toolCallArgs: string }>,
  agentId: string,
  contextIsTrusted: boolean,
): Promise<null | [string, string]> =>
</file>

<file path="platform/backend/src/routes/proxy/utils/tools.ts">
import { getArchestraMcpTools } from "@/archestra-mcp-server";
import { AgentToolModel, ToolModel } from "@/models";
export const persistTools = async (
  tools: Array<{
    toolName: string;
    toolParameters?: Record<string, unknown>;
    toolDescription?: string;
  }>,
  agentId: string,
) =>
</file>

<file path="platform/backend/src/routes/proxy/utils/tracing.ts">
import { type Span, trace } from "@opentelemetry/api";
import type { Agent, SupportedProvider } from "@/types";
export enum RouteCategory {
  LLM_PROXY = "llm-proxy",
  MCP_GATEWAY = "mcp-gateway",
  API = "api",
}
export async function startActiveLlmSpan<T>(
  spanName: string,
  provider: SupportedProvider,
  llmModel: string,
  stream: boolean,
  agent: Agent | undefined,
  callback: (span: Span) => Promise<T>,
): Promise<T>
</file>

<file path="platform/backend/src/routes/proxy/utils/trusted-data.ts">
import { DualLlmResultModel, TrustedDataPolicyModel } from "@/models";
import type {
  CommonMessage,
  SupportedProvider,
  ToolResultUpdates,
} from "@/types";
import { DualLlmSubagent } from "./dual-llm-subagent";
export async function evaluateIfContextIsTrusted(
  messages: CommonMessage[],
  agentId: string,
  apiKey: string,
  provider: SupportedProvider,
  considerContextUntrusted: boolean = false,
  onDualLlmStart?: () => void,
  onDualLlmProgress?: (progress: {
    question: string;
    options: string[];
    answer: string;
  }) => void,
): Promise<
function extractUserRequest(messages: CommonMessage[]): string
</file>

<file path="platform/backend/src/routes/proxy/common.ts">

</file>

<file path="platform/backend/src/routes/proxy/gemini.ts">
import fastifyHttpProxy from "@fastify/http-proxy";
import { GoogleGenAI } from "@google/genai";
import type { FastifyReply } from "fastify";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { getObservableGenAI } from "@/llm-metrics";
import { AgentModel, InteractionModel, LimitValidationService } from "@/models";
import {
  type Agent,
  constructResponseSchema,
  ErrorResponsesSchema,
  Gemini,
  UuidIdSchema,
} from "@/types";
import { PROXY_API_PREFIX } from "./common";
⋮----
const geminiProxyRoutes: FastifyPluginAsyncZod = async (fastify) =>
⋮----
const handleGenerateContent = async (
    body: Gemini.Types.GenerateContentRequest,
    headers: Gemini.Types.GenerateContentHeaders,
    reply: FastifyReply,
    model: string,
    agentId?: string,
    stream = false,
) =>
const generateRouteEndpoint = (
    verb: "generateContent" | "streamGenerateContent",
    includeAgentId = false,
)
</file>

<file path="platform/backend/src/routes/proxy/mock-anthropic-client.ts">
import type Anthropic from "@anthropic-ai/sdk";
⋮----
export class MockAnthropicClient
⋮----
async next()
</file>

<file path="platform/backend/src/routes/proxy/mock-openai-client.ts">
import type OpenAI from "openai";
⋮----
export class MockOpenAIClient
⋮----
async next()
</file>

<file path="platform/backend/src/routes/autonomy-policies.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { ToolInvocationPolicyModel, TrustedDataPolicyModel } from "@/models";
import {
  ApiError,
  AutonomyPolicyOperator,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  ToolInvocation,
  TrustedData,
  UuidIdSchema,
} from "@/types";
const autonomyPolicyRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/dual-llm-config.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { DualLlmConfigModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  InsertDualLlmConfigSchema,
  SelectDualLlmConfigSchema,
  UuidIdSchema,
} from "@/types";
const dualLlmConfigRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/dual-llm-result.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { DualLlmResultModel, InteractionModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  SelectDualLlmResultSchema,
  UuidIdSchema,
} from "@/types";
const dualLlmResultRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/features.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import config from "@/config";
import { McpServerRuntimeManager } from "@/mcp-server-runtime";
const featuresRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/internal-mcp-catalog.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { InternalMcpCatalogModel, McpServerModel, ToolModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  InsertInternalMcpCatalogSchema,
  SelectInternalMcpCatalogSchema,
  UpdateInternalMcpCatalogSchema,
  UuidIdSchema,
} from "@/types";
const internalMcpCatalogRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/mcp-server-installation-requests.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { McpServerInstallationRequestModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  InsertMcpServerInstallationRequestSchema,
  type McpServerInstallationRequest,
  McpServerInstallationRequestStatusSchema,
  SelectMcpServerInstallationRequestSchema,
  UpdateMcpServerInstallationRequestSchema,
  UuidIdSchema,
} from "@/types";
const mcpServerInstallationRequestRoutes: FastifyPluginAsyncZod = async (
  fastify,
) =>
</file>

<file path="platform/backend/src/routes/mcp-tool-call.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { McpToolCallModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  createPaginatedResponseSchema,
  createSortingQuerySchema,
  PaginationQuerySchema,
  SelectMcpToolCallSchema,
  UuidIdSchema,
} from "@/types";
const mcpToolCallRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/organization.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import {
  InteractionModel,
  McpToolCallModel,
  OrganizationModel,
} from "@/models";
import {
  ApiError,
  constructResponseSchema,
  SelectOrganizationSchema,
  UpdateOrganizationSchema,
} from "@/types";
const organizationRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/team.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { AgentToolModel, TeamModel } from "@/models";
import {
  AddTeamMemberBodySchema,
  ApiError,
  CreateTeamBodySchema,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  SelectTeamMemberSchema,
  SelectTeamSchema,
  UpdateTeamBodySchema,
} from "@/types";
const teamRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/standalone-scripts/mocks/agents.ts">
import { randomUUID } from "node:crypto";
import type { InsertAgent } from "@/types";
import { randomBool, randomElement } from "./utils";
⋮----
function generateAgentName(index: number): string
type MockAgent = InsertAgent & { id: string };
export function generateMockAgents(count = 90): MockAgent[]
</file>

<file path="platform/backend/src/standalone-scripts/mocks/index.ts">

</file>

<file path="platform/backend/src/standalone-scripts/mocks/interactions.ts">
import { randomUUID } from "node:crypto";
import type { InsertInteraction } from "@/types";
import { randomBool, randomElement, randomInt } from "./utils";
export interface ConversationTemplate {
  userPrompts: string[];
  toolName: string;
  systemPrompt: string;
}
⋮----
interface ToolInfo {
  name: string;
  description: string | null;
  allowUsageWhenUntrustedDataIsPresent: boolean;
}
function generateToolArguments(toolName: string): Record<string, unknown>
export function generateMockInteraction(
  agentId: string,
  tools: ToolInfo[],
  shouldBlock: boolean,
): InsertInteraction
export function generateMockInteractions(
  agentIds: string[],
  toolsByAgent: Map<string, ToolInfo[]>,
  count: number,
  blockProbability = 0.3,
): InsertInteraction[]
</file>

<file path="platform/backend/src/standalone-scripts/mocks/tools.ts">
import { randomUUID } from "node:crypto";
import { randomBool, randomElement } from "./utils";
⋮----
function generateRandomParameters(toolName: string): Record<string, unknown>
⋮----
export interface MockTool {
  id: string;
  agentId: string;
  name: string;
  description: string;
  parameters: Record<string, unknown>;
  allowUsageWhenUntrustedDataIsPresent: boolean;
  dataIsTrustedByDefault: boolean;
  createdAt: Date;
  updatedAt: Date;
}
export function generateMockTools(
  agentIds: string[],
  toolNames: string[] = TOOL_NAMES,
): MockTool[]
</file>

<file path="platform/backend/src/standalone-scripts/mocks/utils.ts">
export const randomElement = <T>(arr: T[]): T
export const randomInt = (min: number, max: number): number
export const randomBool = (probability = 0.5): boolean
</file>

<file path="platform/backend/src/standalone-scripts/clean-db-on-dev.ts">
import { pathToFileURL } from "node:url";
import { sql } from "drizzle-orm";
import config from "@/config";
import db from "@/database";
import logger from "@/logging";
export const clearDb = async (): Promise<void> =>
</file>

<file path="platform/backend/src/test/index.ts">

</file>

<file path="platform/backend/src/test/setup.ts">
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { PGlite } from "@electric-sql/pglite";
import { drizzle } from "drizzle-orm/pglite";
import { afterEach, beforeEach, vi } from "vitest";
</file>

<file path="platform/backend/src/types/autonomy-policies/index.ts">

</file>

<file path="platform/backend/src/types/autonomy-policies/operator.ts">
import { z } from "zod";
⋮----
export type SupportedOperator = z.infer<typeof SupportedOperatorSchema>;
</file>

<file path="platform/backend/src/types/autonomy-policies/tool-invocation.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { SupportedOperatorSchema } from "./operator";
⋮----
export type ToolInvocationPolicy = z.infer<
  typeof SelectToolInvocationPolicySchema
>;
export type InsertToolInvocationPolicy = z.infer<
  typeof InsertToolInvocationPolicySchema
>;
export type ToolInvocationPolicyAction = z.infer<
  typeof ToolInvocationPolicyActionSchema
>;
</file>

<file path="platform/backend/src/types/autonomy-policies/trusted-data.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { SupportedOperatorSchema } from "./operator";
⋮----
export type TrustedDataPolicy = z.infer<typeof SelectTrustedDataPolicySchema>;
export type InsertTrustedDataPolicy = z.infer<
  typeof InsertTrustedDataPolicySchema
>;
export type TrustedDataPolicyAction = z.infer<
  typeof TrustedDataPolicyActionSchema
>;
</file>

<file path="platform/backend/src/types/llm-providers/anthropic/api.ts">
import { z } from "zod";
import { MessageContentBlockSchema, MessageParamSchema } from "./messages";
import { ToolSchema } from "./tools";
</file>

<file path="platform/backend/src/types/llm-providers/anthropic/index.ts">
import type { z } from "zod";
⋮----
export type MessagesHeaders = z.infer<
      typeof AnthropicAPI.MessagesHeadersSchema
    >;
export type MessagesRequest = z.infer<
      typeof AnthropicAPI.MessagesRequestSchema
    >;
export type MessagesResponse = z.infer<
      typeof AnthropicAPI.MessagesResponseSchema
    >;
export type Usage = z.infer<typeof AnthropicAPI.UsageSchema>;
export type CustomTool = z.infer<typeof AnthropicTools.CustomToolSchema>;
</file>

<file path="platform/backend/src/types/llm-providers/anthropic/messages.ts">
import { z } from "zod";
</file>

<file path="platform/backend/src/types/llm-providers/anthropic/tools.ts">
import { z } from "zod";
</file>

<file path="platform/backend/src/types/llm-providers/gemini/api.ts">
import { z } from "zod";
import { ContentSchema } from "./messages";
import { ToolConfigSchema, ToolSchema } from "./tools";
</file>

<file path="platform/backend/src/types/llm-providers/gemini/index.ts">
import type { z } from "zod";
⋮----
export type GenerateContentHeaders = z.infer<
      typeof GeminiAPI.GenerateContentHeadersSchema
    >;
export type GenerateContentRequest = z.infer<
      typeof GeminiAPI.GenerateContentRequestSchema
    >;
export type GenerateContentResponse = z.infer<
      typeof GeminiAPI.GenerateContentResponseSchema
    >;
export type UsageMetadata = z.infer<typeof Gemini.API.UsageMetadataSchema>;
export type Candidate = z.infer<typeof GeminiAPI.CandidateSchema>;
export type SystemInstruction = z.infer<
      typeof GeminiAPI.SystemInstructionSchema
    >;
export type FinishReason = z.infer<typeof GeminiAPI.FinishReasonSchema>;
export type Role = z.infer<typeof GeminiMessages.RoleSchema>;
export type MessageContent = z.infer<typeof GeminiMessages.ContentSchema>;
export type MessagePart = z.infer<typeof GeminiMessages.PartSchema>;
export type Tool = z.infer<typeof GeminiTools.ToolSchema>;
</file>

<file path="platform/backend/src/types/llm-providers/gemini/messages.ts">
import { z } from "zod";
</file>

<file path="platform/backend/src/types/llm-providers/gemini/tools.ts">
import { z } from "zod";
</file>

<file path="platform/backend/src/types/llm-providers/openai/api.ts">
import { z } from "zod";
import { MessageParamSchema, ToolCallSchema } from "./messages";
import { ToolChoiceOptionSchema, ToolSchema } from "./tools";
</file>

<file path="platform/backend/src/types/llm-providers/openai/index.ts">
import type OpenAIProvider from "openai";
import type { z } from "zod";
⋮----
export type ChatCompletionsHeaders = z.infer<
      typeof OpenAiAPI.ChatCompletionsHeadersSchema
    >;
export type ChatCompletionsRequest = z.infer<
      typeof OpenAiAPI.ChatCompletionRequestSchema
    >;
export type ChatCompletionsResponse = z.infer<
      typeof OpenAiAPI.ChatCompletionResponseSchema
    >;
export type Usage = z.infer<typeof OpenAiAPI.ChatCompletionUsageSchema>;
export type FinishReason = z.infer<typeof OpenAiAPI.FinishReasonSchema>;
export type Message = z.infer<typeof OpenAiMessages.MessageParamSchema>;
export type Role = Message["role"];
export type ChatCompletionChunk =
      OpenAIProvider.Chat.Completions.ChatCompletionChunk;
</file>

<file path="platform/backend/src/types/llm-providers/openai/messages.ts">
import { z } from "zod";
</file>

<file path="platform/backend/src/types/llm-providers/openai/tools.ts">
import { z } from "zod";
</file>

<file path="platform/backend/src/types/llm-providers/index.ts">
import { z } from "zod";
⋮----
export type SupportedProvider = z.infer<typeof SupportedProvidersSchema>;
export type SupportedProviderDiscriminator = z.infer<
  typeof SupportedProvidersDiscriminatorSchema
>;
</file>

<file path="platform/backend/src/types/account.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type Account = z.infer<typeof AccountSchema>;
export type UpdateAccount = z.infer<typeof UpdateAccountSchema>;
export type InsertAccount = z.infer<typeof InsertAccountSchema>;
</file>

<file path="platform/backend/src/types/agent.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { AgentLabelWithDetailsSchema } from "./label";
import { SelectToolSchema } from "./tool";
⋮----
export type Agent = z.infer<typeof SelectAgentSchema>;
export type InsertAgent = z.infer<typeof InsertAgentSchema>;
export type UpdateAgent = z.infer<typeof UpdateAgentSchema>;
</file>

<file path="platform/backend/src/types/api.ts">
import { z } from "zod";
⋮----
export class ApiError extends Error
⋮----
constructor(statusCode: number, message: string)
⋮----
export type ErrorResponseSchema<T extends z.infer<typeof ApiErrorTypeSchema>> =
  {
    error: {
      message: string;
      type: T;
    };
  };
export const generateErrorResponseSchema = <
  T extends z.infer<typeof ApiErrorTypeSchema>,
>(
  errorType: T,
)
⋮----
export const constructResponseSchema = <T extends z.ZodTypeAny>(
  schema: T,
): typeof ErrorResponsesSchema &
⋮----
export const createPaginatedResponseSchema = <T extends z.ZodTypeAny>(
  itemSchema: T,
) =>
export type PaginationQuery = z.infer<typeof PaginationQuerySchema>;
export type PaginationMeta = z.infer<typeof PaginationMetaSchema>;
⋮----
export type SortingQuery = z.infer<typeof SortingQuerySchema>;
export const createSortingQuerySchema = <
  T extends readonly [string, ...string[]],
>(
  allowedSortByValues: T,
)
export type SortingQueryFor<T extends readonly [string, ...string[]]> = {
  sortBy?: T[number];
  sortDirection?: "asc" | "desc";
};
</file>

<file path="platform/backend/src/types/chat-settings.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type ChatSettings = z.infer<typeof SelectChatSettingsSchema>;
export type InsertChatSettings = z.infer<typeof InsertChatSettingsSchema>;
export type UpdateChatSettings = z.infer<typeof UpdateChatSettingsSchema>;
</file>

<file path="platform/backend/src/types/conversation.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type Conversation = z.infer<typeof SelectConversationSchema>;
export type InsertConversation = z.infer<typeof InsertConversationSchema>;
export type UpdateConversation = z.infer<typeof UpdateConversationSchema>;
</file>

<file path="platform/backend/src/types/dual-llm-config.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type DualLlmConfig = z.infer<typeof SelectDualLlmConfigSchema>;
export type InsertDualLlmConfig = z.infer<typeof InsertDualLlmConfigSchema>;
</file>

<file path="platform/backend/src/types/dual-llm-result.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type DualLlmMessage = z.infer<typeof DualLlmMessageSchema>;
export type DualLlmResult = z.infer<typeof SelectDualLlmResultSchema>;
export type InsertDualLlmResult = z.infer<typeof InsertDualLlmResultSchema>;
</file>

<file path="platform/backend/src/types/fastify.d.ts">
import type { User } from "./user";
⋮----
interface FastifyRequest {
    user: User;
    organizationId: string;
  }
</file>

<file path="platform/backend/src/types/invitation.ts">
import { createInsertSchema, createUpdateSchema } from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type UpdateInvitation = z.infer<typeof UpdateInvitationSchema>;
export type InsertInvitation = z.infer<typeof InsertInvitationSchema>;
</file>

<file path="platform/backend/src/types/label.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { UuidIdSchema } from "./api";
⋮----
export type LabelKey = z.infer<typeof SelectLabelKeySchema>;
export type InsertLabelKey = z.infer<typeof InsertLabelKeySchema>;
export type LabelValue = z.infer<typeof SelectLabelValueSchema>;
export type InsertLabelValue = z.infer<typeof InsertLabelValueSchema>;
export type AgentLabel = z.infer<typeof SelectAgentLabelSchema>;
export type InsertAgentLabel = z.infer<typeof InsertAgentLabelSchema>;
export type AgentLabelWithDetails = z.infer<typeof AgentLabelWithDetailsSchema>;
</file>

<file path="platform/backend/src/types/limit.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type LimitEntityType = z.infer<typeof LimitEntityTypeSchema>;
⋮----
export type LimitType = z.infer<typeof LimitTypeSchema>;
⋮----
export type Limit = z.infer<typeof SelectLimitSchema>;
export type InsertLimit = z.infer<typeof InsertLimitSchema>;
export type CreateLimit = z.infer<typeof CreateLimitSchema>;
export type UpdateLimit = z.infer<typeof UpdateLimitSchema>;
export interface LimitUsageInfo {
  limitId: string;
  currentUsage: number;
  limitValue: number;
  isExceeded: boolean;
  remainingUsage: number;
}
export interface ModelUsageBreakdown {
  model: string;
  tokensIn: number;
  tokensOut: number;
  cost: number;
}
⋮----
export type LimitWithUsage = z.infer<typeof LimitWithUsageSchema>;
</file>

<file path="platform/backend/src/types/llm-proxy.ts">
import type { CommonToolResult } from "./tool-execution";
export interface CommonMessage {
  role: "user" | "assistant" | "tool" | "system" | "model" | "function";
  toolCalls?: CommonToolResult[];
}
export type ToolResultUpdates = Record<string, string>;
export interface CommonDualLlmParams {
  toolCallId: string;
  userRequest: string;
  toolResult: unknown;
}
</file>

<file path="platform/backend/src/types/mcp-server-installation-request.ts">
import { LocalConfigSchema, OAuthConfigSchema } from "@shared";
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type McpServerInstallationRequestStatus = z.infer<
  typeof McpServerInstallationRequestStatusSchema
>;
export type McpServerInstallationRequestNote = z.infer<
  typeof McpServerInstallationRequestNoteSchema
>;
export type McpServerInstallationRequestCustomServerConfig = z.infer<
  typeof McpServerInstallationRequestCustomServerConfigSchema
>;
export type McpServerInstallationRequest = z.infer<
  typeof SelectMcpServerInstallationRequestSchema
>;
export type InsertMcpServerInstallationRequest = z.infer<
  typeof InsertMcpServerInstallationRequestSchema
>;
export type UpdateMcpServerInstallationRequest = z.infer<
  typeof UpdateMcpServerInstallationRequestSchema
>;
</file>

<file path="platform/backend/src/types/mcp-server.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { InternalMcpCatalogServerTypeSchema } from "./mcp-catalog";
⋮----
export type LocalMcpServerInstallationStatus = z.infer<
  typeof LocalMcpServerInstallationStatusSchema
>;
export type McpServer = z.infer<typeof SelectMcpServerSchema>;
export type InsertMcpServer = z.infer<typeof InsertMcpServerSchema>;
export type UpdateMcpServer = z.infer<typeof UpdateMcpServerSchema>;
</file>

<file path="platform/backend/src/types/mcp-tool-call.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { CommonToolCallSchema } from "./tool-execution";
⋮----
export type McpToolCall = z.infer<typeof SelectMcpToolCallSchema>;
export type InsertMcpToolCall = z.infer<typeof InsertMcpToolCallSchema>;
</file>

<file path="platform/backend/src/types/member.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type Member = z.infer<typeof MemberSchema>;
export type UpdateMember = z.infer<typeof UpdateMemberSchema>;
export type InsertMember = z.infer<typeof InsertMemberSchema>;
</file>

<file path="platform/backend/src/types/message.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type Message = z.infer<typeof SelectMessageSchema>;
export type InsertMessage = z.infer<typeof InsertMessageSchema>;
</file>

<file path="platform/backend/src/types/secret.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type SecretValue = z.infer<typeof SecretValueSchema>;
export type SelectSecret = z.infer<typeof SelectSecretSchema>;
export type InsertSecret = z.infer<typeof InsertSecretSchema>;
export type UpdateSecret = z.infer<typeof UpdateSecretSchema>;
</file>

<file path="platform/backend/src/types/session.ts">
import type { AuthContext } from "@better-auth/core";
import { createInsertSchema, createUpdateSchema } from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type UpdateSession = z.infer<typeof UpdateSessionSchema>;
export type InsertSession = z.infer<typeof InsertSessionSchema>;
type BetterAuthSessionContext = AuthContext["session"];
export type BetterAuthSession =
  NonNullable<BetterAuthSessionContext>["session"];
export type BetterAuthSessionUser =
  NonNullable<BetterAuthSessionContext>["user"];
</file>

<file path="platform/backend/src/types/token-price.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type TokenPrice = z.infer<typeof SelectTokenPriceSchema>;
export type InsertTokenPrice = z.infer<typeof InsertTokenPriceSchema>;
export type CreateTokenPrice = z.infer<typeof CreateTokenPriceSchema>;
export type UpdateTokenPrice = z.infer<typeof UpdateTokenPriceSchema>;
</file>

<file path="platform/backend/src/types/tool-execution.ts">
import { z } from "zod";
⋮----
export type CommonMcpToolDefinition = {
  name: string;
  description?: string;
  inputSchema: Record<string, unknown>;
};
export type CommonToolCall = z.infer<typeof CommonToolCallSchema>;
export type CommonToolResult = {
  id: string;
  name: string;
  content: unknown;
  isError: boolean;
  error?: string;
};
</file>

<file path="platform/backend/src/types/user.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type User = z.infer<typeof UserSchema>;
export type UpdateUser = z.infer<typeof UpdateUserSchema>;
export type InsertUser = z.infer<typeof InsertUserSchema>;
</file>

<file path="platform/backend/src/llm-metrics.test.ts">
import type { GoogleGenAI } from "@google/genai";
import { vi } from "vitest";
import { beforeEach, describe, expect, test } from "@/test";
import type { Agent } from "@/types";
⋮----
observe(...args: unknown[])
⋮----
inc(...args: unknown[])
⋮----
import {
  getObservableFetch,
  getObservableGenAI,
  initializeMetrics,
} from "./llm-metrics";
⋮----
function getGenAIMock(response: Error | unknown)
</file>

<file path="platform/backend/src/llm-metrics.ts">
import type { GoogleGenAI } from "@google/genai";
import client from "prom-client";
import logger from "@/logging";
import type { Agent, SupportedProvider } from "@/types";
⋮----
type Fetch = (
  input: string | URL | Request,
  init?: RequestInit,
) => Promise<Response>;
⋮----
export function initializeMetrics(labelKeys: string[]): void
function buildMetricLabels(
  agent: Agent,
  additionalLabels: Record<string, string>,
): Record<string, string>
/**
 * Reports LLM token usage
 */
export function reportLLMTokens(
  provider: SupportedProvider,
  agent: Agent,
  usage: { input?: number; output?: number },
): void
export function reportBlockedTools(
  provider: SupportedProvider,
  agent: Agent,
  count: number,
)
export function getObservableFetch(
  provider: SupportedProvider,
  agent: Agent,
): Fetch
export function getObservableGenAI(genAI: GoogleGenAI, agent: Agent)
</file>

<file path="platform/backend/src/logging.ts">
import pino from "pino";
</file>

<file path="platform/backend/src/sentry.ts">
import type { TracesSamplerSamplingContext } from "@sentry/core";
⋮----
import { nodeProfilingIntegration } from "@sentry/profiling-node";
import config from "@/config";
import logger from "@/logging";
</file>

<file path="platform/backend/src/server.test.ts">
import { z } from "zod";
import { describe, expect, test, vi } from "@/test";
import { ApiError } from "@/types";
import { createFastifyInstance } from "./server";
</file>

<file path="platform/backend/src/templating.test.ts">
import { describe, expect, test } from "@/test";
import { applyResponseModifierTemplate } from "./templating";
</file>

<file path="platform/backend/src/templating.ts">
import type { Client } from "@modelcontextprotocol/sdk/client/index.js";
import Handlebars from "handlebars";
import type { CommonToolResult } from "@/types";
⋮----
/**
 * Apply a handlebars template to transform a tool response
 *
 * The content from MCP tools will look like:
 * https://modelcontextprotocol.io/specification/2025-06-18/server/tools#calling-tools
 *
 * @param templateString - Handlebars template string
 * @param toolCallResponseResultContent - The content returned from an MCP tool call
 * @returns Transformed content (parsed JSON or original content on failure)
 */
export function applyResponseModifierTemplate(
  templateString: string,
  toolCallResponseResultContent: Awaited<
    ReturnType<typeof Client.prototype.callTool>
  >["content"],
): CommonToolResult["content"]
⋮----
// Render the template with the response as context
⋮----
// Try to parse as JSON if possible, otherwise return as text
⋮----
// If it's not valid JSON, return as a text content block
</file>

<file path="platform/backend/src/tracing.ts">
import { FastifyOtelInstrumentation } from "@fastify/otel";
import { getNodeAutoInstrumentations } from "@opentelemetry/auto-instrumentations-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import {
  defaultResource,
  resourceFromAttributes,
} from "@opentelemetry/resources";
import { NodeSDK } from "@opentelemetry/sdk-node";
import {
  BatchSpanProcessor,
  type SpanProcessor,
} from "@opentelemetry/sdk-trace-base";
import {
  ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION,
} from "@opentelemetry/semantic-conventions";
⋮----
import {
  SentryPropagator,
  SentrySampler,
  SentrySpanProcessor,
} from "@sentry/opentelemetry";
import config from "@/config";
import logger from "@/logging";
import sentryClient from "@/sentry";
</file>

<file path="platform/benchmarks/.env.example">
# GCP Configuration
GCP_PROJECT_ID=your-project-id
GCP_ZONE=us-central1-a
GCP_MACHINE_TYPE=n2-standard-4

# Benchmark Configuration
NUM_REQUESTS=40000
CONCURRENCY=1000

# Platform Configuration (set on Archestra VM)
BENCHMARK_MOCK_MODE=true
</file>

<file path="platform/benchmarks/.gitignore">
results
.env
benchmark-config.env
</file>

<file path="platform/benchmarks/cleanup-gcp-benchmark.sh">
set -e
if [ -f benchmark-config.env ]; then
    set -a
    source benchmark-config.env
    set +a
else
    echo "❌ Error: benchmark-config.env not found"
    echo "This file is created by setup-gcp-benchmark.sh"
    echo "Please run setup-gcp-benchmark.sh first, or set variables manually:"
    echo "  export GCP_PROJECT_ID=your-project-id"
    echo "  export GCP_ZONE=us-central1-a"
    exit 1
fi
if [ -z "$GCP_PROJECT_ID" ]; then
    echo "❌ Error: GCP_PROJECT_ID not set in benchmark-config.env"
    exit 1
fi
if [ -z "$GCP_ZONE" ]; then
    echo "❌ Error: GCP_ZONE not set in benchmark-config.env"
    exit 1
fi
PROJECT_ID="$GCP_PROJECT_ID"
ZONE="$GCP_ZONE"
ARCHESTRA_VM_NAME="archestra-platform-vm"
LOADTEST_VM_NAME="loadtest-vm"
echo "=========================================="
echo "GCP Benchmark Cleanup"
echo "=========================================="
echo "Project: $PROJECT_ID"
echo "Zone: $ZONE"
echo "=========================================="
gcloud config set project "$PROJECT_ID"
echo "🗑️  Deleting VMs..."
gcloud compute instances delete "$ARCHESTRA_VM_NAME" --zone="$ZONE" --quiet 2>/dev/null || echo "  Archestra VM not found"
gcloud compute instances delete "$LOADTEST_VM_NAME" --zone="$ZONE" --quiet 2>/dev/null || echo "  Load Test VM not found"
echo "✅ VMs deleted"
echo "🗑️  Deleting firewall rule..."
gcloud compute firewall-rules delete archestra-benchmark-allow-9000 --quiet 2>/dev/null || echo "  Firewall rule not found"
echo "✅ Firewall rule deleted"
if [ -f benchmark-config.env ]; then
    rm benchmark-config.env
    echo "✅ Local configuration removed"
fi
echo ""
echo "=========================================="
echo "✅ Cleanup Complete!"
echo "=========================================="
</file>

<file path="platform/benchmarks/run-benchmark.sh">
set -e
if [ -f benchmark-config.env ]; then
    set -a
    source benchmark-config.env
    set +a
else
    echo "❌ Error: benchmark-config.env not found"
    echo "Please copy this file from the setup machine or run setup-gcp-benchmark.sh"
    exit 1
fi
if [ -z "$ARCHESTRA_API_URL" ]; then
    echo "❌ Error: ARCHESTRA_API_URL not set in benchmark-config.env"
    exit 1
fi
if [ -f .env ]; then
    set -a
    source .env
    set +a
fi
if [ -z "$NUM_REQUESTS" ]; then
    echo "❌ Error: NUM_REQUESTS not set in .env"
    exit 1
fi
if [ -z "$CONCURRENCY" ]; then
    echo "❌ Error: CONCURRENCY not set in .env"
    exit 1
fi
ARCHESTRA_API_URL="$ARCHESTRA_API_URL"
OPENAI_API_KEY="sk-mock-key"
NUM_REQUESTS="$NUM_REQUESTS"
CONCURRENCY="$CONCURRENCY"
RESULTS_DIR="results"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
echo "=========================================="
echo "Archestra Platform Benchmark"
echo "=========================================="
echo "API URL: $ARCHESTRA_API_URL"
echo "Requests: $NUM_REQUESTS"
echo "Concurrency: $CONCURRENCY"
echo "Timestamp: $TIMESTAMP"
echo "=========================================="
mkdir -p "$RESULTS_DIR"
run_ab_test() {
    local test_name=$1
    local endpoint=$2
    local payload_file=$3
    local output_file="$RESULTS_DIR/${test_name}_${TIMESTAMP}.txt"
    echo ""
    echo "📊 Running: $test_name"
    echo "   Endpoint: $endpoint"
    echo "   Payload: $payload_file"
    ab -n "$NUM_REQUESTS" \
       -c "$CONCURRENCY" \
       -p "$payload_file" \
       -T "application/json" \
       -H "Authorization: Bearer $OPENAI_API_KEY" \
       "$endpoint" > "$output_file" 2>&1
    echo "   ✅ Complete"
    local requests_per_sec=$(grep "Requests per second" "$output_file" | awk '{print $4}')
    local mean_time=$(grep "Time per request" "$output_file" | grep -v concurrent | awk '{print $4}')
    local p50=$(grep " 50%" "$output_file" | awk '{print $2}')
    local p95=$(grep " 95%" "$output_file" | awk '{print $2}')
    local p99=$(grep " 99%" "$output_file" | awk '{print $2}')
    local failed=$(grep "Failed requests" "$output_file" | awk '{print $3}')
    echo "   Throughput: $requests_per_sec req/s"
    echo "   Mean Latency: ${mean_time}ms"
    echo "   P50: ${p50}ms"
    echo "   P95: ${p95}ms"
    echo "   P99: ${p99}ms"
    echo "   Failed: $failed"
    echo "| $test_name | $requests_per_sec | ${mean_time} | ${p50} | ${p95} | ${p99} | $failed |" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
}
cat > "$RESULTS_DIR/summary_${TIMESTAMP}.md" <<EOF
**Date**: $(date)
**API URL**: $ARCHESTRA_API_URL
**Total Requests**: $NUM_REQUESTS
**Concurrency**: $CONCURRENCY
**Mock Mode**: Enabled (no real OpenAI API calls)
---
| Test Scenario | Throughput (req/s) | Mean Latency (ms) | P50 (ms) | P95 (ms) | P99 (ms) | Failed |
|---------------|-------------------|-------------------|----------|----------|----------|---------|
EOF
run_ab_test \
    "chat_with_tools" \
    "${ARCHESTRA_API_URL}/v1/openai/chat/completions" \
    "test-payloads/chat-with-tools.json"
echo "" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "---" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "## Notes" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "- All tests run with mock OpenAI responses (no network latency)" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "- Metrics show pure Archestra platform overhead" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "- Full Apache Bench output available in individual result files" >> "$RESULTS_DIR/summary_${TIMESTAMP}.md"
echo ""
echo "=========================================="
echo "✅ Benchmark Complete!"
echo "=========================================="
echo ""
echo "Results saved to: $RESULTS_DIR/"
echo "Summary: $RESULTS_DIR/summary_${TIMESTAMP}.md"
echo ""
echo "View summary:"
echo "  cat $RESULTS_DIR/summary_${TIMESTAMP}.md"
echo "=========================================="
cat "$RESULTS_DIR/summary_${TIMESTAMP}.md"
</file>

<file path="platform/benchmarks/setup-gcp-benchmark.sh">
set -e
if [ -f .env ]; then
    set -a
    source .env
    set +a
else
    echo "❌ Error: .env file not found"
    echo "Please copy .env.example to .env and configure your settings"
    exit 1
fi
if [ -z "$GCP_PROJECT_ID" ]; then
    echo "❌ Error: GCP_PROJECT_ID is not set in .env"
    exit 1
fi
if [ -z "$GCP_ZONE" ]; then
    echo "❌ Error: GCP_ZONE is not set in .env"
    exit 1
fi
if [ -z "$GCP_MACHINE_TYPE" ]; then
    echo "❌ Error: GCP_MACHINE_TYPE is not set in .env"
    exit 1
fi
PROJECT_ID="$GCP_PROJECT_ID"
ZONE="$GCP_ZONE"
MACHINE_TYPE="$GCP_MACHINE_TYPE"
ARCHESTRA_VM_NAME="archestra-platform-vm"
LOADTEST_VM_NAME="loadtest-vm"
IMAGE_FAMILY="ubuntu-2204-lts"
IMAGE_PROJECT="ubuntu-os-cloud"
echo "=========================================="
echo "GCP Benchmark Environment Setup"
echo "=========================================="
echo "Project: $PROJECT_ID"
echo "Zone: $ZONE"
echo "Machine Type: $MACHINE_TYPE"
echo "=========================================="
if ! command -v gcloud &> /dev/null; then
    echo "❌ Error: gcloud CLI is not installed"
    echo "Please install it from: https://cloud.google.com/sdk/docs/install"
    exit 1
fi
echo "📋 Setting GCP project..."
gcloud config set project "$PROJECT_ID"
echo "🔥 Creating firewall rule for port 9000..."
gcloud compute firewall-rules create archestra-benchmark-allow-9000 \
    --allow=tcp:9000 \
    --source-ranges=10.128.0.0/9 \
    --target-tags=archestra-benchmark-platform \
    --direction=INGRESS \
    2>/dev/null || echo "  Firewall rule already exists"
echo "✅ Firewall rule configured"
echo "🚀 Creating Archestra Platform VM..."
ARCHESTRA_STARTUP_SCRIPT='#!/bin/bash
set -e
echo "Installing Docker..."
apt-get update
apt-get install -y ca-certificates curl
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
chmod a+r /etc/apt/keyrings/docker.asc
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
apt-get update
apt-get install -y docker-ce docker-ce-cli containerd.io
echo "Starting Archestra Platform..."
docker run -d -p 9000:9000 -p 3000:3000 -e BENCHMARK_MOCK_MODE=true --name archestra archestra/platform:latest
echo "✅ Archestra Platform is running (mock mode enabled)"
echo "API: http://$(hostname -I | awk "{print \$1}"):9000"
'
gcloud compute instances create "$ARCHESTRA_VM_NAME" \
    --zone="$ZONE" \
    --machine-type="$MACHINE_TYPE" \
    --image-family="$IMAGE_FAMILY" \
    --image-project="$IMAGE_PROJECT" \
    --boot-disk-size=50GB \
    --boot-disk-type=pd-standard \
    --metadata=startup-script="$ARCHESTRA_STARTUP_SCRIPT" \
    --tags=archestra-benchmark-platform \
    2>/dev/null || echo "  VM already exists"
echo "✅ Archestra VM created"
echo "🔨 Creating Load Test VM..."
LOADTEST_STARTUP_SCRIPT='#!/bin/bash
set -e
echo "Installing Apache Bench..."
apt-get update
apt-get install -y apache2-utils curl jq
echo "✅ Apache Bench installed"
'
gcloud compute instances create "$LOADTEST_VM_NAME" \
    --zone="$ZONE" \
    --machine-type="$MACHINE_TYPE" \
    --image-family="$IMAGE_FAMILY" \
    --image-project="$IMAGE_PROJECT" \
    --boot-disk-size=20GB \
    --boot-disk-type=pd-standard \
    --metadata=startup-script="$LOADTEST_STARTUP_SCRIPT" \
    --tags=archestra-benchmark-loadtest \
    2>/dev/null || echo "  VM already exists"
echo "✅ Load Test VM created"
echo "⏳ Waiting for VMs to be ready..."
sleep 30
ARCHESTRA_INTERNAL_IP=$(gcloud compute instances describe "$ARCHESTRA_VM_NAME" \
    --zone="$ZONE" \
    --format='get(networkInterfaces[0].networkIP)')
LOADTEST_INTERNAL_IP=$(gcloud compute instances describe "$LOADTEST_VM_NAME" \
    --zone="$ZONE" \
    --format='get(networkInterfaces[0].networkIP)')
echo ""
echo "=========================================="
echo "✅ Benchmark Environment Ready!"
echo "=========================================="
echo ""
echo "📊 Archestra Platform VM:"
echo "  Name: $ARCHESTRA_VM_NAME"
echo "  Internal IP: $ARCHESTRA_INTERNAL_IP"
echo "  API Endpoint: http://$ARCHESTRA_INTERNAL_IP:9000"
echo ""
echo "🔨 Load Test VM:"
echo "  Name: $LOADTEST_VM_NAME"
echo "  Internal IP: $LOADTEST_INTERNAL_IP"
echo ""
echo "To connect:"
echo "  Archestra VM: gcloud compute ssh $ARCHESTRA_VM_NAME --zone=$ZONE"
echo "  Load Test VM: gcloud compute ssh $LOADTEST_VM_NAME --zone=$ZONE"
echo ""
echo "To check Archestra status:"
echo "  gcloud compute ssh $ARCHESTRA_VM_NAME --zone=$ZONE --command='docker logs archestra'"
echo ""
echo "To cleanup:"
echo "  ./cleanup-gcp-benchmark.sh"
echo "=========================================="
cat > benchmark-config.env <<EOF
export GCP_PROJECT_ID=$PROJECT_ID
export GCP_ZONE=$ZONE
export ARCHESTRA_VM_NAME=$ARCHESTRA_VM_NAME
export LOADTEST_VM_NAME=$LOADTEST_VM_NAME
export ARCHESTRA_INTERNAL_IP=$ARCHESTRA_INTERNAL_IP
export LOADTEST_INTERNAL_IP=$LOADTEST_INTERNAL_IP
export ARCHESTRA_API_URL=http://$ARCHESTRA_INTERNAL_IP:9000
EOF
echo "✅ Configuration saved to benchmark-config.env"
</file>

<file path="platform/dev/Tiltfile.database">
# Database resources
load('ext://helm_remote', 'helm_remote')

# PostgreSQL database for local development
# https://dev.to/flodev/use-tilt-to-provide-easy-to-setup-development-environments-4n9d
helm_remote(
  'postgresql',
  repo_url='https://charts.bitnami.com/bitnami',
  namespace='archestra-dev',
  create_namespace=True,
  set=[
    'auth.database=archestra_dev',
    'auth.username=archestra',
    'auth.password=archestra_dev_password',

    # NOTE: Bitnami is archiving their image.. see these github comments for details
    # (this is essentially why we need to override image.repository and image.tag and global.security.allowInsecureImages)
    #
    # https://github.com/coder/coder/issues/19869#issuecomment-3305875979
    # https://github.com/bitnami/containers/issues/83267
    'image.repository=bitnamisecure/postgresql',
    'image.tag=latest',
    'global.security.allowInsecureImages=true'
  ]
)

k8s_resource('postgresql', port_forwards=['5432:5432'], labels=['database'])

# Database cleanup button (manual trigger only, for development)
local_resource(
  'db-clean',
  cmd='pnpm db:clean && tilt trigger db-migrate',
  dir='../backend',
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  labels=['database']
)

local_resource(
  'db-seed-mock-data',
  cmd='pnpm db:seed:mock-data',
  resource_deps=['pnpm-install', 'postgresql'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  labels=['database']
)

local_resource(
  'db-migrate',
  # NOTE: we need to cd into the backend directory to run the migrate command
  # because otherwise if we run the command from this directory, it is run via turbo, which does not properly
  # propogate the required environment variables (ie. DATABASE_URL)
  # Retry logic: wait for PostgreSQL to be ready before running migrations, then seed
  cmd='''
    for i in {1..30}; do
      if pnpm db:migrate 2>/dev/null; then
        echo "✅ Migration completed successfully"
        tilt trigger pnpm-dev
        exit 0
      fi
      echo "⏳ Waiting for PostgreSQL... (attempt $i/30)"
      sleep 2
    done
    echo "❌ Migration failed after 30 attempts"
    exit 1
  ''',
  dir='../backend',
  deps=['../backend/src/database/migrations'],
  resource_deps=['pnpm-install', 'postgresql'],
  labels=['database']
)

local_resource(
  'db-generate',
  cmd='pnpm db:generate',
  dir='../backend',
  resource_deps=['postgresql'],
  labels=['database'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
)

local_resource(
  'database-gui',
  # NOTE: we need to cd into the backend directory to run the migrate command
  # because otherwise if we run the command from this directory, it is run via turbo, which does not properly
  # propogate the required environment variables (ie. DATABASE_URL)
  serve_cmd='pnpm db:studio',
  serve_dir='../backend',
  labels=['database'],
  resource_deps=['postgresql']
)
</file>

<file path="platform/e2e-tests/tests/api/agents.spec.ts">
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/api/mcp-gateway.spec.ts">
import {
  MCP_GATEWAY_URL_SUFFIX,
  MCP_SERVER_TOOL_NAME_SEPARATOR,
} from "../../consts";
import { expect, test } from "./fixtures";
⋮----
const makeMcpGatewayRequestHeaders = (sessionId?: string) => (
</file>

<file path="platform/e2e-tests/tests/api/mcp-server-installation-requests.spec.ts">
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/api/metrics.spec.ts">
import {
  API_BASE_URL,
  METRICS_BASE_URL,
  METRICS_BEARER_TOKEN,
  METRICS_ENDPOINT,
} from "../../consts";
import { type APIRequestContext, expect, test } from "./fixtures";
const fetchMetrics = async (
  request: APIRequestContext,
  baseUrl: string,
  bearerToken: string,
)
</file>

<file path="platform/e2e-tests/tests/api/orchestrator.spec.ts">
import {
  type APIRequestContext,
  expect,
  type TestFixtures,
  test,
} from "./fixtures";
⋮----
const waitForMcpServerReady = async (
    request: APIRequestContext,
    makeApiRequest: TestFixtures["makeApiRequest"],
    serverId: string,
    maxRetries = 30,
) =>
const getMcpServerTools = async (
    request: APIRequestContext,
    makeApiRequest: TestFixtures["makeApiRequest"],
    serverId: string,
) =>
</file>

<file path="platform/e2e-tests/tests/ui/agents.spec.ts">
import { E2eTestId } from "@shared";
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/ui/fixtures.ts">
import { test as base, type Page } from "@playwright/test";
import { UI_BASE_URL } from "../../consts";
interface TestFixtures {
  goToPage: typeof goToPage;
  makeRandomString: typeof makeRandomString;
}
const goToPage = (page: Page, path = "") => page.goto(`$
const makeRandomString = (length = 10, prefix = "")
</file>

<file path="platform/e2e-tests/.gitignore">
# Playwright
node_modules/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/
/playwright/.auth/
</file>

<file path="platform/e2e-tests/consts.ts">

</file>

<file path="platform/e2e-tests/playwright.config.ts">
import path from "node:path";
import { defineConfig, devices } from "@playwright/test";
</file>

<file path="platform/examples/ai-sdk-express/src/server.ts">
import { createOpenAI } from "@ai-sdk/openai";
import { type CoreMessage, stepCountIs, streamText, tool } from "ai";
⋮----
import { readFileSync } from "node:fs";
⋮----
import { z } from "zod";
⋮----
async function chat(userMessage: string)
function promptUser()
</file>

<file path="platform/examples/ai-sdk-express/.env.example">
OPENAI_API_KEY=""
</file>

<file path="platform/examples/ai-sdk-express/.gitignore">
.env
</file>

<file path="platform/examples/mastra-ai/src/mastra/agents/github-agent.ts">
import { createOpenAI, openai as defaultOpenAi } from "@ai-sdk/openai";
import { Agent } from "@mastra/core/agent";
import { PinoLogger } from "@mastra/loggers";
import { githubTool } from "../tools/github-tool";
</file>

<file path="platform/examples/mastra-ai/src/mastra/tools/github-tool.ts">
import { createTool } from "@mastra/core/tools";
import { z } from "zod";
</file>

<file path="platform/examples/mastra-ai/src/mastra/index.ts">
import { Mastra } from "@mastra/core/mastra";
import { LibSQLStore } from "@mastra/libsql";
import { PinoLogger } from "@mastra/loggers";
import { githubAgent } from "./agents/github-agent";
</file>

<file path="platform/examples/mastra-ai/.env.example">
# Open AI API key, see https://platform.openai.com/api-keys. Required.
OPENAI_API_KEY=

# Github token for Github tools. Required.
GITHUB_TOKEN=

# Optional Open AI proxy url
OPENAI_PROXY_URL=
</file>

<file path="platform/examples/mastra-ai/.gitignore">
output.txt
node_modules
dist
.mastra
.env.development
.env
*.db
*.db-*
</file>

<file path="platform/examples/pydantic-ai/.env.example">
OPENAI_API_KEY=""
ANTHROPIC_API_KEY=""
GEMINI_API_KEY=""
GITHUB_TOKEN=""
</file>

<file path="platform/examples/pydantic-ai/.gitignore">
.env
</file>

<file path="platform/examples/pydantic-ai/Dockerfile">
FROM python:3.11.3

WORKDIR /app

# Copy requirements and install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY main.py .
COPY .env .

# Set entrypoint to run the agent
ENTRYPOINT ["python", "main.py"]
</file>

<file path="platform/examples/pydantic-ai/main.py">
AGENT_TASK = """You are a software engineering assistant. Please help me build the feature described in this GitHub issue:
def get_model(use_archestra: bool = False)
⋮----
provider = os.getenv("LLM_PROVIDER", "openai").lower()
model_name = os.getenv("MODEL_NAME")
extra_provider_kwargs = {
⋮----
model_name = "claude-sonnet-4-5-20250929"
model = AnthropicModel(
⋮----
model_name = "gemini-2.5-pro"
model = GoogleModel(
⋮----
model_name = "gpt-4o"
model = OpenAIChatModel(
⋮----
async def run_agent(use_archestra: bool = False)
⋮----
agent = Agent(
⋮----
@agent.tool
  def read_file(ctx: RunContext[None], file_path: str) -> dict
⋮----
content = f.read()
⋮----
@agent.tool
  def get_github_issue(ctx: RunContext[None], owner: str, repo: str, issue_number: int) -> dict
⋮----
url = f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}"
headers = {
response = requests.get(url, headers=headers, timeout=10)
⋮----
issue_data = response.json()
result = {
⋮----
@agent.tool
  def send_email(ctx: RunContext[None], to: str, subject: str, body: str) -> dict
⋮----
def main()
⋮----
parser = argparse.ArgumentParser(
⋮----
args = parser.parse_args()
mode = "🔒 Archestra-secured" if args.secure else "⚠️  Direct to LLM provider (UNSAFE)"
</file>

<file path="platform/experiments/dummy_email_mcp_server/Dockerfile">
FROM python:3.11-slim

# Install dependencies
RUN pip install mcp pydantic

# Copy the MCP server
COPY main.py /app/main.py
WORKDIR /app

# Make the script executable
RUN chmod +x main.py

# Run the MCP server
CMD ["python", "main.py"]
</file>

<file path="platform/experiments/dummy_email_mcp_server/main.py">
logger = logging.getLogger("email-mcp-server")
server = Server("email-mcp-server")
class SendEmailParams(BaseModel)
⋮----
to: str
subject: str
body: str
⋮----
@server.list_tools()
async def list_tools() -> list[Tool]
⋮----
@server.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]
⋮----
params = SendEmailParams.model_validate(arguments)
⋮----
async def main()
</file>

<file path="platform/experiments/src/index.ts">

</file>

<file path="platform/experiments/src/interceptor.ts">
import type { IncomingMessage, request } from "node:http";
import { logger } from "./logger";
export interface ArchestraConfig {
  text2: string;
}
export class Archestra
⋮----
constructor()
public instrumentAll(): void
public instrumentFetch(): void
⋮----
start(controller)
⋮----
function pump(): Promise<void>
⋮----
public instrumentNodeHTTP(): void
⋮----
async function parseResponseBody(
  response: Response,
): Promise<
function parseNodeRequestURL(options: any, isHttps: boolean): string
function interceptNodeRequest(
  originalRequest: typeof request,
  options: any,
  callback: any,
  isHttps: boolean,
)
⋮----
// Parse URL from options
⋮----
// Create the request
</file>

<file path="platform/experiments/src/logger.ts">
class Logger
⋮----
info(message: string, color?: Color)
error(message: string, color?: Color)
warn(message: string, color?: Color)
debug(message: string, color: Color = "blue")
private formatMessage(message: string, color: Color = "magenta")
⋮----
type Color = keyof typeof colors;
</file>

<file path="platform/experiments/src/main.ts">
import Fastify, { type FastifyReply, type FastifyRequest } from "fastify";
import { OpenAI } from "openai";
interface ChatCompletionRequest {
  model: string;
  messages: Array<{
    role: "system" | "user" | "assistant";
    content: string;
  }>;
  temperature?: number;
  max_tokens?: number;
  stream?: boolean;
}
⋮----
const start = async () =>
</file>

<file path="platform/frontend/src/app/_parts/error-boundary.tsx">
import { QueryErrorResetBoundary } from "@tanstack/react-query";
import type { ComponentProps, ComponentType } from "react";
import { ErrorBoundary as ReactErrorBoundary } from "react-error-boundary";
import { ClientErrorFallback } from "@/components/error-fallback";
type FallbackProps = {
  error: Error;
  resetErrorBoundary: () => void;
};
⋮----
const onError = (_error: Error) =>
</file>

<file path="platform/frontend/src/app/_parts/posthog-provider.tsx">
import posthog from "posthog-js";
import { PostHogProvider } from "posthog-js/react";
import { useEffect } from "react";
import config from "@/lib/config";
export function PostHogProviderWrapper({
  children,
}: {
  children: React.ReactNode;
})
</file>

<file path="platform/frontend/src/app/_parts/query-client-provider.tsx">
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useState } from "react";
export const ArchestraQueryClientProvider = ({
  children,
}: {
  children: React.ReactNode;
}) =>
</file>

<file path="platform/frontend/src/app/_parts/theme-provider.tsx">
import { ThemeProvider as NextThemesProvider } from "next-themes";
⋮----
export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>)
</file>

<file path="platform/frontend/src/app/account/[path]/page.tsx">
import { AccountView } from "@daveyplate/better-auth-ui";
import { accountViewPaths } from "@daveyplate/better-auth-ui/server";
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
⋮----
export function generateStaticParams()
</file>

<file path="platform/frontend/src/app/api/chat-demo/route.ts">
import { convertToModelMessages, streamText, type UIMessage } from "ai";
⋮----
export async function POST(req: Request)
</file>

<file path="platform/frontend/src/app/cost/page.tsx">
import { redirect } from "next/navigation";
export default function CostPage()
</file>

<file path="platform/frontend/src/app/logs/[id]/page.tsx">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { getServerApiHeaders } from "@/lib/server-utils";
import { ChatPage } from "./page.client";
export default async function ChatPageServer({
  params,
}: {
  params: Promise<{ id: string }>;
})
</file>

<file path="platform/frontend/src/app/logs/llm-proxy/page.tsx">
import {
  archestraApiSdk,
  type archestraApiTypes,
  type ErrorExtended,
} from "@shared";
import { ServerErrorFallback } from "@/components/error-fallback";
import { getServerApiHeaders } from "@/lib/server-utils";
import { DEFAULT_TABLE_LIMIT } from "@/lib/utils";
import LlmProxyLogsPage from "./page.client";
⋮----
export default async function LlmProxyLogsPageServer()
</file>

<file path="platform/frontend/src/app/logs/mcp-gateway/page.tsx">
import {
  archestraApiSdk,
  type archestraApiTypes,
  type ErrorExtended,
} from "@shared";
import { ServerErrorFallback } from "@/components/error-fallback";
import { getServerApiHeaders } from "@/lib/server-utils";
import { DEFAULT_TABLE_LIMIT } from "@/lib/utils";
import McpGatewayLogsPage from "./page.client";
⋮----
export default async function McpGatewayLogsPageServer()
</file>

<file path="platform/frontend/src/app/logs/layout.tsx">
import { PageLayout } from "@/components/page-layout";
export default function LogsLayout({
  children,
}: {
  children: React.ReactNode;
})
</file>

<file path="platform/frontend/src/app/logs/page.tsx">
import { redirect } from "next/navigation";
export default function LogsPage()
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/delete-catalog-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useDeleteInternalMcpCatalogItem } from "@/lib/internal-mcp-catalog.query";
interface DeleteCatalogDialogProps {
  item: archestraApiTypes.GetInternalMcpCatalogResponses["200"][number] | null;
  onClose: () => void;
  installationCount: number;
}
⋮----
const handleConfirm = async () =>
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/manage-local-installations-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { format } from "date-fns";
import { Server, Trash } from "lucide-react";
import { useCallback, useMemo } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { authClient } from "@/lib/clients/auth/auth-client";
import {
  useMcpServers,
  useRevokeUserMcpServerAccess,
} from "@/lib/mcp-server.query";
interface ManageLocalInstallationsDialogProps {
  isOpen: boolean;
  onClose: () => void;
  server:
    | archestraApiTypes.GetMcpServersResponses["200"][number]
    | null
    | undefined;
  label?: string;
}
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/manage-users-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { format } from "date-fns";
import { Trash, User } from "lucide-react";
import { useCallback, useMemo } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { authClient } from "@/lib/clients/auth/auth-client";
import {
  useMcpServers,
  useRevokeUserMcpServerAccess,
} from "@/lib/mcp-server.query";
interface ManageUsersDialogProps {
  isOpen: boolean;
  onClose: () => void;
  server:
    | archestraApiTypes.GetMcpServersResponses["200"][number]
    | null
    | undefined;
  label?: string;
}
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-catalog-form.test.ts">
import { formSchema } from "./mcp-catalog-form.types";
import { stripEnvVarQuotes } from "./mcp-catalog-form.utils";
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-catalog-form.types.ts">
import { LocalConfigFormSchema } from "@shared";
import { z } from "zod";
⋮----
export type McpCatalogFormValues = z.infer<typeof formSchema>;
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/no-auth-install-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Building2, Info, X } from "lucide-react";
import { useCallback, useState } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useHasPermissions } from "@/lib/auth.query";
import { useTeams } from "@/lib/team.query";
type CatalogItem =
  archestraApiTypes.GetInternalMcpCatalogResponses["200"][number];
interface NoAuthInstallDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onInstall: (teams: string[]) => Promise<void>;
  catalogItem: CatalogItem | null;
  isInstalling: boolean;
}
⋮----
<Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => handleRemoveTeam(teamId)}
                          className="h-auto p-0.5 ml-1 hover:bg-destructive/20"
                        >
                          <X className="h-3 w-3" />
                        </Button>
                      </Badge>
                    );
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/reinstall-confirmation-dialog.tsx">
import { RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
interface ReinstallConfirmationDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  serverName: string;
  isReinstalling: boolean;
  isRemoteServer: boolean;
}
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/remote-server-install-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Building2, Info, ShieldCheck, User, X } from "lucide-react";
import { useState } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useTeams } from "@/lib/team.query";
type CatalogItem =
  archestraApiTypes.GetInternalMcpCatalogResponses["200"][number];
type UserConfigType = Record<
  string,
  {
    type: "string" | "number" | "boolean" | "directory" | "file";
    title: string;
    description: string;
    required?: boolean;
    default?: string | number | boolean | Array<string>;
    multiple?: boolean;
    sensitive?: boolean;
    min?: number;
    max?: number;
  }
>;
interface RemoteServerInstallDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: (
    catalogItem: CatalogItem,
    metadata: Record<string, unknown>,
    teams: string[],
  ) => Promise<void>;
  catalogItem: CatalogItem | null;
  isInstalling: boolean;
  isTeamMode?: boolean;
}
⋮----
const handleAddTeam = (teamId: string) =>
const handleRemoveTeam = (teamId: string) =>
⋮----
const getTeamById = (teamId: string) =>
const handleConfirm = async () =>
⋮----
// Validate required fields
⋮----
// Convert values to appropriate types based on config
⋮----
// Error handling is done in the parent component
⋮----
const handleClose = () =>
⋮----
// Check if all required fields are filled
⋮----
<Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={() => handleRemoveTeam(teamId)}
                            className="h-auto p-0.5 ml-1 hover:bg-destructive/20"
                          >
                            <X className="h-3 w-3" />
                          </Button>
                        </Badge>
                      );
⋮----
setConfigValues((prev) => (
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/transport-badges.tsx">
import { Badge } from "@/components/ui/badge";
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/uninstall-server-dialog.tsx">
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useDeleteMcpServer } from "@/lib/mcp-server.query";
interface UninstallServerDialogProps {
  server: { id: string; name: string } | null;
  onClose: () => void;
  isCancelingInstallation?: boolean;
  onCancelInstallation?: (serverId: string) => void;
}
export function UninstallServerDialog({
  server,
  onClose,
  isCancelingInstallation = false,
  onCancelInstallation,
}: UninstallServerDialogProps)
⋮----
const handleConfirm = async () =>
</file>

<file path="platform/frontend/src/app/mcp-catalog/registry/page.client.tsx">
import type { archestraApiTypes } from "@shared";
import { InternalMCPCatalog } from "../_parts/InternalMCPCatalog";
export default function McpRegistryClient({
  initialData,
}: {
  initialData: {
    catalog: archestraApiTypes.GetInternalMcpCatalogResponses["200"];
    servers: archestraApiTypes.GetMcpServersResponses["200"];
  };
})
</file>

<file path="platform/frontend/src/app/mcp-catalog/registry/page.tsx">
import {
  archestraApiSdk,
  type archestraApiTypes,
  type ErrorExtended,
} from "@shared";
import { ServerErrorFallback } from "@/components/error-fallback";
import { getServerApiHeaders } from "@/lib/server-utils";
import McpRegistryClient from "./page.client";
⋮----
export default async function McpRegistryPage()
</file>

<file path="platform/frontend/src/app/mcp-catalog/layout.tsx">
import { PageLayout } from "@/components/page-layout";
import { useHasPermissions } from "@/lib/auth.query";
</file>

<file path="platform/frontend/src/app/mcp-catalog/page.tsx">
import { redirect } from "next/navigation";
export default function McpCatalogPage()
</file>

<file path="platform/frontend/src/app/oauth-callback/page.tsx">
import { AlertCircle, CheckCircle, Loader2 } from "lucide-react";
import { useRouter, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useInstallMcpServer } from "@/lib/mcp-server.query";
export default function OAuthCallbackPage()
⋮----
const handleOAuthCallback = async () =>
⋮----
<Button onClick=
</file>

<file path="platform/frontend/src/app/organization/[path]/page.tsx">
import { OrganizationView } from "@daveyplate/better-auth-ui";
import { organizationViewPaths } from "@daveyplate/better-auth-ui/server";
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
⋮----
export function generateStaticParams()
</file>

<file path="platform/frontend/src/app/settings/account/page.tsx">
import { ApiKeysCard, SecuritySettingsCards } from "@daveyplate/better-auth-ui";
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
function AccountSettingsContent()
</file>

<file path="platform/frontend/src/app/settings/appearance/_components/font-selector.tsx">
import type { OrganizationCustomFont } from "@shared";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { fonts } from "@/config/themes";
interface FontSelectorProps {
  selectedFont: OrganizationCustomFont;
  onFontSelect: (fontId: OrganizationCustomFont) => void;
}
export function FontSelector({
  selectedFont,
  onFontSelect,
}: FontSelectorProps)
</file>

<file path="platform/frontend/src/app/settings/appearance/_components/light-dark-toggle.tsx">
import { Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
export function LightDarkToggle()
</file>

<file path="platform/frontend/src/app/settings/appearance/_components/theme-selector.tsx">
import type { OrganizationTheme } from "@shared";
import { Check } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  getThemeCategories,
  getThemesByCategory,
  type ThemeMetadata,
} from "@/config/themes";
interface ThemeSelectorProps {
  selectedTheme: OrganizationTheme | undefined;
  onThemeSelect: (themeId: OrganizationTheme) => void;
}
⋮----
onClick=
</file>

<file path="platform/frontend/src/app/settings/members/page.tsx">
import { OrganizationMembersCard } from "@daveyplate/better-auth-ui";
import { useQueryClient } from "@tanstack/react-query";
import { Suspense, useState } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { InvitationsList } from "@/components/invitations-list";
import { InviteByLinkCard } from "@/components/invite-by-link-card";
import { LoadingSpinner } from "@/components/loading";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  organizationKeys,
  useActiveMemberRole,
  useActiveOrganization,
} from "@/lib/organization.query";
⋮----
setInviteDialogOpen(open);
⋮----
setInviteDialogOpen(true);
</file>

<file path="platform/frontend/src/app/settings/roles/page.tsx">
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
import { RolesList } from "@/components/roles/roles-list";
function RolesSettingsContent()
</file>

<file path="platform/frontend/src/app/settings/teams/page.tsx">
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
import { TeamsList } from "@/components/teams/teams-list";
function TeamsSettingsContent()
</file>

<file path="platform/frontend/src/app/settings/page.tsx">
import { redirect } from "next/navigation";
export default function SettingsPage()
</file>

<file path="platform/frontend/src/app/tools/layout.tsx">
import { PageLayout } from "@/components/page-layout";
export default function ToolsLayout({
  children,
}: {
  children: React.ReactNode;
})
</file>

<file path="platform/frontend/src/app/tools/page.tsx">
import { ToolsClient } from "./page.client";
⋮----
export default async function ToolsPage()
</file>

<file path="platform/frontend/src/app/global-error.tsx">
import NextError from "next/error";
import { useEffect } from "react";
export default function GlobalError({
  error,
}: {
  error: Error & { digest?: string };
})
</file>

<file path="platform/frontend/src/app/globals.css">
@theme inline {
:root {
@layer base {
⋮----
* {
body {
.font-sans {
⋮----
button, div[role="menuitem"] {
button:disabled {
</file>

<file path="platform/frontend/src/app/page.tsx">
import { redirect } from "next/navigation";
export default function Home()
</file>

<file path="platform/frontend/src/app/themes.css">
.theme-modern-minimal {
.dark.theme-modern-minimal {
.theme-graphite {
.dark.theme-graphite {
.theme-clean-slate {
.dark.theme-clean-slate {
.theme-mono {
.dark.theme-mono {
.theme-elegant-luxury {
.dark.theme-elegant-luxury {
.theme-claymorphism {
.dark.theme-claymorphism {
.theme-t3-chat {
.dark.theme-t3-chat {
.theme-twitter {
.dark.theme-twitter {
.theme-bubblegum {
.dark.theme-bubblegum {
.theme-tangerine {
.dark.theme-tangerine {
.theme-quantum-rose {
.dark.theme-quantum-rose {
.theme-candyland {
.dark.theme-candyland {
.theme-pastel-dreams {
.dark.theme-pastel-dreams {
.theme-retro-arcade {
.dark.theme-retro-arcade {
.theme-caffeine {
.dark.theme-caffeine {
.theme-amber-minimal {
.dark.theme-amber-minimal {
.theme-cosmic-night {
.dark.theme-cosmic-night {
.theme-doom-64 {
.dark.theme-doom-64 {
.theme-catppuccin {
.dark.theme-catppuccin {
.theme-perpetuity {
.dark.theme-perpetuity {
.theme-midnight-bloom {
.dark.theme-midnight-bloom {
.theme-starry-night {
.dark.theme-starry-night {
.theme-cyberpunk {
.dark.theme-cyberpunk {
.theme-mocha-mousse {
.dark.theme-mocha-mousse {
.theme-kodama-grove {
.dark.theme-kodama-grove {
.theme-nature {
.dark.theme-nature {
.theme-ocean-breeze {
.dark.theme-ocean-breeze {
.theme-sunset-horizon {
.dark.theme-sunset-horizon {
.theme-solar-dusk {
.dark.theme-solar-dusk {
.theme-bold-tech {
.dark.theme-bold-tech {
.theme-neo-brutalism {
.dark.theme-neo-brutalism {
.theme-supabase {
.dark.theme-supabase {
.theme-vercel {
.dark.theme-vercel {
.theme-claude {
.dark.theme-claude {
.theme-northern-lights {
.dark.theme-northern-lights {
.theme-vintage-paper {
.dark.theme-vintage-paper {
</file>

<file path="platform/frontend/src/components/ai-elements/actions.tsx">
import type { ComponentProps } from "react";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
export type ActionsProps = ComponentProps<"div">;
export const Actions = ({ className, children, ...props }: ActionsProps) => (
  <div className={cn("flex items-center gap-1", className)} {...props}>
    {children}
  </div>
);
⋮----
<div className=
⋮----
export type ActionProps = ComponentProps<typeof Button> & {
  tooltip?: string;
  label?: string;
};
export const Action = ({
  tooltip,
  children,
  label,
  className,
  variant = "ghost",
  size = "sm",
  ...props
}: ActionProps) =>
⋮----
className=
</file>

<file path="platform/frontend/src/components/ai-elements/code-block.tsx">
import { CheckIcon, CopyIcon } from "lucide-react";
import type { ComponentProps, HTMLAttributes, ReactNode } from "react";
import { createContext, useContext, useState } from "react";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import {
  oneDark,
  oneLight,
} from "react-syntax-highlighter/dist/esm/styles/prism";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
type CodeBlockContextType = {
  code: string;
};
⋮----
export type CodeBlockProps = HTMLAttributes<HTMLDivElement> & {
  code: string;
  language: string;
  showLineNumbers?: boolean;
  children?: ReactNode;
};
⋮----
className=
⋮----
const copyToClipboard = async () =>
</file>

<file path="platform/frontend/src/components/ai-elements/conversation.tsx">
import { ArrowDownIcon } from "lucide-react";
import type { ComponentProps } from "react";
import { useCallback } from "react";
import { StickToBottom, useStickToBottomContext } from "use-stick-to-bottom";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
export type ConversationProps = ComponentProps<typeof StickToBottom>;
⋮----
<StickToBottom.Content className=
⋮----
className=
⋮----
scrollToBottom();
</file>

<file path="platform/frontend/src/components/ai-elements/loader.tsx">
import type { HTMLAttributes } from "react";
import { cn } from "@/lib/utils";
type LoaderIconProps = {
  size?: number;
};
const LoaderIcon = ({ size = 16 }: LoaderIconProps) => (
  <svg
    height={size}
    strokeLinejoin="round"
    style={{ color: "currentcolor" }}
    viewBox="0 0 16 16"
    width={size}
  >
    <title>Loader</title>
    <g clipPath="url(#clip0_2393_1490)">
      <path d="M8 0V4" stroke="currentColor" strokeWidth="1.5" />
      <path
        d="M8 16V12"
        opacity="0.5"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M3.29773 1.52783L5.64887 4.7639"
        opacity="0.9"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M12.7023 1.52783L10.3511 4.7639"
        opacity="0.1"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M12.7023 14.472L10.3511 11.236"
        opacity="0.4"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M3.29773 14.472L5.64887 11.236"
        opacity="0.6"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M15.6085 5.52783L11.8043 6.7639"
        opacity="0.2"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M0.391602 10.472L4.19583 9.23598"
        opacity="0.7"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M15.6085 10.4722L11.8043 9.2361"
        opacity="0.3"
        stroke="currentColor"
        strokeWidth="1.5"
      />
      <path
        d="M0.391602 5.52783L4.19583 6.7639"
        opacity="0.8"
        stroke="currentColor"
        strokeWidth="1.5"
      />
    </g>
    <defs>
      <clipPath id="clip0_2393_1490">
        <rect fill="white" height="16" width="16" />
      </clipPath>
    </defs>
  </svg>
);
export type LoaderProps = HTMLAttributes<HTMLDivElement> & {
  size?: number;
};
export const Loader = ({ className, size = 16, ...props }: LoaderProps) => (
  <div
    className={cn(
      "inline-flex animate-spin items-center justify-center",
      className,
    )}
    {...props}
  >
    <LoaderIcon size={size} />
  </div>
);
⋮----
className=
</file>

<file path="platform/frontend/src/components/ai-elements/message.tsx">
import type { UIMessage } from "ai";
import { cva, type VariantProps } from "class-variance-authority";
import type { ComponentProps, HTMLAttributes } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { cn } from "@/lib/utils";
export type MessageProps = HTMLAttributes<HTMLDivElement> & {
  from: UIMessage["role"];
};
⋮----
className=
</file>

<file path="platform/frontend/src/components/ai-elements/prompt-input.tsx">
import type { ChatStatus, FileUIPart } from "ai";
import {
  ImageIcon,
  Loader2Icon,
  PaperclipIcon,
  PlusIcon,
  SendIcon,
  SquareIcon,
  XIcon,
} from "lucide-react";
import { nanoid } from "nanoid";
import {
  type ChangeEventHandler,
  Children,
  type ClipboardEventHandler,
  type ComponentProps,
  createContext,
  type FormEvent,
  type FormEventHandler,
  Fragment,
  type HTMLAttributes,
  type KeyboardEventHandler,
  type RefObject,
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
type AttachmentsContext = {
  files: (FileUIPart & { id: string })[];
  add: (files: File[] | FileList) => void;
  remove: (id: string) => void;
  clear: () => void;
  openFileDialog: () => void;
  fileInputRef: RefObject<HTMLInputElement | null>;
  textareaKey: number;
};
⋮----
export const usePromptInputAttachments = () =>
export type PromptInputAttachmentProps = HTMLAttributes<HTMLDivElement> & {
  data: FileUIPart & { id: string };
  className?: string;
};
⋮----
className=
⋮----
export const PromptInputActionAddAttachments = ({
  label = "Add photos or files",
  ...props
}: PromptInputActionAddAttachmentsProps) =>
⋮----
// Simple check: if accept includes "image
</file>

<file path="platform/frontend/src/components/ai-elements/reasoning.tsx">
import { useControllableState } from "@radix-ui/react-use-controllable-state";
import { BrainIcon, ChevronDownIcon } from "lucide-react";
import type { ComponentProps } from "react";
import { createContext, memo, useContext, useEffect, useState } from "react";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
import { Response } from "./response";
type ReasoningContextValue = {
  isStreaming: boolean;
  isOpen: boolean;
  setIsOpen: (open: boolean) => void;
  duration: number;
};
⋮----
const useReasoning = () =>
export type ReasoningProps = ComponentProps<typeof Collapsible> & {
  isStreaming?: boolean;
  open?: boolean;
  defaultOpen?: boolean;
  onOpenChange?: (open: boolean) => void;
  duration?: number;
};
⋮----
const handleOpenChange = (newOpen: boolean) =>
⋮----
export type ReasoningTriggerProps = ComponentProps<typeof CollapsibleTrigger>;
const getThinkingMessage = (isStreaming: boolean, duration?: number) =>
⋮----
className=
⋮----
</file>

<file path="platform/frontend/src/components/ai-elements/response.tsx">
import { type ComponentProps, memo } from "react";
import { Streamdown } from "streamdown";
import { cn } from "@/lib/utils";
type ResponseProps = ComponentProps<typeof Streamdown>;
⋮----
className=
</file>

<file path="platform/frontend/src/components/ai-elements/sources.tsx">
import { BookIcon, ChevronDownIcon } from "lucide-react";
import type { ComponentProps } from "react";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
export type SourcesProps = ComponentProps<"div">;
export const Sources = ({ className, ...props }: SourcesProps) => (
  <Collapsible
    className={cn("not-prose mb-4 text-primary text-xs", className)}
    {...props}
  />
);
⋮----
className=
⋮----
export type SourcesTriggerProps = ComponentProps<typeof CollapsibleTrigger> & {
  count: number;
};
</file>

<file path="platform/frontend/src/components/chat/chat-error.tsx">
import { AlertCircle } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
interface ChatErrorProps {
  error: Error;
}
export function ChatError(
</file>

<file path="platform/frontend/src/components/chat/chat-messages.tsx">
import type { UIMessage } from "@ai-sdk/react";
import type { ChatStatus, DynamicToolUIPart, ToolUIPart } from "ai";
import Image from "next/image";
import { Fragment, useEffect, useRef, useState } from "react";
import {
  Conversation,
  ConversationContent,
  ConversationScrollButton,
} from "@/components/ai-elements/conversation";
import { Message, MessageContent } from "@/components/ai-elements/message";
import {
  Reasoning,
  ReasoningContent,
  ReasoningTrigger,
} from "@/components/ai-elements/reasoning";
import { Response } from "@/components/ai-elements/response";
import {
  Tool,
  ToolContent,
  ToolHeader,
  ToolInput,
  ToolOutput,
} from "@/components/ai-elements/tool";
interface ChatMessagesProps {
  messages: UIMessage[];
  hideToolCalls?: boolean;
  status: ChatStatus;
}
function isToolPart(part: any): part is
⋮----
// Look ahead for tool result (same tool call ID)
// biome-ignore lint/suspicious/noExplicitAny: Tool result structure varies by tool type
⋮----
state=
</file>

<file path="platform/frontend/src/components/teams/team-members-dialog.tsx">
import { archestraApiSdk } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Plus, Trash2 } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useActiveOrganization } from "@/lib/organization.query";
interface Team {
  id: string;
  name: string;
  description: string | null;
}
interface TeamMembersDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  team: Team;
}
⋮----
const handleAddMember = () =>
⋮----
onClick=
</file>

<file path="platform/frontend/src/components/ui/accordion.tsx">
import { ChevronDownIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>)
function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>)
function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>)
</file>

<file path="platform/frontend/src/components/ui/alert-dialog.tsx">
import { buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";
⋮----
function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>)
function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>)
⋮----
className=
⋮----
function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>)
function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>)
function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>)
</file>

<file path="platform/frontend/src/components/ui/alert.tsx">
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>)
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/avatar.tsx">
import { cn } from "@/lib/utils";
function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>)
⋮----
className=
⋮----
function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>)
</file>

<file path="platform/frontend/src/components/ui/badge.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
VariantProps<typeof badgeVariants> &
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/calendar.tsx">
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react";
⋮----
import {
  type DayButton,
  DayPicker,
  getDefaultClassNames,
} from "react-day-picker";
import { Button, buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/card.tsx">
import { cn } from "@/lib/utils";
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/checkbox.tsx">
import { CheckIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>)
</file>

<file path="platform/frontend/src/components/ui/collapsible.tsx">
function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>)
function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>)
</file>

<file path="platform/frontend/src/components/ui/data-table-pagination.tsx">
import type { Table } from "@tanstack/react-table";
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
interface DataTablePaginationProps<TData> {
  table: Table<TData>;
  totalRows?: number;
}
⋮----
const handlePageSizeChange = (value: string) =>
const handleFirstPage = () =>
const handlePreviousPage = () =>
const handleNextPage = () =>
const handleLastPage = () =>
⋮----
</file>

<file path="platform/frontend/src/components/ui/data-table.tsx">
import {
  type ColumnDef,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  type RowSelectionState,
  type SortingState,
  useReactTable,
  type VisibilityState,
} from "@tanstack/react-table";
import { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { DataTablePagination } from "./data-table-pagination";
interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
  pagination?: {
    pageIndex: number;
    pageSize: number;
    total: number;
  };
  onPaginationChange?: (pagination: {
    pageIndex: number;
    pageSize: number;
  }) => void;
  manualPagination?: boolean;
  onSortingChange?: (sorting: SortingState) => void;
  manualSorting?: boolean;
  sorting?: SortingState;
  onRowClick?: (row: TData, event: React.MouseEvent) => void;
  rowSelection?: RowSelectionState;
  onRowSelectionChange?: (rowSelection: RowSelectionState) => void;
}
⋮----
</file>

<file path="platform/frontend/src/components/ui/dialog.tsx">
import { XIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
className=
⋮----
function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>)
</file>

<file path="platform/frontend/src/components/ui/dropdown-menu.tsx">
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>)
function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>)
function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>)
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>)
function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
})
⋮----
className=
⋮----
function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>)
function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>)
function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
})
⋮----
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
})
</file>

<file path="platform/frontend/src/components/ui/form.tsx">
import { Slot } from "@radix-ui/react-slot";
⋮----
import {
  Controller,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
  FormProvider,
  useFormContext,
  useFormState,
} from "react-hook-form";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
⋮----
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};
⋮----
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) =>
const useFormField = () =>
type FormItemContextValue = {
  id: string;
};
⋮----
className=
⋮----
function FormControl(
function FormDescription(
</file>

<file path="platform/frontend/src/components/ui/input.tsx">
import { cn } from "@/lib/utils";
function Input(
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/label.tsx">
import { cn } from "@/lib/utils";
function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>)
</file>

<file path="platform/frontend/src/components/ui/popover.tsx">
import { cn } from "@/lib/utils";
⋮----
function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>)
</file>

<file path="platform/frontend/src/components/ui/progress.tsx">
import { cn } from "@/lib/utils";
</file>

<file path="platform/frontend/src/components/ui/radio-group.tsx">
import { CircleIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>)
function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>)
</file>

<file path="platform/frontend/src/components/ui/scroll-area.tsx">
import { cn } from "@/lib/utils";
function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>)
function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>)
</file>

<file path="platform/frontend/src/components/ui/searchable-select.tsx">
import { Check, ChevronDown, Search } from "lucide-react";
⋮----
import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
interface SearchableSelectProps {
  value: string;
  onValueChange: (value: string) => void;
  placeholder?: string;
  items: Array<{ value: string; label: string }>;
  className?: string;
  disabled?: boolean;
}
⋮----
onValueChange(item.value);
setOpen(false);
setSearchQuery("");
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/select.tsx">
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default";
})
⋮----
className=
⋮----
function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>)
function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>)
function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>)
function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>)
function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>)
</file>

<file path="platform/frontend/src/components/ui/separator.tsx">
import { cn } from "@/lib/utils";
function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>)
</file>

<file path="platform/frontend/src/components/ui/sheet.tsx">
import { XIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>)
⋮----
className=
⋮----
function SheetHeader(
</file>

<file path="platform/frontend/src/components/ui/sidebar.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { PanelLeftIcon } from "lucide-react";
⋮----
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useIsMobile } from "@/lib/use-mobile.hook";
import { cn } from "@/lib/utils";
⋮----
type SidebarContextProps = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};
⋮----
function useSidebar()
⋮----
const handleKeyDown = (event: KeyboardEvent) =>
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/sonner.tsx">
import { useTheme } from "next-themes";
import { Toaster as Sonner, type ToasterProps } from "sonner";
</file>

<file path="platform/frontend/src/components/ui/switch.tsx">
import { cn } from "@/lib/utils";
function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>)
</file>

<file path="platform/frontend/src/components/ui/table.tsx">
import { cn } from "@/lib/utils";
⋮----
className=
⋮----
function TableBody(
</file>

<file path="platform/frontend/src/components/ui/tabs.tsx">
import { cn } from "@/lib/utils";
function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>)
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/textarea.tsx">
import { cn } from "@/lib/utils";
⋮----
className=
</file>

<file path="platform/frontend/src/components/button-with-tooltip.tsx">
import type { ComponentProps } from "react";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
type ButtonWithTooltipProps = ComponentProps<typeof Button> & {
  disabledText?: string;
};
export function ButtonWithTooltip({
  disabledText,
  ...props
}: ButtonWithTooltipProps)
</file>

<file path="platform/frontend/src/components/chatbot-demo.tsx">
import type { ChatStatus, UIMessage } from "ai";
import {
  Check,
  CopyIcon,
  GlobeIcon,
  RefreshCcwIcon,
  ShieldCheck,
  TriangleAlert,
} from "lucide-react";
import { Fragment, useState } from "react";
import { Action, Actions } from "@/components/ai-elements/actions";
import {
  Conversation,
  ConversationContent,
  ConversationScrollButton,
} from "@/components/ai-elements/conversation";
import { Loader } from "@/components/ai-elements/loader";
import { Message, MessageContent } from "@/components/ai-elements/message";
import {
  PromptInput,
  PromptInputActionAddAttachments,
  PromptInputActionMenu,
  PromptInputActionMenuContent,
  PromptInputActionMenuTrigger,
  PromptInputAttachment,
  PromptInputAttachments,
  PromptInputBody,
  PromptInputButton,
  type PromptInputMessage,
  PromptInputModelSelect,
  PromptInputModelSelectContent,
  PromptInputModelSelectItem,
  PromptInputModelSelectTrigger,
  PromptInputModelSelectValue,
  PromptInputSubmit,
  PromptInputTextarea,
  PromptInputToolbar,
  PromptInputTools,
} from "@/components/ai-elements/prompt-input";
import {
  Reasoning,
  ReasoningContent,
  ReasoningTrigger,
} from "@/components/ai-elements/reasoning";
import { Response } from "@/components/ai-elements/response";
import {
  Source,
  Sources,
  SourcesContent,
  SourcesTrigger,
} from "@/components/ai-elements/sources";
import {
  Tool,
  ToolContent,
  ToolHeader,
  ToolInput,
  ToolOutput,
} from "@/components/ai-elements/tool";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import Divider from "./divider";
⋮----
// const { messages, reload, isEnded } = useMockedMessages({ isMitigated });
// We are mocking those parts
// const { messages, sendMessage, status } = useChat({
//   transport: new DefaultChatTransport({
//     api: "/api/chat-demo",
const handleSubmit = (message: PromptInputMessage) =>
⋮----
className=
⋮----
const getIcon = () =>
⋮----
// Look ahead for tool result and dual LLM analysis
⋮----
// Check if next part is a tool result (same tool call ID)
⋮----
if (_isDualLlmPart(nextPart))
⋮----
onChange=
</file>

<file path="platform/frontend/src/components/code-text.tsx">
import { cn } from "@/lib/utils";
export function CodeText({
  children,
  className,
}: {
  children: React.ReactNode;
  className?: string;
})
⋮----
<code className=
</file>

<file path="platform/frontend/src/components/cost.tsx">
export function formatCost(value: number)
export function Cost({
  cost,
  className,
}: {
  cost: string;
  className?: string;
})
</file>

<file path="platform/frontend/src/components/debounced-input.tsx">
import { useDebounce } from "@uidotdev/usehooks";
import { useEffect, useRef, useState } from "react";
import { Input } from "./ui/input";
type DebouncedInputProps = Omit<
  React.ComponentProps<typeof Input>,
  "onChange"
> & {
  initialValue: string;
  onChange: (value: string) => void;
};
export function DebouncedInput({
  initialValue,
  onChange,
  ...props
}: DebouncedInputProps)
⋮----
onChange=
</file>

<file path="platform/frontend/src/components/divider.tsx">
import { cn } from "@/lib/utils";
function Divider(
⋮----
className=
</file>

<file path="platform/frontend/src/components/editor.tsx">
import { type EditorProps, Editor as MonacoEditor } from "@monaco-editor/react";
import { useTheme } from "next-themes";
interface CustomEditorProps extends Omit<EditorProps, "theme"> {
  theme?: "light" | "vs-dark" | "hc-black";
}
export function Editor(
</file>

<file path="platform/frontend/src/components/error-fallback.tsx">
import type { ErrorExtended } from "@shared";
import { AlertCircle } from "lucide-react";
import { Button } from "./ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "./ui/card";
</file>

<file path="platform/frontend/src/components/loading.tsx">
import type { ComponentProps } from "react";
import { cn } from "@/lib/utils";
import { Skeleton } from "./ui/skeleton";
⋮----
className=
</file>

<file path="platform/frontend/src/components/mermaid-diagram.tsx">
import mermaid from "mermaid";
import { useTheme } from "next-themes";
import { useEffect, useRef } from "react";
interface MermaidDiagramProps {
  chart: string;
  id?: string;
}
export function MermaidDiagram({
  chart,
  id = "mermaid-diagram",
}: MermaidDiagramProps)
⋮----
const renderDiagram = async () =>
⋮----
// Generate a unique ID to avoid conflicts
</file>

<file path="platform/frontend/src/components/mermaid-wrapper.tsx">
import dynamic from "next/dynamic";
</file>

<file path="platform/frontend/src/components/oauth-confirmation-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Building2, Info, ShieldCheck, User, X } from "lucide-react";
import { useState } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useMcpServers } from "@/lib/mcp-server.query";
import { useTeams } from "@/lib/team.query";
type McpServer = archestraApiTypes.GetMcpServersResponses["200"][number];
interface OAuthConfirmationDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  serverName: string;
  onConfirm: (teams: string[]) => void;
  onCancel: () => void;
  isTeamMode?: boolean;
  catalogId?: string;
  installedServers?: McpServer[];
}
⋮----
// Get teams that already have access to this catalog
⋮----
const handleAddTeam = (teamId: string) =>
const handleRemoveTeam = (teamId: string) =>
⋮----
const getTeamById = (teamId: string) =>
const handleConfirm = () =>
const handleCancel = () =>
⋮----
<Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={() => handleRemoveTeam(teamId)}
                            className="h-auto p-0.5 ml-1 hover:bg-destructive/20"
                          >
                            <X className="h-3 w-3" />
                          </Button>
                        </Badge>
                      );
</file>

<file path="platform/frontend/src/components/onboarding-dialog-wrapper.tsx">
import { OnboardingDialog } from "@/components/onboarding-dialog";
import { useOrganization } from "@/lib/organization.query";
export function OnboardingDialogWrapper()
</file>

<file path="platform/frontend/src/components/org-theme-loader.tsx">
import { useOrgTheme } from "@/lib/theme.hook";
export function OrgThemeLoader()
</file>

<file path="platform/frontend/src/components/truncated-text.tsx">
import { useState } from "react";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
⋮----
const handleOpenChange = (open: boolean) =>
⋮----
className=
</file>

<file path="platform/frontend/src/components/version.tsx">
import { usePathname } from "next/navigation";
import { useHealth } from "@/lib/health.query";
export function Version()
</file>

<file path="platform/frontend/src/config/themes.ts">
import type { OrganizationCustomFont, OrganizationTheme } from "@shared";
import {
  DEFAULT_THEME_ID,
  getThemeById as getThemeByIdShared,
  getThemeCategories as getThemeCategoriesShared,
  getThemeMetadata,
  getThemesByCategory as getThemesByCategoryShared,
  type ThemeMetadata as ThemeMetadataShared,
} from "@shared";
export type ThemeMetadata = ThemeMetadataShared;
⋮----
export function getThemeById(id: OrganizationTheme): ThemeMetadata | undefined
export function getThemesByCategory(
  category: ThemeMetadata["category"],
): ThemeMetadata[]
export function getThemeCategories(): ReturnType<
  typeof getThemeCategoriesShared
> {
  return getThemeCategoriesShared();
⋮----
export function getFontById(id: OrganizationCustomFont)
</file>

<file path="platform/frontend/src/lib/llmProviders/anthropic.ts">
import type { archestraApiTypes } from "@shared";
import type { PartialUIMessage } from "@/components/chatbot-demo";
import type { DualLlmResult, Interaction, InteractionUtils } from "./common";
class AnthropicMessagesInteraction implements InteractionUtils
⋮----
constructor(interaction: Interaction)
isLastMessageToolCall(): boolean
getLastToolCallId(): string | null
getToolNamesUsed(): string[]
getToolNamesRefused(): string[]
getToolNamesRequested(): string[]
getToolRefusedCount(): number
getLastUserMessage(): string
getLastAssistantResponse(): string
⋮----
// Find the first text block in the response
⋮----
private mapToUiMessage(
    message:
      | archestraApiTypes.AnthropicMessagesRequest["messages"][number]
      | {
          role: "assistant";
          content: archestraApiTypes.AnthropicMessagesResponse["content"];
        },
    _dualLlmResults?: DualLlmResult[],
): PartialUIMessage
mapToUiMessages(dualLlmResults?: DualLlmResult[]): PartialUIMessage[]
</file>

<file path="platform/frontend/src/lib/llmProviders/common.ts">
import type { archestraApiTypes } from "@shared";
import type { PartialUIMessage } from "@/components/chatbot-demo";
export type Interaction =
  archestraApiTypes.GetInteractionsResponses["200"]["data"][number];
export type DualLlmResult =
  archestraApiTypes.GetDualLlmResultsByInteractionResponses["200"][number];
export interface RefusalInfo {
  toolName?: string;
  toolArguments?: string;
  reason?: string;
}
export interface InteractionUtils {
  modelName: string;
  isLastMessageToolCall(): boolean;
  getLastToolCallId(): string | null;
  getToolNamesUsed(): string[];
  getToolNamesRefused(): string[];
  getToolNamesRequested(): string[];
  getToolRefusedCount(): number;
  getLastUserMessage(): string;
  getLastAssistantResponse(): string;
  mapToUiMessages(dualLlmResults?: DualLlmResult[]): PartialUIMessage[];
}
⋮----
isLastMessageToolCall(): boolean;
getLastToolCallId(): string | null;
getToolNamesUsed(): string[];
getToolNamesRefused(): string[];
getToolNamesRequested(): string[];
getToolRefusedCount(): number;
getLastUserMessage(): string;
getLastAssistantResponse(): string;
mapToUiMessages(dualLlmResults?: DualLlmResult[]): PartialUIMessage[];
⋮----
export function parseRefusalMessage(refusal: string): RefusalInfo
</file>

<file path="platform/frontend/src/lib/llmProviders/gemini.ts">
import type { archestraApiTypes } from "@shared";
import type { PartialUIMessage } from "@/components/chatbot-demo";
import type { DualLlmResult, Interaction, InteractionUtils } from "./common";
class GeminiGenerateContentInteraction implements InteractionUtils
⋮----
constructor(interaction: Interaction)
isLastMessageToolCall(): boolean
getLastToolCallId(): string | null
getToolNamesUsed(): string[]
getToolNamesRefused(): string[]
getToolNamesRequested(): string[]
getToolRefusedCount(): number
getLastUserMessage(): string
// TODO: Implement this
getLastAssistantResponse(): string
// TODO: Implement this
private mapToUiMessage(
    _content:
      | archestraApiTypes.GeminiGenerateContentRequest["contents"][number]
      | archestraApiTypes.GeminiGenerateContentResponse["candidates"][number],
): PartialUIMessage
private mapRequestToUiMessages(
    _dualLlmResults?: DualLlmResult[],
): PartialUIMessage[]
private mapResponseToUiMessages(): PartialUIMessage[]
mapToUiMessages(dualLlmResults?: DualLlmResult[]): PartialUIMessage[]
</file>

<file path="platform/frontend/src/lib/llmProviders/openai.ts">
import type { archestraApiTypes } from "@shared";
import type { PartialUIMessage } from "@/components/chatbot-demo";
import {
  type DualLlmResult,
  type Interaction,
  type InteractionUtils,
  parseRefusalMessage,
} from "./common";
class OpenAiChatCompletionInteraction implements InteractionUtils
⋮----
constructor(interaction: Interaction)
isLastMessageToolCall(): boolean
getLastToolCallId(): string | null
getToolNamesUsed(): string[]
getToolNamesRefused(): string[]
getToolNamesRequested(): string[]
getLastUserMessage(): string
getLastAssistantResponse(): string
⋮----
/**
     * TODO: remove this as string assertion once we figure out the openapi/zod weirdness
     * (ie. there shouldn't be | unknown in the codegen'd type here..)
     */
⋮----
getToolRefusedCount(): number
private mapToUiMessage(
    message:
      | archestraApiTypes.OpenAiChatCompletionRequest["messages"][number]
      | archestraApiTypes.OpenAiChatCompletionResponse["choices"][number]["message"],
): PartialUIMessage
private mapRequestToUiMessages(
    dualLlmResults?: DualLlmResult[],
): PartialUIMessage[]
private mapResponseToUiMessages(): PartialUIMessage[]
mapToUiMessages(dualLlmResults?: DualLlmResult[]): PartialUIMessage[]
</file>

<file path="platform/frontend/src/lib/auth.hook.test.ts">
import { renderHook } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";
import { useIsAuthenticated } from "./auth.hook";
import { authClient } from "./clients/auth/auth-client";
⋮----
type Session = Awaited<ReturnType<typeof authClient.useSession>>;
</file>

<file path="platform/frontend/src/lib/auth.hook.ts">
import { authClient } from "./clients/auth/auth-client";
export function useIsAuthenticated()
</file>

<file path="platform/frontend/src/lib/auth.utils.test.ts">
import type { Permissions } from "@shared";
import { describe, expect, it, vi } from "vitest";
import { hasPermission } from "./auth.utils";
import { authClient } from "./clients/auth/auth-client";
⋮----
type HasPermissionResponse = Awaited<
  ReturnType<typeof authClient.organization.hasPermission>
>;
</file>

<file path="platform/frontend/src/lib/chat-settings.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
⋮----
export function useChatSettings(params?: {
  initialData?: archestraApiTypes.GetChatSettingsResponses["200"];
})
export function useChatSettingsOptional()
export function useUpdateChatSettings()
</file>

<file path="platform/frontend/src/lib/config.test.ts">
import { getDisplayProxyUrl } from "./config";
</file>

<file path="platform/frontend/src/lib/dialog.hook.ts">
import { useState } from "react";
export function useDialogs<T extends string>()
⋮----
const isDialogOpened = (dialogKey: T) =>
const openDialog = (dialogKey: T) =>
const closeDialog = (dialogKey: T) =>
</file>

<file path="platform/frontend/src/lib/dual-llm-result.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useQuery } from "@tanstack/react-query";
⋮----
export function useDualLlmResultByToolCallId(toolCallId: string | null)
export function useDualLlmResultsByInteraction({
  interactionId,
  initialData,
}: {
  interactionId: string;
  initialData?: archestraApiTypes.GetDualLlmResultsByInteractionResponses["200"];
})
</file>

<file path="platform/frontend/src/lib/features.hook.ts">
import type { archestraApiTypes } from "@shared";
import { useFeatures } from "./features.query";
export function useFeatureFlag(
  flag: keyof archestraApiTypes.GetFeaturesResponses["200"],
): boolean
</file>

<file path="platform/frontend/src/lib/features.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useQuery } from "@tanstack/react-query";
⋮----
export function useFeatures(params?: {
  initialData?: archestraApiTypes.GetFeaturesResponses["200"];
})
</file>

<file path="platform/frontend/src/lib/github.query.ts">
import { useQuery } from "@tanstack/react-query";
export function useGithubStars()
</file>

<file path="platform/frontend/src/lib/health.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useQuery } from "@tanstack/react-query";
⋮----
export function useHealth(params?: {
  initialData?: archestraApiTypes.GetHealthResponses["200"];
})
</file>

<file path="platform/frontend/src/lib/interaction.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useSuspenseQuery } from "@tanstack/react-query";
import { DEFAULT_TABLE_LIMIT } from "./utils";
⋮----
export function useInteractions({
  agentId,
  limit = DEFAULT_TABLE_LIMIT,
  offset = 0,
  sortBy,
  sortDirection = "desc",
  initialData,
}: {
  agentId?: string;
  limit?: number;
  offset?: number;
  sortBy?: NonNullable<
    archestraApiTypes.GetInteractionsData["query"]
  >["sortBy"];
  sortDirection?: "asc" | "desc";
  initialData?: archestraApiTypes.GetInteractionsResponses["200"];
} =
export function useInteraction({
  interactionId,
  initialData,
  refetchInterval = 3_000,
}: {
  interactionId: string;
  initialData?: archestraApiTypes.GetInteractionResponses["200"];
  refetchInterval?: number | null;
})
</file>

<file path="platform/frontend/src/lib/internal-mcp-catalog.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
import { toast } from "sonner";
⋮----
export function useInternalMcpCatalog(params?: {
  initialData?: archestraApiTypes.GetInternalMcpCatalogResponses["200"];
})
export function useCreateInternalMcpCatalogItem()
export function useUpdateInternalMcpCatalogItem()
export function useDeleteInternalMcpCatalogItem()
</file>

<file path="platform/frontend/src/lib/lifecycle.hook.ts">
import { useEffect, useRef } from "react";
export function useOnUnmount(callback: () => void)
</file>

<file path="platform/frontend/src/lib/mcp-server-installation-request.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
⋮----
export type McpServerInstallationRequest =
  archestraApiTypes.GetMcpServerInstallationRequestResponses["200"];
export function useMcpServerInstallationRequests(params?: {
  status?: "pending" | "approved" | "declined";
})
export function useMcpServerInstallationRequest(id: string)
export function useCreateMcpServerInstallationRequest()
export function useApproveMcpServerInstallationRequest()
export function useDeclineMcpServerInstallationRequest()
export function useAddMcpServerInstallationRequestNote()
export function useDeleteMcpServerInstallationRequest()
</file>

<file path="platform/frontend/src/lib/mcp-tool-call.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useSuspenseQuery } from "@tanstack/react-query";
import { DEFAULT_TABLE_LIMIT } from "./utils";
⋮----
export function useMcpToolCalls({
  agentId,
  limit = DEFAULT_TABLE_LIMIT,
  offset = 0,
  sortBy,
  sortDirection = "desc",
  initialData,
}: {
  agentId?: string;
  limit?: number;
  offset?: number;
  sortBy?: NonNullable<
    archestraApiTypes.GetMcpToolCallsData["query"]
  >["sortBy"];
  sortDirection?: "asc" | "desc";
  initialData?: archestraApiTypes.GetMcpToolCallsResponses["200"];
} =
export function useMcpToolCall({
  mcpToolCallId,
  initialData,
}: {
  mcpToolCallId: string;
  initialData?: archestraApiTypes.GetMcpToolCallResponses["200"];
})
</file>

<file path="platform/frontend/src/lib/organization.query.ts">
import {
  type AnyRoleName,
  archestraApiSdk,
  type archestraApiTypes,
} from "@shared";
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
import type { Invitation } from "better-auth/plugins/organization";
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import { authClient } from "@/lib/clients/auth/auth-client";
⋮----
export function useInvitation(invitationId: string)
export function useActiveOrganization()
export function useActiveMemberRole(organizationId?: string)
export function useAcceptInvitation()
export function useInvitationsList(organizationId: string | undefined)
export function useCancelInvitation()
export function useCreateInvitation(organizationId: string | undefined)
export function useOrganization(enabled = true)
export function useOrganizationOnboardingStatus(enabled: boolean)
export function useUpdateOrganization(
  onSuccessMessage: string,
  onErrorMessage: string,
)
</file>

<file path="platform/frontend/src/lib/server-utils.ts">
import { cookies } from "next/headers";
export async function getServerApiHeaders()
</file>

<file path="platform/frontend/src/lib/team.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useQuery } from "@tanstack/react-query";
⋮----
export function useTeams(params?: {
  initialData?: archestraApiTypes.GetTeamsResponses["200"];
})
</file>

<file path="platform/frontend/src/lib/theme.hook.ts">
import {
  DEFAULT_THEME_ID,
  type OrganizationCustomFont,
  type OrganizationTheme,
} from "@shared";
import { usePathname } from "next/navigation";
import { useCallback, useEffect, useState } from "react";
import { fontFamilyMap } from "@/config/themes";
import { useOrganization, useUpdateOrganization } from "./organization.query";
⋮----
export function useOrgTheme()
const applyThemeOnUI = (themeId: OrganizationTheme) =>
const applyFontOnUI = (fontId: OrganizationCustomFont) =>
const applyThemeInLocalStorage = (themeId: OrganizationTheme) =>
const applyFontInLocalStorage = (fontId: OrganizationCustomFont) =>
</file>

<file path="platform/frontend/src/lib/token-price.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
⋮----
export function useTokenPrices()
export function useTokenPrice(id: string)
export function useCreateTokenPrice()
export function useUpdateTokenPrice()
export function useDeleteTokenPrice()
</file>

<file path="platform/frontend/src/lib/use-mobile.hook.ts">
export function useIsMobile()
⋮----
const onChange = () =>
</file>

<file path="platform/frontend/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { format } from "date-fns";
import { twMerge } from "tailwind-merge";
⋮----
export function cn(...inputs: ClassValue[])
export function formatDate({
  date,
  dateFormat = "MM/dd/yyyy HH:mm:ss",
}: {
  date: string;
  dateFormat?: string;
})
</file>

<file path="platform/frontend/src/consts.ts">

</file>

<file path="platform/frontend/src/instrumentation-client.ts">
import config from "@/lib/config";
</file>

<file path="platform/frontend/src/instrumentation.ts">
export async function register()
</file>

<file path="platform/frontend/postcss.config.mjs">

</file>

<file path="platform/helm/archestra/templates/_helpers.tpl">
{{/*
Expand the name of the chart.
*/}}
{{- define "archestra-platform.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
If release name contains chart name it will be used as a full name.
*/}}
{{- define "archestra-platform.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "archestra-platform.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "archestra-platform.labels" -}}
helm.sh/chart: {{ include "archestra-platform.chart" . }}
{{ include "archestra-platform.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "archestra-platform.selectorLabels" -}}
app.kubernetes.io/name: {{ include "archestra-platform.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Environment variables for the Archestra Platform container
*/}}
{{- define "archestra-platform.env" -}}
- name: ARCHESTRA_DATABASE_URL
  value: {{ if .Values.postgresql.external_database_url }}{{ .Values.postgresql.external_database_url }}{{ else }}postgresql://{{ .Values.postgresql.auth.username }}:{{ .Values.postgresql.auth.password }}@{{ include "archestra-platform.fullname" . }}-postgresql:5432/{{ .Values.postgresql.auth.database }}{{ end }}
{{/*
Assigns value from autogenerated auth-secret to ARCHESTRA_AUTH_SECRET by default.
If ARCHESTRA_AUTH_SECRET env variable is explicitly set, it will override the autogenerated default.
*/}}
{{- if not (hasKey .Values.archestra.env "ARCHESTRA_AUTH_SECRET") }}
- name: ARCHESTRA_AUTH_SECRET
  valueFrom:
    secretKeyRef:
      name: {{ include "archestra-platform.fullname" . }}-auth
      key: auth-secret
{{- end }}
- name: ARCHESTRA_ORCHESTRATOR_K8S_NAMESPACE
  value: {{ default .Release.Namespace .Values.archestra.orchestrator.kubernetes.namespace | quote }}
{{- if .Values.archestra.orchestrator.baseImage }}
- name: ARCHESTRA_ORCHESTRATOR_MCP_SERVER_BASE_IMAGE
  value: {{ .Values.archestra.orchestrator.baseImage | quote }}
{{- end }}
{{- if and .Values.archestra.orchestrator.kubernetes.kubeconfig.enabled .Values.archestra.orchestrator.kubernetes.kubeconfig.secretName }}
- name: ARCHESTRA_ORCHESTRATOR_KUBECONFIG
  value: {{ printf "%s/config" .Values.archestra.orchestrator.kubernetes.kubeconfig.mountPath | quote }}
{{- end }}
- name: ARCHESTRA_ORCHESTRATOR_LOAD_KUBECONFIG_FROM_CURRENT_CLUSTER
  value: {{ .Values.archestra.orchestrator.kubernetes.loadKubeconfigFromCurrentCluster | quote }}
{{- range $key, $value := .Values.archestra.env }}
- name: {{ $key }}
  value: {{ $value | quote }}
{{- end }}
{{- range .Values.archestra.envFromSecrets }}
- name: {{ .name }}
  valueFrom:
    secretKeyRef:
      name: {{ .secretName }}
      key: {{ .secretKey }}
{{- end }}
{{- end }}

{{/*
PostgreSQL host for database connectivity checks
*/}}
{{- define "archestra-platform.postgresql.host" -}}
{{- if .Values.postgresql.external_database_url -}}
{{- regexReplaceAll "^postgresql://[^@]+@([^:/]+).*$" .Values.postgresql.external_database_url "${1}" -}}
{{- else -}}
{{- include "archestra-platform.fullname" . }}-postgresql
{{- end -}}
{{- end }}

{{/*
PostgreSQL port for database connectivity checks
*/}}
{{- define "archestra-platform.postgresql.port" -}}
{{- if .Values.postgresql.external_database_url -}}
{{- regexReplaceAll "^postgresql://[^@]+@[^:]+:([0-9]+).*$" .Values.postgresql.external_database_url "${1}" -}}
{{- else -}}
5432
{{- end -}}
{{- end }}

{{/*
ServiceAccount name for the Archestra Platform
*/}}
{{- define "archestra-platform.serviceAccountName" -}}
{{- if .Values.archestra.orchestrator.kubernetes.serviceAccount.create }}
{{- default (include "archestra-platform.fullname" .) .Values.archestra.orchestrator.kubernetes.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.archestra.orchestrator.kubernetes.serviceAccount.name }}
{{- end }}
{{- end }}
</file>

<file path="platform/helm/archestra/.helmignore">
# Patterns to ignore when building packages.
# This supports shell glob matching, relative path matching, and
# negation (prefixed with !). Only one pattern per line.

.DS_Store

# Common VCS dirs
.git/
.gitignore
.bzr/
.bzrignore
.hg/
.hgignore
.svn/

# Common backup files
*.swp
*.bak
*.tmp
*.orig
*~

# Various IDEs
.project
.idea/
*.tmproj
.vscode/

tests
</file>

<file path="platform/helm/archestra/Chart.lock">
dependencies:
- name: postgresql
  repository: https://charts.bitnami.com/bitnami
  version: 18.0.8
digest: sha256:03e8f85e37fd87c2bd6cd98cf1ebb82091418545bbae4e508137f95992983d1e
generated: "2025-10-07T09:23:21.298408-04:00"
</file>

<file path="platform/mcp_server_docker_image/Dockerfile">
# Multi-stage build for minimal final image
FROM python:3.12-alpine AS python-builder

# Install Python build dependencies
RUN apk add --no-cache \
   gcc \
   musl-dev \
   libffi-dev \
   openssl-dev \
   python3-dev

# Copy uv from the official image
COPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv
RUN chmod +x /usr/local/bin/uv

# Create virtual environment and install Python MCP dependencies
RUN uv venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"
RUN uv pip install --no-cache-dir \
   mcp[cli]>=1.2.0 \
   httpx \
   fastapi \
   uvicorn \
   requests>=2.31.0 \
   python-dotenv>=1.0.0

# Node.js stage
FROM node:20-alpine AS node-builder

# Install Node.js MCP dependencies globally
RUN npm install -g \
   @modelcontextprotocol/sdk \
   typescript@5 \
   zod \
   express

# Final stage - minimal runtime image with Python 3.12
FROM python:3.12-alpine

# Install runtime dependencies only
RUN apk add --no-cache \
   nodejs \
   npm \
   libstdc++ \
   libgcc \
   openssl \
   ca-certificates \
   # Required for some Python packages
   libffi \
   # Process management
   tini \
   # Git for installing packages from git repositories
   git \
   # Network and SSL/TLS support
   curl \
   wget \
   # DNS resolution
   bind-tools \
   # Additional SSL/TLS libraries
   openssl-dev \
   # Go runtime for Go-based MCP servers
   go

# Copy Python environment from builder
COPY --from=python-builder /opt/venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"
ENV PYTHONUNBUFFERED=1

# Set up Go environment
ENV GOPATH=/home/mcp/go
ENV PATH=$GOPATH/bin:/usr/local/go/bin:$PATH

# Update CA certificates and configure git to use system certificates
RUN update-ca-certificates && \
    git config --global http.sslCAInfo /etc/ssl/certs/ca-certificates.crt

# Install uv using the official installation method
COPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv
COPY --from=ghcr.io/astral-sh/uv:latest /uvx /usr/local/bin/uvx

# Make sure uv and uvx are executable
RUN chmod +x /usr/local/bin/uv /usr/local/bin/uvx

# Copy Node.js global modules from builder
COPY --from=node-builder /usr/local/lib/node_modules /usr/local/lib/node_modules
COPY --from=node-builder /usr/local/bin /usr/local/bin

# Create non-root user for running MCP servers
RUN addgroup -g 1000 mcp && \
   adduser -u 1000 -G mcp -D -h /home/mcp mcp

# Set up working directory
WORKDIR /home/mcp

# Configure git for the mcp user before switching
RUN git config --system http.sslVerify true && \
    git config --system http.postBuffer 524288000 && \
    git config --system http.timeout 180 && \
    git config --system core.compression 0

USER mcp

# Common environment variables for MCP servers
ENV MCP_ENV=production
ENV NODE_ENV=production

# Health check for container monitoring
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
   CMD node -e "process.exit(0)" && python3 -c "exit(0)" && go version

# Use tini for proper signal handling
ENTRYPOINT ["/sbin/tini", "--"]

# Default command (override when running specific MCP server)
CMD ["sh", "-c", "echo 'MCP base container ready. Override CMD to run your MCP server.'"]
</file>

<file path="platform/shared/themes/generate-theme-css.ts">
import { fileURLToPath } from "node:url";
import { THEME_IDS } from "./theme-config";
import type { ThemeId } from "./theme-utils";
import themeRegistry from "./tweakcn-themes.json";
⋮----
interface ThemeItem {
  name: string;
  title: string;
  description: string;
  cssVars: {
    theme: Record<string, string>;
    light: Record<string, string>;
    dark: Record<string, string>;
  };
}
function generateCSSVars(vars: Record<string, string>): string
function generateThemeCSS(theme: ThemeItem): string
function generateThemesCSS(): string
function main()
</file>

<file path="platform/shared/themes/theme-config.ts">
export type ThemeCategory = "minimal" | "vibrant" | "dark" | "nature" | "tech";
export interface ThemeConfig {
  id: string;
  category: ThemeCategory;
  isDefault?: boolean;
}
</file>

<file path="platform/shared/themes/theme-utils.ts">
import {
  DEFAULT_THEME_ID,
  SUPPORTED_THEMES,
  THEME_CATEGORY_LABELS,
  type THEME_IDS,
  type ThemeCategory,
} from "./theme-config";
import themeRegistry from "./tweakcn-themes.json";
⋮----
export type ThemeId = (typeof THEME_IDS)[number];
export interface ThemeItem {
  name: ThemeId;
  title: string;
  description: string;
  cssVars: {
    theme: Record<string, string>;
    light: Record<string, string>;
    dark: Record<string, string>;
  };
}
export interface ThemeMetadata {
  id: ThemeId;
  name: string;
  category: ThemeCategory;
}
export function getSupportedThemeItems(): ThemeItem[]
export function getThemeMetadata(): ThemeMetadata[]
export function getThemeById(id: ThemeId): ThemeMetadata | undefined
export function getThemesByCategory(category: ThemeCategory): ThemeMetadata[]
export function getThemeCategories(): Array<
export function getThemeItemById(id: string): ThemeItem | undefined
</file>

<file path="platform/shared/index.ts">

</file>

<file path="platform/shared/types.ts">
export type ErrorExtended = {
  message: string;
  request?: {
    method: string;
    url: string;
  };
  data?: object;
  stack?: string;
};
</file>

<file path="platform/.cursorrules">
# Cursor Rules for Archestra Platform

**⚠️ DEPRECATED: This file is legacy. Modern Cursor uses Project Rules in `.cursor/rules/`.**
**For the latest rules, see `.cursor/rules/` directory.**

**⚠️ IMPORTANT: Keep `.cursor/rules/` in sync with CLAUDE.md. When updating one, update the other.**

## Working Directory

**ALWAYS run all commands from the `platform/` directory unless specifically instructed otherwise.**

## Important Rules

1. **ALWAYS use pnpm** (not npm or yarn) for package management
2. **Use Biome for formatting and linting** - Run `pnpm lint` before committing changes
3. **TypeScript strict mode** - Ensure code passes `pnpm type-check` before completion
4. **Tilt for development** - The project uses Tilt to orchestrate the development environment
5. **Use shadcn/ui components** - Add components with `npx shadcn@latest add <component>` instead of using Radix UI directly

## Tech Stack

- **Monorepo**: pnpm workspaces with Turbo for build orchestration
- **Development**: Tilt for local development orchestration
- **Backend**: Fastify + Drizzle ORM (PostgreSQL)
- **Frontend**: Next.js 15.5.4 + React 19 + Turbopack + Tailwind CSS 4 + shadcn/ui
- **Code Quality**: Biome for linting and formatting
- **Testing**: Vitest with PGLite

## Development Best Practices

- Use existing patterns and libraries - check neighboring files for examples
- Follow existing naming conventions (camelCase for TypeScript)
- Test files should be colocated with source (`.test.ts` extension)
- Use workspace-relative imports within each workspace
- Run `pnpm type-check` before committing to catch type errors
- Use `tilt up` for the best development experience with hot reload
</file>

<file path="platform/.dockerignore">
# Dependencies
node_modules
**/node_modules

# Build outputs
dist
.next
.turbo

# Development
.tilt
.env.local
.env.*.local

# Tests
coverage
**/*.test.ts
**/*.test.tsx

# Misc
.DS_Store
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# IDE
.vscode
.idea
*.swp
*.swo

# Git
.git
.gitignore
</file>

<file path="platform/.editorconfig">
# EditorConfig: https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
quote_type = single
end_of_line = lf
insert_final_newline = true

[Makefile]
indent_style = tab

[*.py]
indent_size = 2

[*.{yml,yaml,md}]
quote_type = double

[*.sh]
indent_style = space
indent_size = 2
</file>

<file path="platform/.gitignore">
# compiled output
dist
node_modules
build
.next
next-env.d.ts

# Logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
coverage
.nyc_output

# IDEs and editors
.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# turbopack
.turbo

tsconfig.tsbuildinfo
.playwright-mcp
benchmark-config.env

# Playwright
/playwright/
playwright-report/
</file>

<file path="platform/LICENSE">
../LICENSE
</file>

<file path="platform/Tiltfile">
allow_k8s_contexts(['orbstack', 'docker-desktop'])

load('ext://dotenv', 'dotenv')

is_prod = os.getenv('PROD') == 'true'

# Disable analytics in local development
os.putenv('NEXT_PUBLIC_ARCHESTRA_ANALYTICS', "disabled")

# set NEXT_PUBLIC_ARCHESTRA_API_BASE_URL to the same value as ARCHESTRA_API_BASE_URL
# so it's accessible by the frontend
api_base_url = os.getenv("ARCHESTRA_API_BASE_URL")
next_pubic_api_base_url = os.getenv("NEXT_PUBLIC_ARCHESTRA_API_BASE_URL")
if not next_pubic_api_base_url and api_base_url and api_base_url != "":
  os.putenv('NEXT_PUBLIC_ARCHESTRA_API_BASE_URL', api_base_url)

# set NEXT_PUBLIC_ARCHESTRA_SENTRY_ENVIRONMENT to the same value as ARCHESTRA_SENTRY_ENVIRONMENT
# so it's accessible by the frontend
sentry_server_name = os.getenv("ARCHESTRA_SENTRY_ENVIRONMENT")
next_public_sentry_server_name = os.getenv("NEXT_PUBLIC_ARCHESTRA_SENTRY_ENVIRONMENT")
if not next_public_sentry_server_name and sentry_server_name and sentry_server_name != "":
  os.putenv('NEXT_PUBLIC_ARCHESTRA_SENTRY_ENVIRONMENT', sentry_server_name)

# Check if .env exists, if not copy from .env.example
if not os.path.exists('.env'):
  local('cp .env.example .env')
  print("📝 Created .env from .env.example, be sure to fill in any necessary unique values (ex. API keys)")
else:
  print("📝 .env already exists, skipping copy from .env.example")

dotenv('./.env')

# Load sub-Tiltfiles by label
load_dynamic('./dev/Tiltfile.database')
load_dynamic('./dev/Tiltfile.dev')
load_dynamic('./dev/Tiltfile.test')
load_dynamic('./dev/Tiltfile.integrations')
</file>

<file path="platform/backend/src/auth/fastify-plugin/middleware.test.ts">
import type { FastifyReply, FastifyRequest } from "fastify";
import { vi } from "vitest";
import { describe, expect, test } from "@/test";
import { Authnz } from "./middleware";
</file>

<file path="platform/backend/src/auth/member-deletion.test.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import MemberModel from "@/models/member";
import { describe, expect, test } from "@/test";
</file>

<file path="platform/backend/src/clients/chat-mcp-client.test.ts">
import type { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { vi } from "vitest";
import { describe, expect, test } from "@/test";
</file>

<file path="platform/backend/src/clients/chat-mcp-client.ts">
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { jsonSchema, type Tool } from "ai";
import logger from "@/logging";
⋮----
setCachedClient(agentId: string, client: Client)
clearToolCache(agentId?: string)
⋮----
export function clearChatMcpClient(agentId: string): void
export async function getChatMcpClient(
  agentId: string,
): Promise<Client | null>
function normalizeJsonSchema(schema: any): any
export async function getChatMcpTools(
  agentId: string,
): Promise<Record<string, Tool>>
</file>

<file path="platform/backend/src/clients/mcp-client.ts">
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import type { Tool } from "@modelcontextprotocol/sdk/types.js";
import { MCP_SERVER_TOOL_NAME_SEPARATOR } from "@shared";
import logger from "@/logging";
import { McpServerRuntimeManager } from "@/mcp-server-runtime";
import {
  InternalMcpCatalogModel,
  McpServerModel,
  McpToolCallModel,
  ToolModel,
} from "@/models";
import { secretManager } from "@/secretsmanager";
import { applyResponseModifierTemplate } from "@/templating";
import type {
  CommonMcpToolDefinition,
  CommonToolCall,
  CommonToolResult,
  InternalMcpCatalog,
} from "@/types";
import { K8sAttachTransport } from "./k8s-attach-transport";
type McpToolWithServerMetadata = {
  toolName: string;
  responseModifierTemplate: string | null;
  mcpServerSecretId: string | null;
  mcpServerName: string | null;
  mcpServerCatalogId: string | null;
  mcpServerId: string | null;
  credentialSourceMcpServerId: string | null;
  executionSourceMcpServerId: string | null;
  catalogId: string | null;
  catalogName: string | null;
};
class McpClient
⋮----
async executeToolCall(
    toolCall: CommonToolCall,
    agentId: string,
): Promise<CommonToolResult>
private async getOrCreateClient(
    connectionKey: string,
    transport: import("@modelcontextprotocol/sdk/shared/transport.js").Transport,
): Promise<Client>
private async validateAndGetTool(
    toolCall: CommonToolCall,
    agentId: string,
  ): Promise<
    | { tool: McpToolWithServerMetadata; catalogItem: InternalMcpCatalog }
    | { error: CommonToolResult }
  > {
    const mcpTools = await ToolModel.getMcpToolsAssignedToAgent(
      [toolCall.name],
      agentId,
    );
private async getExecutionContext(
    tool: McpToolWithServerMetadata,
    toolCall: CommonToolCall,
    agentId: string,
  ): Promise<
    | { targetMcpServerId: string; secrets: Record<string, unknown> }
    | { error: CommonToolResult }
  > {
    const targetMcpServerId =
      tool.executionSourceMcpServerId || tool.mcpServerId;
if (!targetMcpServerId)
private async getTransport(
    catalogItem: InternalMcpCatalog,
    targetMcpServerId: string,
    secrets: Record<string, unknown>,
  ): Promise<
    import("@modelcontextprotocol/sdk/shared/transport.js").Transport
  > {
if (catalogItem.serverType === "local")
private stripServerPrefix(toolName: string, prefixName: string): string
private applyTemplate(
    content: unknown,
    template: string | null,
    toolName: string,
): unknown
private async createErrorResult(
    toolCall: CommonToolCall,
    agentId: string,
    error: string,
    mcpServerName: string = "unknown",
): Promise<CommonToolResult>
private async createSuccessResult(
    toolCall: CommonToolCall,
    agentId: string,
    mcpServerName: string,
    content: unknown,
    isError: boolean,
    template: string | null,
): Promise<CommonToolResult>
private async persistToolCall(
    agentId: string,
    mcpServerName: string,
    toolCall: CommonToolCall,
    toolResult: CommonToolResult,
): Promise<void>
private createTimeout(ms: number, message: string): Promise<never>
async connectAndGetTools(params: {
    catalogItem: InternalMcpCatalog;
    mcpServerId: string;
    secrets: Record<string, unknown>;
}): Promise<CommonMcpToolDefinition[]>
async disconnect(clientId: string): Promise<void>
async disconnectAll(): Promise<void>
</file>

<file path="platform/backend/src/database/migrations/0060_demonic_jimmy_woo.sql">
ALTER TABLE "optimization_rules" DROP CONSTRAINT "optimization_rules_agent_id_agents_id_fk";
ALTER TABLE "optimization_rules" ADD COLUMN "entity_type" varchar;
ALTER TABLE "optimization_rules" ADD COLUMN "entity_id" text;
UPDATE "optimization_rules" SET
  "entity_type" = 'organization',
  "entity_id" = (
    SELECT COALESCE(
      (SELECT t.organization_id
       FROM agent_team at
       JOIN team t ON t.id = at.team_id
       WHERE at.agent_id = optimization_rules.agent_id
       LIMIT 1),
      (SELECT id FROM organization LIMIT 1)
    )
  );
ALTER TABLE "optimization_rules" ALTER COLUMN "entity_type" SET NOT NULL;
ALTER TABLE "optimization_rules" ALTER COLUMN "entity_id" SET NOT NULL;
CREATE INDEX "optimization_rules_entity_idx" ON "optimization_rules" USING btree ("entity_type","entity_id");
ALTER TABLE "optimization_rules" DROP COLUMN "agent_id";
</file>

<file path="platform/backend/src/database/migrations/0061_toon_compressor.sql">
ALTER TABLE "agents" ADD COLUMN "convert_tool_results_to_toon" boolean DEFAULT false NOT NULL;
ALTER TABLE "interactions" ADD COLUMN "processed_request" jsonb;
ALTER TABLE "interactions" ADD COLUMN "toon_tokens_before" integer;
ALTER TABLE "interactions" ADD COLUMN "toon_tokens_after" integer;
</file>

<file path="platform/backend/src/database/migrations/0062_burly_shatterstar.sql">
ALTER TABLE "organization_role" DROP CONSTRAINT "organization_role_organization_id_name_unique";
ALTER TABLE "organization_role" ALTER COLUMN "id" SET DATA TYPE text;
ALTER TABLE "organization_role" ALTER COLUMN "id" DROP DEFAULT;
ALTER TABLE "organization_role" ADD COLUMN "role" text;
UPDATE "organization_role" SET "role" = "name";
ALTER TABLE "organization_role" ALTER COLUMN "role" SET NOT NULL;
ALTER TABLE "organization_role" ADD CONSTRAINT "organization_role_organization_id_role_unique" UNIQUE("organization_id","role");
ALTER TABLE "invitation" ADD COLUMN "created_at" timestamp DEFAULT now() NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0063_glorious_storm.sql">
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'prompts' AND column_name = 'agent_id') THEN
    ALTER TABLE "prompts" ADD COLUMN "agent_id" uuid;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'prompts' AND column_name = 'user_prompt') THEN
    ALTER TABLE "prompts" ADD COLUMN "user_prompt" text;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'prompts' AND column_name = 'system_prompt') THEN
    ALTER TABLE "prompts" ADD COLUMN "system_prompt" text;
  END IF;
END $$;
INSERT INTO "prompts" ("id", "organization_id", "name", "type", "content", "created_by", "agent_id", "user_prompt", "system_prompt", "version", "is_active", "created_at", "updated_at")
SELECT
  gen_random_uuid() as "id",
  p."organization_id",
  p."name",
  p."type",
  p."content",
  p."created_by",
  ap."agent_id",
  CASE WHEN p."type" = 'regular' THEN p."content" ELSE NULL END as "user_prompt",
  CASE WHEN p."type" = 'system' THEN p."content" ELSE NULL END as "system_prompt",
  1 as "version",
  true as "is_active",
  p."created_at",
  p."updated_at"
FROM "prompts" p
INNER JOIN "agent_prompts" ap ON p."id" = ap."prompt_id"
WHERE p."is_active" = true
  AND p."agent_id" IS NULL;
DELETE FROM "prompts" WHERE "agent_id" IS NULL;
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns
             WHERE table_name = 'prompts' AND column_name = 'type') THEN
    ALTER TABLE "prompts" DROP COLUMN "type";
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns
             WHERE table_name = 'prompts' AND column_name = 'content') THEN
    ALTER TABLE "prompts" DROP COLUMN "content";
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns
             WHERE table_name = 'prompts' AND column_name = 'created_by') THEN
    ALTER TABLE "prompts" DROP COLUMN "created_by";
  END IF;
END $$;
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'prompts'
      AND column_name = 'agent_id'
      AND is_nullable = 'YES'
  ) THEN
    ALTER TABLE "prompts" ALTER COLUMN "agent_id" SET NOT NULL;
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'prompts_agent_id_agents_id_fk'
  ) THEN
    ALTER TABLE "prompts" ADD CONSTRAINT "prompts_agent_id_agents_id_fk"
      FOREIGN KEY ("agent_id") REFERENCES "agents"("id") ON DELETE cascade ON UPDATE no action;
  END IF;
END $$;
DROP TABLE IF EXISTS "agent_prompts";
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'conversations' AND column_name = 'prompt_id'
  ) THEN
    ALTER TABLE "conversations" ADD COLUMN "prompt_id" uuid;
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints
    WHERE constraint_name = 'conversations_prompt_id_prompts_id_fk'
  ) THEN
    ALTER TABLE "conversations" ADD CONSTRAINT "conversations_prompt_id_prompts_id_fk"
      FOREIGN KEY ("prompt_id") REFERENCES "prompts"("id") ON DELETE set null ON UPDATE no action;
  END IF;
END $$;
</file>

<file path="platform/backend/src/database/migrations/0064_interactions_add_toon_cost_savings.sql">
ALTER TABLE "interactions" ADD COLUMN "toon_cost_savings" numeric(13, 10);
</file>

<file path="platform/backend/src/database/migrations/0065_keen_moondragon.sql">
ALTER TABLE "agents" DROP COLUMN "optimize_cost";
ALTER TABLE "optimization_rules" DROP COLUMN "priority";
</file>

<file path="platform/backend/src/database/migrations/0066_tan_sprite.sql">
ALTER TABLE "organization" ADD COLUMN "convert_tool_results_to_toon" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0067_many_bloodstorm.sql">
ALTER TABLE "agents" DROP COLUMN "convert_tool_results_to_toon";
</file>

<file path="platform/backend/src/database/migrations/0068_sour_iron_patriot.sql">
ALTER TABLE "organization" ADD COLUMN "compression_scope" varchar DEFAULT 'organization' NOT NULL;
ALTER TABLE "team" ADD COLUMN "convert_tool_results_to_toon" boolean DEFAULT false NOT NULL;
</file>

<file path="platform/backend/src/database/migrations/0069_magical_king_bedlam.sql">
CREATE TABLE "sso_provider" (
	"id" text PRIMARY KEY NOT NULL,
	"issuer" text NOT NULL,
	"oidc_config" text,
	"saml_config" text,
	"user_id" text,
	"provider_id" text NOT NULL,
	"organization_id" text,
	"domain" text NOT NULL,
	CONSTRAINT "sso_provider_provider_id_unique" UNIQUE("provider_id")
);
ALTER TABLE "sso_provider" ADD CONSTRAINT "sso_provider_user_id_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;
</file>

<file path="platform/backend/src/database/migrations/0070_vault secrets manager.sql">
ALTER TABLE "secret" ADD COLUMN "is_vault" boolean DEFAULT false NOT NULL;
ALTER TABLE "agents" DROP COLUMN "use_in_chat";
</file>

<file path="platform/backend/src/database/schemas/conversation.ts">
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import agentsTable from "./agent";
import promptsTable from "./prompt";
</file>

<file path="platform/backend/src/database/schemas/invitation.ts">
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";
import organizationsTable from "./organization";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/member.ts">
import { MEMBER_ROLE_NAME } from "@shared";
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";
import organizationsTable from "./organization";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/organization-role.ts">
import { pgTable, text, timestamp, unique } from "drizzle-orm/pg-core";
import organizationsTable from "./organization";
</file>

<file path="platform/backend/src/database/schemas/organization.ts">
import type { OrganizationCustomFont, OrganizationTheme } from "@shared";
import {
  boolean,
  pgTable,
  text,
  timestamp,
  varchar,
} from "drizzle-orm/pg-core";
import type {
  OrganizationCompressionScope,
  OrganizationLimitCleanupInterval,
} from "@/types";
</file>

<file path="platform/backend/src/database/schemas/prompt.ts">
import {
  boolean,
  integer,
  pgTable,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import agentsTable from "./agent";
</file>

<file path="platform/backend/src/database/schemas/secret.ts">
import { boolean, jsonb, pgTable, timestamp, uuid } from "drizzle-orm/pg-core";
import type { SecretValue } from "@/types";
</file>

<file path="platform/backend/src/database/schemas/sso-provider.ts">
import type { SsoProviderOidcConfig, SsoProviderSamlConfig } from "@shared";
import { pgTable, text } from "drizzle-orm/pg-core";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/team.ts">
import { boolean, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import organizationsTable from "./organization";
import usersTable from "./user";
</file>

<file path="platform/backend/src/database/schemas/user.ts">
import { boolean, pgTable, text, timestamp } from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/seed.ts">
import { ADMIN_ROLE_NAME, type PredefinedRoleName } from "@shared";
import logger from "@/logging";
import {
  AgentModel,
  DualLlmConfigModel,
  MemberModel,
  OrganizationModel,
  PromptModel,
  ToolModel,
  UserModel,
} from "@/models";
import type { InsertDualLlmConfig } from "@/types";
export async function seedDefaultUserAndOrg(
  config: {
    email?: string;
    password?: string;
    role?: PredefinedRoleName;
    name?: string;
  } = {},
)
async function seedDualLlmConfig(): Promise<void>
async function seedN8NSystemPrompt(): Promise<void>
async function seedDefaultRegularPrompts(): Promise<void>
async function seedArchestraTools(): Promise<void>
export async function seedRequiredStartingData(): Promise<void>
</file>

<file path="platform/backend/src/mcp-server-runtime/k8s-pod.ts">
import { PassThrough } from "node:stream";
⋮----
import type { Attach } from "@kubernetes/client-node";
import type { LocalConfigSchema } from "@shared";
import type z from "zod";
import config from "@/config";
import logger from "@/logging";
import { InternalMcpCatalogModel } from "@/models";
import type { InternalMcpCatalog, McpServer } from "@/types";
import type { K8sPodState, K8sPodStatusSummary } from "./schemas";
⋮----
export default class K8sPod
⋮----
constructor(
    mcpServer: McpServer,
    k8sApi: k8s.CoreV1Api,
    k8sAttach: Attach,
    k8sLog: k8s.Log,
    namespace: string,
    catalogItem?: InternalMcpCatalog | null,
    userConfigValues?: Record<string, string>,
    environmentValues?: Record<string, string>,
)
static constructPodName(mcpServer: McpServer): string
static constructK8sSecretName(mcpServerId: string): string
static ensureStringIsRfc1123Compliant(input: string): string
⋮----
.replace(/[^a-z0-9.-]/g, "") // remove invalid characters
.replace(/-+/g, "-") // collapse consecutive hyphens
.replace(/\.+/g, ".") // collapse consecutive dots
.replace(/^[^a-z0-9]+/, "") // remove leading non-alphanumeric
.replace(/[^a-z0-9]+$/, ""); // remove trailing non-alphanumeric
⋮----
/**
   * Sanitizes metadata labels to ensure all keys and values are RFC 1123 compliant.
   * Also ensures values are no longer than 63 characters as per Kubernetes label requirements.
   */
static sanitizeMetadataLabels(
    labels: Record<string, string>,
): Record<string, string>
⋮----
// Labels values must be 63 characters or less and end with alphanumeric
⋮----
/**
   * Get catalog item for this MCP server
   */
private async getCatalogItem(): Promise<InternalMcpCatalog | null>
/**
   * Create or update a Kubernetes Secret for environment variables marked as "secret" type
   */
async createK8sSecret(secretData: Record<string, string>): Promise<void>
async deleteK8sSecret(): Promise<void>
generatePodSpec(
    dockerImage: string,
    localConfig: z.infer<typeof LocalConfigSchema>,
    needsHttp: boolean,
    httpPort: number,
): k8s.V1Pod
createPodEnvFromConfig(): k8s.V1EnvVar[]
async startOrCreatePod(): Promise<void>
⋮----
// For HTTP servers, create a K8s Service and set endpoint URL
⋮----
// Get HTTP path from config (default to /mcp)
⋮----
private async needsHttpPort(): Promise<boolean>
private async createServiceForHttpServer(httpPort: number): Promise<void>
private async assignHttpPortIfNeeded(pod: k8s.V1Pod): Promise<void>
async waitForPodReady(maxAttempts = 60, intervalMs = 2000): Promise<void>
async stopPod(): Promise<void>
async removePod(): Promise<void>
async getRecentLogs(lines: number = 100): Promise<string>
async streamLogs(
    responseStream: NodeJS.WritableStream,
    lines: number = 100,
): Promise<void>
get statusSummary(): K8sPodStatusSummary
get containerName(): string
get k8sAttachClient(): Attach
get k8sNamespace(): string
get k8sPodName(): string
async usesStreamableHttp(): Promise<boolean>
getHttpEndpointUrl(): string | undefined
</file>

<file path="platform/backend/src/mcp-server-runtime/manager.ts">
import { Attach } from "@kubernetes/client-node";
import config from "@/config";
import logger from "@/logging";
import { InternalMcpCatalogModel, McpServerModel } from "@/models";
import { secretManager } from "@/secretsmanager";
import type { McpServer } from "@/types";
import K8sPod from "./k8s-pod";
import type {
  AvailableTool,
  K8sRuntimeStatus,
  K8sRuntimeStatusSummary,
  McpServerContainerLogs,
} from "./schemas";
⋮----
export class McpServerRuntimeManager
⋮----
constructor()
get isEnabled(): boolean
async start(): Promise<void>
private async verifyK8sConnection(): Promise<void>
async startServer(
    mcpServer: McpServer,
    userConfigValues?: Record<string, string>,
    environmentValues?: Record<string, string>,
): Promise<void>
async stopServer(mcpServerId: string): Promise<void>
getPod(mcpServerId: string): K8sPod | undefined
async removeMcpServer(mcpServerId: string): Promise<void>
async restartServer(mcpServerId: string): Promise<void>
async usesStreamableHttp(mcpServerId: string): Promise<boolean>
getHttpEndpointUrl(mcpServerId: string): string | undefined
async getMcpServerLogs(
    mcpServerId: string,
    lines: number = 100,
): Promise<McpServerContainerLogs>
async streamMcpServerLogs(
    mcpServerId: string,
    responseStream: NodeJS.WritableStream,
    lines: number = 100,
): Promise<void>
get allAvailableTools(): AvailableTool[]
get statusSummary(): K8sRuntimeStatusSummary
async shutdown(): Promise<void>
</file>

<file path="platform/backend/src/models/internal-mcp-catalog.test.ts">
import { describe, expect, test } from "@/test";
import InternalMcpCatalogModel from "./internal-mcp-catalog";
</file>

<file path="platform/backend/src/models/internal-mcp-catalog.ts">
import { desc, eq, ilike, inArray, or } from "drizzle-orm";
import db, { schema } from "@/database";
import type {
  InsertInternalMcpCatalog,
  InternalMcpCatalog,
  UpdateInternalMcpCatalog,
} from "@/types";
import McpServerModel from "./mcp-server";
class InternalMcpCatalogModel
⋮----
static async create(
    catalogItem: InsertInternalMcpCatalog,
): Promise<InternalMcpCatalog>
static async findAll(): Promise<InternalMcpCatalog[]>
static async searchByQuery(query: string): Promise<InternalMcpCatalog[]>
static async findById(id: string): Promise<InternalMcpCatalog | null>
static async getByIds(
    ids: string[],
): Promise<Map<string, InternalMcpCatalog>>
static async findByName(name: string): Promise<InternalMcpCatalog | null>
static async update(
    id: string,
    catalogItem: Partial<UpdateInternalMcpCatalog>,
): Promise<InternalMcpCatalog | null>
static async delete(id: string): Promise<boolean>
</file>

<file path="platform/backend/src/models/invitation.ts">
import { MEMBER_ROLE_NAME } from "@shared";
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import logger from "@/logging";
import type {
  BetterAuthSession,
  BetterAuthSessionUser,
  UpdateInvitation,
} from "@/types";
import MemberModel from "./member";
import SessionModel from "./session";
class InvitationModel
⋮----
static async getById(invitationId: string)
static async accept(
    { id: sessionId }: BetterAuthSession,
    user: BetterAuthSessionUser,
    invitationId: string,
)
static async patch(invitationId: string, data: Partial<UpdateInvitation>)
static async delete(invitationId: string)
</file>

<file path="platform/backend/src/models/mcp-server-team.test.ts">
import { describe, expect, test } from "@/test";
import McpServerTeamModel from "./mcp-server-team";
import TeamModel from "./team";
</file>

<file path="platform/backend/src/models/mcp-server-team.ts">
import { and, eq, inArray } from "drizzle-orm";
import db, { schema } from "@/database";
class McpServerTeamModel
⋮----
static async getUserAccessibleMcpServerIds(
    userId: string,
    isMcpServerAdmin: boolean,
): Promise<string[]>
static async userHasMcpServerAccess(
    userId: string,
    mcpServerId: string,
    isMcpServerAdmin: boolean,
): Promise<boolean>
static async getTeamsForMcpServer(mcpServerId: string): Promise<string[]>
static async getTeamDetailsForMcpServer(mcpServerId: string): Promise<
    Array<{
      teamId: string;
      name: string;
      createdAt: Date;
    }>
  > {
    const result = await db
      .select({
        teamId: schema.mcpServerTeamsTable.teamId,
        name: schema.teamsTable.name,
        createdAt: schema.mcpServerTeamsTable.createdAt,
      })
      .from(schema.mcpServerTeamsTable)
      .innerJoin(
        schema.teamsTable,
        eq(schema.mcpServerTeamsTable.teamId, schema.teamsTable.id),
      )
      .where(eq(schema.mcpServerTeamsTable.mcpServerId, mcpServerId));
static async syncMcpServerTeams(
    mcpServerId: string,
    teamIds: string[],
): Promise<number>
static async assignTeamsToMcpServer(
    mcpServerId: string,
    teamIds: string[],
): Promise<void>
static async getTeamDetailsForMcpServers(mcpServerIds: string[]): Promise<
    Map<
      string,
      Array<{
        teamId: string;
        name: string;
        createdAt: Date;
      }>
    >
  > {
if (mcpServerIds.length === 0)
static async removeTeamFromMcpServer(
    mcpServerId: string,
    teamId: string,
): Promise<boolean>
</file>

<file path="platform/backend/src/models/mcp-server.ts">
import { eq, inArray, isNull } from "drizzle-orm";
import mcpClient from "@/clients/mcp-client";
import db, { schema } from "@/database";
import logger from "@/logging";
import { McpServerRuntimeManager } from "@/mcp-server-runtime";
import { secretManager } from "@/secretsmanager";
import type { InsertMcpServer, McpServer, UpdateMcpServer } from "@/types";
import InternalMcpCatalogModel from "./internal-mcp-catalog";
import McpServerTeamModel from "./mcp-server-team";
import McpServerUserModel from "./mcp-server-user";
import ToolModel from "./tool";
class McpServerModel
⋮----
static async create(server: InsertMcpServer): Promise<McpServer>
static async findAll(
    userId?: string,
    isMcpServerAdmin?: boolean,
): Promise<McpServer[]>
static async findById(
    id: string,
    userId?: string,
    isMcpServerAdmin?: boolean,
): Promise<McpServer | null>
static async findByCatalogId(catalogId: string): Promise<McpServer[]>
static async findCustomServers(): Promise<McpServer[]>
static async update(
    id: string,
    server: Partial<UpdateMcpServer>,
): Promise<McpServer | null>
static async delete(id: string): Promise<boolean>
static async getToolsFromServer(mcpServer: McpServer): Promise<
    Array<{
      name: string;
      description: string;
      inputSchema: Record<string, unknown>;
    }>
  > {
    let catalogItem = null;
if (mcpServer.catalogId)
static async validateConnection(
    serverName: string,
    catalogId?: string,
    secretId?: string,
): Promise<boolean>
</file>

<file path="platform/backend/src/models/organization-role.test.ts">
import {
  ADMIN_ROLE_NAME,
  MEMBER_ROLE_NAME,
  predefinedPermissionsMap,
} from "@shared";
import { describe, expect, test } from "@/test";
import OrganizationRoleModel from "./organization-role";
</file>

<file path="platform/backend/src/models/organization-role.ts">
import {
  ADMIN_ROLE_NAME,
  MEMBER_ROLE_NAME,
  type Permissions,
  type PredefinedRoleName,
  PredefinedRoleNameSchema,
  predefinedPermissionsMap,
  type Resource,
} from "@shared";
import { and, eq, getTableColumns, sql } from "drizzle-orm";
import db, { schema } from "@/database";
import type { OrganizationRole } from "@/types";
const generatePredefinedRole = (
  role: PredefinedRoleName,
  organizationId: string,
): OrganizationRole => (
class OrganizationRoleModel
⋮----
static isPredefinedRole(roleName: string): roleName is PredefinedRoleName
static getPredefinedRolePermissions(
    roleName: PredefinedRoleName,
): Permissions
static validateRolePermissions(
    userPermissions: Permissions,
    rolePermissions: Permissions,
):
static async canDelete(
    roleId: string,
    organizationId: string,
): Promise<
static async getByIdentifier(
    identifier: string,
    organizationId: string,
): Promise<OrganizationRole | null>
static async getById(
    roleId: string,
    organizationId: string,
): Promise<OrganizationRole | null>
static async getPermissions(
    identifier: string,
    organizationId: string,
): Promise<Permissions>
static async getAll(
    organizationId: string,
): Promise<Array<OrganizationRole>>
static async create(): Promise<OrganizationRole>
static async update(): Promise<OrganizationRole>
static async delete(): Promise<boolean>
</file>

<file path="platform/backend/src/models/prompt.fix.test.ts">
import { describe, expect, test } from "@/test";
import AgentModel from "./agent";
import PromptModel from "./prompt";
</file>

<file path="platform/backend/src/models/secret.ts">
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { InsertSecret, SelectSecret, UpdateSecret } from "@/types";
class SecretModel
⋮----
static async create(input: InsertSecret): Promise<SelectSecret>
static async findById(id: string): Promise<SelectSecret | null>
static async update(
    id: string,
    input: UpdateSecret,
): Promise<SelectSecret | null>
static async delete(id: string): Promise<boolean>
</file>

<file path="platform/backend/src/models/sso-provider.test.ts">
import { describe, expect, test } from "@/test";
import SsoProviderModel from "./sso-provider";
</file>

<file path="platform/backend/src/models/sso-provider.ts">
import { and, eq } from "drizzle-orm";
import { auth } from "@/auth/better-auth";
import db, { schema } from "@/database";
import type {
  InsertSsoProvider,
  PublicSsoProvider,
  SsoProvider,
  UpdateSsoProvider,
} from "@/types";
class SsoProviderModel
⋮----
static async findAllPublic(): Promise<PublicSsoProvider[]>
static async findAll(organizationId: string): Promise<SsoProvider[]>
static async findById(
    id: string,
    organizationId: string,
): Promise<SsoProvider | null>
static async create(
    data: Omit<InsertSsoProvider, "id">,
    organizationId: string,
    headers: HeadersInit,
): Promise<SsoProvider>
static async update(
    id: string,
    data: Partial<UpdateSsoProvider>,
    organizationId: string,
): Promise<SsoProvider | null>
static async delete(id: string, organizationId: string): Promise<boolean>
</file>

<file path="platform/backend/src/models/statistics.ts">
import type { StatisticsTimeFrame } from "@shared";
import { and, eq, gte, inArray, lte, sql } from "drizzle-orm";
import db, { schema } from "@/database";
import type {
  AgentStatistics,
  CostSavingsStatistics,
  ModelStatistics,
  OverviewStatistics,
  StatisticsTimeSeriesData,
  TeamStatistics,
} from "@/types";
import AgentTeamModel from "./agent-team";
class StatisticsModel
⋮----
private static parseCustomTimeframe(
    timeframe: string,
):
private static getTimeframeInterval(
    timeframe: StatisticsTimeFrame,
): string | null
private static getTimeBucket(timeframe: StatisticsTimeFrame): string
private static getBucketIntervalMinutes(
    timeframe: StatisticsTimeFrame,
): number
private static roundToBucket(
    timestamp: string,
    intervalMinutes: number,
): string
private static groupTimeSeries<T extends StatisticsTimeSeriesData>(
    timeSeriesData: T[],
    timeframe: StatisticsTimeFrame,
): T[]
private static async getAverageTokenPrices(): Promise<
private static calculateCost(
    inputTokens: number,
    outputTokens: number,
    avgInputPrice: number,
    avgOutputPrice: number,
): number
static async getTeamStatistics(
    timeframe: StatisticsTimeFrame,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<TeamStatistics[]>
⋮----
// Debug logging for 1h timeframe only
⋮----
// Get team member counts
⋮----
// Get agent counts per team
⋮----
// Aggregate data by team
⋮----
/**
   * Get agent statistics
   */
static async getAgentStatistics(
    timeframe: StatisticsTimeFrame,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<AgentStatistics[]>
⋮----
// Get accessible agent IDs for users that are non-agent admins
⋮----
// Debug logging for 1h timeframe only
⋮----
// Aggregate data by agent
⋮----
/**
   * Get model statistics
   */
static async getModelStatistics(
    timeframe: StatisticsTimeFrame,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<ModelStatistics[]>
⋮----
// Get accessible agent IDs for users that are non-agent admins
⋮----
// Aggregate data by model
⋮----
// Calculate percentages
⋮----
/**
   * Get overview statistics
   */
static async getOverviewStatistics(
    timeframe: StatisticsTimeFrame,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<OverviewStatistics>
/**
   * Calculate actual cost: cost - toon_savings
   * This represents the final cost after all optimizations
   * - cost = cost after model optimization
   * - toonSavings = savings from TOON compression
   * - actual cost = cost after both model optimization and TOON
   */
private static calculateActualCost(
    cost: number,
    toonSavings: number,
): number
/**
   * Get cost savings statistics
   */
static async getCostSavingsStatistics(
    timeframe: StatisticsTimeFrame,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<CostSavingsStatistics>
⋮----
// Get accessible agent IDs for users that are non-agent admins
⋮----
interface CostSavingsRow {
      timeBucket: string;
      baselineCost: number;
      actualCost: number;
      toonSavings: number;
    }
</file>

<file path="platform/backend/src/models/team.ts">
import { MEMBER_ROLE_NAME } from "@shared";
import { and, eq } from "drizzle-orm";
import db, { schema } from "@/database";
import type { InsertTeam, Team, TeamMember, UpdateTeam } from "@/types";
class TeamModel
⋮----
static async create(
    input: Omit<InsertTeam, "id" | "createdAt" | "updatedAt">,
): Promise<Team>
static async findByOrganization(organizationId: string): Promise<Team[]>
static async findById(id: string): Promise<Team | null>
static async update(id: string, input: UpdateTeam): Promise<Team | null>
static async delete(id: string): Promise<boolean>
static async getTeamMembers(teamId: string): Promise<TeamMember[]>
static async addMember(
    teamId: string,
    userId: string,
    role: string = MEMBER_ROLE_NAME,
): Promise<TeamMember>
static async removeMember(teamId: string, userId: string): Promise<boolean>
static async getUserTeams(userId: string): Promise<Team[]>
static async isUserInTeam(teamId: string, userId: string): Promise<boolean>
static async getUserTeamIds(userId: string): Promise<string[]>
static async getTeamsForAgent(agentId: string): Promise<Team[]>
</file>

<file path="platform/backend/src/models/token-price.test.ts">
import { describe, expect, test } from "@/test";
import TokenPriceModel from "./token-price";
</file>

<file path="platform/backend/src/models/user.test.ts">
import {
  ADMIN_ROLE_NAME,
  MEMBER_ROLE_NAME,
  predefinedPermissionsMap,
} from "@shared";
import { eq } from "drizzle-orm";
import db, { schema } from "@/database";
import { beforeEach, describe, expect, test } from "@/test";
import type { InsertOrganizationRole } from "@/types";
import UserModel from "./user";
</file>

<file path="platform/backend/src/routes/proxy/anthropic.test.ts">
import Fastify, { type FastifyInstance } from "fastify";
import {
  serializerCompiler,
  validatorCompiler,
  type ZodTypeProvider,
} from "fastify-type-provider-zod";
import config from "@/config";
import { AgentModel, TokenPriceModel } from "@/models";
import { afterEach, beforeEach, describe, expect, test } from "@/test";
import anthropicProxyRoutes from "./anthropic";
</file>

<file path="platform/backend/src/routes/proxy/openai.test.ts">
import Fastify, { type FastifyInstance } from "fastify";
import {
  serializerCompiler,
  validatorCompiler,
  type ZodTypeProvider,
} from "fastify-type-provider-zod";
import config from "@/config";
import { AgentModel, TokenPriceModel } from "@/models";
import { afterEach, beforeEach, describe, expect, test } from "@/test";
import type { OpenAi } from "@/types";
import openAiProxyRoutes from "./openai";
⋮----
// Restore original config after registration
</file>

<file path="platform/backend/src/routes/chat-settings.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { ChatSettingsModel } from "@/models";
import { secretManager } from "@/secretsmanager";
import {
  ApiError,
  constructResponseSchema,
  SelectChatSettingsSchema,
} from "@/types";
const chatSettingsRoutes: FastifyPluginAsyncZod = async (fastify) =>
⋮----
// If API key is provided, create or update secret
⋮----
// Update existing secret
⋮----
// Create new secret
⋮----
// Update settings (only if secretId changed or was created)
</file>

<file path="platform/backend/src/routes/interaction.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { InteractionModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  createPaginatedResponseSchema,
  createSortingQuerySchema,
  PaginationQuerySchema,
  SelectInteractionSchema,
  UuidIdSchema,
} from "@/types";
const interactionRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/invitation.ts">
import { eq } from "drizzle-orm";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import db, { schema } from "@/database";
import { InvitationModel } from "@/models";
import { ApiError, constructResponseSchema } from "@/types";
const routes: FastifyPluginAsyncZod = async (app) =>
</file>

<file path="platform/backend/src/routes/limits.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { LimitModel, OptimizationRuleModel, TokenPriceModel } from "@/models";
import {
  ApiError,
  CreateLimitSchema,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  LimitEntityTypeSchema,
  LimitTypeSchema,
  LimitWithUsageSchema,
  SelectLimitSchema,
  UpdateLimitSchema,
  UuidIdSchema,
} from "@/types";
const limitsRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/mcp-gateway.ts">
import { randomUUID } from "node:crypto";
import type { IncomingMessage, ServerResponse } from "node:http";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  type Tool,
} from "@modelcontextprotocol/sdk/types.js";
import {
  ARCHESTRA_MCP_SERVER_NAME,
  MCP_SERVER_TOOL_NAME_SEPARATOR,
} from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import {
  executeArchestraTool,
  getArchestraMcpTools,
} from "@/archestra-mcp-server";
import { clearChatMcpClient } from "@/clients/chat-mcp-client";
import mcpClient from "@/clients/mcp-client";
import config from "@/config";
import logger from "@/logging";
import { AgentModel, McpToolCallModel, ToolModel } from "@/models";
import { type CommonToolCall, UuidIdSchema } from "@/types";
interface SessionData {
  server: Server;
  transport: StreamableHTTPServerTransport;
  lastAccess: number;
  agentId: string;
  agent?: {
    id: string;
    name: string;
  };
}
⋮----
function cleanupExpiredSessions(): void
async function createAgentServer(
  agentId: string,
  logger: { info: (obj: unknown, msg: string) => void },
  cachedAgent?: { name: string; id: string },
): Promise<
function createTransport(
  agentId: string,
  clientSessionId: string | undefined,
  logger: { info: (obj: unknown, msg: string) => void },
): StreamableHTTPServerTransport
function extractAgentIdFromAuth(authHeader: string | undefined): string | null
export function clearAgentSessions(agentId: string): void
const mcpGatewayRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/oauth.ts">
import { createHash, randomBytes } from "node:crypto";
import { exchangeAuthorization } from "@modelcontextprotocol/sdk/client/auth.js";
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import logger from "@/logging";
import { InternalMcpCatalogModel } from "@/models";
import { secretManager } from "@/secretsmanager";
import { ApiError, constructResponseSchema, UuidIdSchema } from "@/types";
function generateCodeVerifier(): string
function generateCodeChallenge(verifier: string): string
async function discoverOAuthResourceMetadata(serverUrl: string)
async function discoverScopes(
  serverUrl: string,
  supportsResourceMetadata: boolean,
  defaultScopes: string[],
): Promise<string[]>
function buildDiscoveryUrls(serverUrl: string): string[]
⋮----
// Root path: try OAuth then OIDC
⋮----
// Strip trailing slash
⋮----
// Try path-aware OAuth first, then root OAuth, then OIDC variants
⋮----
/**
 * Discover OAuth authorization server metadata with fallback support
 * Tries multiple discovery URLs like the MCP SDK does
 */
async function discoverAuthorizationServerMetadata(serverUrl: string): Promise<
async function registerOAuthClient(
  registrationEndpoint: string,
  clientMetadata: {
    client_name: string;
    redirect_uris: string[];
    grant_types?: string[];
    response_types?: string[];
    scope?: string;
  },
)
⋮----
const oauthRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/optimization-rule.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { OptimizationRuleModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  InsertOptimizationRuleSchema,
  SelectOptimizationRuleSchema,
  UpdateOptimizationRuleSchema,
  UuidIdSchema,
} from "@/types";
const optimizationRuleRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/organization-role.ts">
import { PermissionsSchema, PredefinedRoleNameSchema, RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { betterAuth } from "@/auth";
import logger from "@/logging";
import { OrganizationRoleModel, UserModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  SelectOrganizationRoleSchema,
} from "@/types";
⋮----
const generateRoleIdentifier = (title: string): string =>
⋮----
.replace(/^_+|_+$/g, ""); // Remove leading/trailing underscores
⋮----
const organizationRoleRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/sso-provider.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { SsoProviderModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  InsertSsoProviderSchema,
  PublicSsoProviderSchema,
  SelectSsoProviderSchema,
  UpdateSsoProviderSchema,
} from "@/types";
const ssoProviderRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/statistics.ts">
import { RouteId, StatisticsTimeFrameSchema } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { StatisticsModel } from "@/models";
import {
  AgentStatisticsSchema,
  CostSavingsStatisticsSchema,
  constructResponseSchema,
  ModelStatisticsSchema,
  OverviewStatisticsSchema,
  TeamStatisticsSchema,
} from "@/types";
⋮----
const statisticsRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/token-price.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { OptimizationRuleModel, TokenPriceModel } from "@/models";
import {
  ApiError,
  CreateTokenPriceSchema,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  SelectTokenPriceSchema,
  UpdateTokenPriceSchema,
  UuidIdSchema,
} from "@/types";
const tokenPriceRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/standalone-scripts/codegen-access-control-docs.ts">
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import {
  type Action,
  ADMIN_ROLE_NAME,
  allAvailableActions,
  MEMBER_ROLE_NAME,
  type PredefinedRoleName,
  predefinedPermissionsMap,
  type Resource,
} from "@shared";
import logger from "@/logging";
⋮----
function getResourceDescription(resource: Resource): string
function getRoleDescription(roleName: string): string
function generatePredefinedRolesTable(): string
function generateCustomRolesPermissionsTable(): string
function getActionDescription(action: Action): string
function generateMarkdownContent(): string
async function main()
⋮----
// Ensure directory exists
⋮----
// Write the generated content
</file>

<file path="platform/backend/src/tokenizers/anthropic.ts">
import { countTokens } from "@anthropic-ai/tokenizer";
import { BaseTokenizer, type ProviderMessage } from "./base";
export class AnthropicTokenizer extends BaseTokenizer
⋮----
countMessageTokens(message: ProviderMessage): number
</file>

<file path="platform/backend/src/tokenizers/base.ts">
import type { Anthropic, OpenAi } from "@/types";
export type ProviderMessage =
  | OpenAi.Types.ChatCompletionsRequest["messages"][number]
  | Anthropic.Types.MessagesRequest["messages"][number];
export interface Tokenizer {
  countTokens(messages: ProviderMessage[] | ProviderMessage): number;
}
⋮----
countTokens(messages: ProviderMessage[] | ProviderMessage): number;
⋮----
export abstract class BaseTokenizer implements Tokenizer
⋮----
countMessageTokens(message: ProviderMessage): number
countTokens(messages: ProviderMessage[] | ProviderMessage): number
protected getMessageText(message: ProviderMessage): string
</file>

<file path="platform/backend/src/tokenizers/index.ts">
import type { SupportedProvider } from "@/types";
import { AnthropicTokenizer } from "./anthropic";
import type { Tokenizer } from "./base";
import { TiktokenTokenizer } from "./tiktoken";
⋮----
export function getTokenizer(provider: SupportedProvider): Tokenizer
</file>

<file path="platform/backend/src/tokenizers/tiktoken.ts">
import { get_encoding, type Tiktoken } from "tiktoken";
import { BaseTokenizer, type ProviderMessage } from "./base";
export class TiktokenTokenizer extends BaseTokenizer
⋮----
constructor()
countMessageTokens(message: ProviderMessage): number
</file>

<file path="platform/backend/src/tokenizers/tokenizers.test.ts">
import { describe, expect, test } from "vitest";
import { AnthropicTokenizer } from "./anthropic";
import type { ProviderMessage } from "./base";
import { getTokenizer } from "./index";
import { TiktokenTokenizer } from "./tiktoken";
⋮----
// Should at least count the role
</file>

<file path="platform/backend/src/types/interaction.ts">
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import {
  Anthropic,
  Gemini,
  OpenAi,
  SupportedProvidersDiscriminatorSchema,
} from "./llm-providers";
⋮----
export type Interaction = z.infer<typeof SelectInteractionSchema>;
export type InsertInteraction = z.infer<typeof InsertInteractionSchema>;
export type InteractionRequest = z.infer<typeof InteractionRequestSchema>;
export type InteractionResponse = z.infer<typeof InteractionResponseSchema>;
</file>

<file path="platform/backend/src/types/mcp-catalog.ts">
import { LocalConfigSchema, OAuthConfigSchema } from "@shared";
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type InternalMcpCatalogServerType = z.infer<
  typeof InternalMcpCatalogServerTypeSchema
>;
export type InternalMcpCatalog = z.infer<typeof SelectInternalMcpCatalogSchema>;
export type InsertInternalMcpCatalog = z.infer<
  typeof InsertInternalMcpCatalogSchema
>;
export type UpdateInternalMcpCatalog = z.infer<
  typeof UpdateInternalMcpCatalogSchema
>;
</file>

<file path="platform/backend/src/types/organization.ts">
import { OrganizationCustomFontSchema, OrganizationThemeSchema } from "@shared";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type OrganizationLimitCleanupInterval = z.infer<
  typeof OrganizationLimitCleanupIntervalSchema
>;
export type OrganizationCompressionScope = z.infer<
  typeof OrganizationCompressionScopeSchema
>;
export type Organization = z.infer<typeof SelectOrganizationSchema>;
export type InsertOrganization = z.infer<typeof InsertOrganizationSchema>;
export type UpdateOrganization = z.infer<typeof UpdateOrganizationSchema>;
</file>

<file path="platform/backend/src/types/role.ts">
import { PermissionsSchema } from "@shared";
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type OrganizationRole = z.infer<typeof SelectOrganizationRoleSchema>;
export type InsertOrganizationRole = z.infer<
  typeof InsertOrganizationRoleSchema
>;
export type UpdateOrganizationRole = z.infer<
  typeof UpdateOrganizationRoleSchema
>;
</file>

<file path="platform/backend/src/types/sso-provider.ts">
import {
  SsoProviderOidcConfigSchema,
  SsoProviderSamlConfigSchema,
} from "@shared";
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type SsoProvider = z.infer<typeof SelectSsoProviderSchema>;
export type PublicSsoProvider = z.infer<typeof PublicSsoProviderSchema>;
export type InsertSsoProvider = z.infer<typeof InsertSsoProviderSchema>;
export type UpdateSsoProvider = z.infer<typeof UpdateSsoProviderSchema>;
</file>

<file path="platform/backend/src/types/statistics.ts">
import { z } from "zod";
⋮----
export type StatisticsTimeSeriesPoint = z.infer<
  typeof StatisticsTimeSeriesPointSchema
>;
export type TeamStatistics = z.infer<typeof TeamStatisticsSchema>;
export type AgentStatistics = z.infer<typeof AgentStatisticsSchema>;
export type ModelStatistics = z.infer<typeof ModelStatisticsSchema>;
export type OverviewStatistics = z.infer<typeof OverviewStatisticsSchema>;
export type CostSavingsStatistics = z.infer<typeof CostSavingsStatisticsSchema>;
export type StatisticsTeamTimeSeriesData = z.infer<
  typeof StatisticsTeamTimeSeriesDataSchema
>;
export type StatisticsAgentTimeSeriesData = z.infer<
  typeof StatisticsAgentTimeSeriesDataSchema
>;
export type StatisticsModelTimeSeriesData = z.infer<
  typeof StatisticsModelTimeSeriesDataSchema
>;
export type StatisticsTimeSeriesData = z.infer<
  typeof StatisticsTimeSeriesDataSchema
>;
</file>

<file path="platform/backend/src/types/team.ts">
import { MEMBER_ROLE_NAME } from "@shared";
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
⋮----
export type Team = z.infer<typeof SelectTeamSchema>;
export type InsertTeam = z.infer<typeof InsertTeamSchema>;
export type UpdateTeam = z.infer<typeof UpdateTeamSchema>;
export type TeamMember = z.infer<typeof SelectTeamMemberSchema>;
export type CreateTeamBody = z.infer<typeof CreateTeamBodySchema>;
export type UpdateTeamBody = z.infer<typeof UpdateTeamBodySchema>;
export type AddTeamMemberBody = z.infer<typeof AddTeamMemberBodySchema>;
</file>

<file path="platform/backend/src/types/websocket.ts">
import { z } from "zod";
⋮----
export type WebSocketMessage = z.infer<typeof WebSocketMessageSchema>;
</file>

<file path="platform/backend/src/archestra-mcp-server.test.ts">
import {
  ARCHESTRA_MCP_SERVER_NAME,
  MCP_SERVER_TOOL_NAME_SEPARATOR,
} from "@shared";
import { InternalMcpCatalogModel } from "@/models";
import { beforeEach, describe, expect, test, vi } from "@/test";
import type { Agent } from "@/types";
import {
  type ArchestraContext,
  executeArchestraTool,
  getArchestraMcpTools,
  isArchestraMcpServerTool,
} from "./archestra-mcp-server";
</file>

<file path="platform/backend/src/config.test.ts">
import { vi } from "vitest";
import { afterEach, beforeEach, describe, expect, test } from "@/test";
import { getDatabaseUrl, getOtlpAuthHeaders } from "./config";
⋮----
import logger from "./logging";
</file>

<file path="platform/backend/src/default-model-prices.ts">
function getDefaultModelPrice(model: string):
</file>

<file path="platform/backend/src/secretsmanager.test.ts">
import { vi } from "vitest";
import SecretModel from "@/models/secret";
import { afterEach, beforeEach, describe, expect, test } from "@/test";
⋮----
import {
  createSecretManager,
  DbSecretsManager,
  getSecretsManagerType,
  getVaultConfigFromEnv,
  SecretsManagerType,
  VaultSecretManager,
} from "./secretsmanager";
</file>

<file path="platform/backend/src/secretsmanager.ts">
import Vault from "node-vault";
import logger from "@/logging";
import SecretModel from "@/models/secret";
import type { SecretValue, SelectSecret } from "@/types";
export interface SecretManager {
  createSecret(secretValue: SecretValue): Promise<SelectSecret>;
  deleteSecret(secretId: string): Promise<boolean>;
  removeSecret(secretId: string): Promise<boolean>;
  getSecret(secretId: string): Promise<SelectSecret | null>;
  updateSecret(
    secretId: string,
    secretValue: SecretValue,
  ): Promise<SelectSecret | null>;
}
⋮----
createSecret(secretValue: SecretValue): Promise<SelectSecret>;
deleteSecret(secretId: string): Promise<boolean>;
removeSecret(secretId: string): Promise<boolean>;
getSecret(secretId: string): Promise<SelectSecret | null>;
updateSecret(
    secretId: string,
    secretValue: SecretValue,
  ): Promise<SelectSecret | null>;
⋮----
export interface VaultConfig {
  address: string;
  token: string;
}
export class DbSecretsManager implements SecretManager
⋮----
async createSecret(secretValue: SecretValue): Promise<SelectSecret>
async deleteSecret(secid: string): Promise<boolean>
async removeSecret(secid: string): Promise<boolean>
async getSecret(secid: string): Promise<SelectSecret | null>
async updateSecret(
    secid: string,
    secretValue: SecretValue,
): Promise<SelectSecret | null>
⋮----
export class VaultSecretManager implements SecretManager
⋮----
constructor(config: VaultConfig)
private getVaultPath(secid: string): string
private getVaultMetadataPath(secid: string): string
⋮----
export function getVaultConfigFromEnv(): VaultConfig | null
export enum SecretsManagerType {
  DB = "DB",
  Vault = "Vault",
}
export function getSecretsManagerType(): SecretsManagerType
export function createSecretManager(): SecretManager
</file>

<file path="platform/backend/src/websocket.ts">
import type { Server } from "node:http";
import type { WebSocket, WebSocketServer } from "ws";
import { WebSocket as WS, WebSocketServer as WSS } from "ws";
import config from "@/config";
import logger from "@/logging";
import { type WebSocketMessage, WebSocketMessageSchema } from "@/types";
class WebSocketService
⋮----
start(httpServer: Server)
private async handleMessage(
    message: WebSocketMessage,
    _ws: WebSocket,
): Promise<void>
broadcast(message: WebSocketMessage)
sendToClients(
    message: WebSocketMessage,
    filter?: (client: WebSocket) => boolean,
)
stop()
getClientCount(): number
</file>

<file path="platform/backend/drizzle.config.ts">
import path from "node:path";
import dotenv from "dotenv";
import { defineConfig } from "drizzle-kit";
</file>

<file path="platform/backend/knip.config.ts">
import type { KnipConfig } from "knip";
</file>

<file path="platform/backend/vitest.config.ts">
import path from "node:path";
import { defineConfig } from "vitest/config";
</file>

<file path="platform/dev/Tiltfile.dev">
# Development + pre-requisite resources

# Define is_prod locally (same logic as main Tiltfile)
is_prod = os.getenv('PROD') == 'true'

local_resource(
  'pnpm-install',
  cmd='CI=true pnpm install',
  deps=[
    '../frontend/package.json',
    '../backend/package.json',
  ],
  labels=['dev']
)

if is_prod:
  # prod bundle
  local_resource(
    'pnpm-prod',
    cmd='rm -rf frontend/.next && pnpm build',
    serve_cmd='pnpm start',
    labels=['dev'],
    resource_deps=['db-migrate']
  )
else:
  # dev bundle
  local_resource(
    'pnpm-dev',
    serve_cmd='pnpm dev',
    labels=['dev'],
    resource_deps=['db-migrate']
  )

local_resource(
  'lint:fix',
  cmd='pnpm type-check && pnpm lint:fix',
  labels=['dev'],
  resource_deps=['pnpm-install'],
  deps=[
    "../frontend/src",
    "../backend/src",
    "../experiments/src",
    "../biome.json",
  ]
)

local_resource(
  'lint:fix:unsafe',
  cmd='pnpm lint:fix:unsafe && tilt trigger lint:fix',
  labels=['dev'],
  resource_deps=['pnpm-install'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
)

local_resource(
  'codegen:api-client',
  cmd='pnpm codegen:api-client',
  labels=['dev'],
  resource_deps=['pnpm-install', 'pnpm-dev'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
)
</file>

<file path="platform/dev/Tiltfile.integrations">
# Integration resources

local_resource(
  'n8n',
  serve_cmd='docker compose -f docker-compose-n8n.yml up n8n --no-deps',
  serve_dir='../',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'mcp-inspector',
  serve_env={
    'DANGEROUSLY_OMIT_AUTH': 'true'
  },
  serve_cmd='npx @modelcontextprotocol/inspector --transport http --server-url http://localhost:9000/v1/mcp',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
)

local_resource(
  'orlando-wiremock',
  serve_cmd='docker compose -f ./orlando/docker-compose.yml up wiremock',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'observability',
  serve_cmd='docker compose -f docker-compose.observability.yml up',
  serve_dir='.',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'vault',
  serve_cmd='docker run --rm -p 8200:8200 -e VAULT_DEV_ROOT_TOKEN_ID=dev-root-token -e VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200 --cap-add=IPC_LOCK hashicorp/vault:1.15',
  labels=['integrations'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)
</file>

<file path="platform/dev/Tiltfile.test">
# Test resources

local_resource(
  'unit-tests',
  cmd='pnpm test',
  labels=['test'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  resource_deps=['pnpm-install', 'pnpm-dev']
)

local_resource(
  'helm-tests',
  cmd='helm unittest helm/archestra',
  dir='../',
  labels=['test'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)

local_resource(
  'e2e-tests',
  cmd='pnpm test:e2e',
  labels=['test'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  resource_deps=['pnpm-install', 'pnpm-dev']
)

local_resource(
  'e2e-tests-ui',
  serve_cmd='pnpm test:e2e:ui',
  serve_dir='../',
  labels=['test'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False,
  resource_deps=['pnpm-install', 'pnpm-dev']
)

# E2E test dependencies (WireMock, Keycloak)
# Use a local_resource to deploy/redeploy the helm chart on demand
local_resource(
  'e2e-test-dependencies',
  cmd='helm upgrade --install e2e-tests ../helm/e2e-tests --namespace default --wait',
  labels=['test'],
  trigger_mode=TRIGGER_MODE_MANUAL,
  auto_init=False
)
</file>

<file path="platform/e2e-tests/tests/api/access-control.spec.ts">
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/api/auth-permissions.spec.ts">
import { allAvailableActions, type Permissions } from "@shared";
import {
  type APIRequestContext,
  expect,
  type TestFixtures,
  test,
} from "./fixtures";
⋮----
const makeHasPermissionsRequest = async ({
    request,
    makeApiRequest,
    data,
  }: {
    request: APIRequestContext;
    makeApiRequest: TestFixtures["makeApiRequest"];
    data: {
      permissions: Permissions;
    };
}) =>
</file>

<file path="platform/e2e-tests/tests/api/sso-providers.spec.ts">
import { API_BASE_URL, UI_BASE_URL } from "../../consts";
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/ui/invitation.spec.ts">
import { E2eTestId } from "@shared";
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/ui/sso-providers.spec.ts">
import { UI_BASE_URL } from "../../consts";
import { expect, test } from "./fixtures";
⋮----
async function fetchKeycloakSamlMetadata(): Promise<string>
function extractCertFromMetadata(metadata: string): string
</file>

<file path="platform/e2e-tests/knip.config.ts">
import type { KnipConfig } from "knip";
</file>

<file path="platform/experiments/src/cli-chat.ts">
import { readdirSync, readFileSync } from "node:fs";
import { homedir } from "node:os";
import path, { resolve } from "node:path";
⋮----
import Anthropic from "@anthropic-ai/sdk";
import {
  BedrockRuntimeClient,
  ConverseCommand,
  type ConverseCommandInput,
  ConverseStreamCommand,
  type ConverseStreamCommandInput,
  type Message,
  type Tool,
} from "@aws-sdk/client-bedrock-runtime";
import { GoogleGenAI } from "@google/genai";
import dotenv from "dotenv";
import OpenAI from "openai";
import type { Stream } from "openai/core/streaming";
import type {
  ChatCompletionMessageParam,
  ChatCompletionTool,
} from "openai/resources/chat/completions";
⋮----
type Provider = "openai" | "gemini" | "anthropic" | "bedrock";
const parseArgs = ():
const getToolDefinitions = (): ChatCompletionTool[] =>
const executeToolCall = async (
  toolName: string,
  args: any,
  includeExternalEmail: boolean,
  includeMaliciousEmail: boolean,
): Promise<any> =>
const getAssistantMessageFromStream = async (
  stream: Stream<OpenAI.Chat.Completions.ChatCompletionChunk>,
  shouldPrintPrefix: boolean,
): Promise<OpenAI.Chat.Completions.ChatCompletionMessage> =>
⋮----
// Skip chunks without choices (metadata, end markers, etc.)
⋮----
// Initialize tool call if it doesn't exist
⋮----
// Accumulate tool call fields
⋮----
const printStartMessage = (model: string, provider: Provider) =>
const handleHelpCommand = () =>
const handleExitCommand = () =>
const cliChatWithOpenAI = async (options: {
  includeExternalEmail: boolean;
  includeMaliciousEmail: boolean;
  debug: boolean;
  stream: boolean;
  model: string;
  agentId: string | null;
}) =>
const cliChatWithGemini = async (options: {
  includeExternalEmail: boolean;
  includeMaliciousEmail: boolean;
  debug: boolean;
  stream: boolean;
  model: string;
  agentId: string | null;
}) =>
⋮----
// Check if there are function calls
⋮----
const cliChatWithAnthropic = async (options: {
  includeExternalEmail: boolean;
  includeMaliciousEmail: boolean;
  debug: boolean;
  stream: boolean;
  model: string;
  agentId: string | null;
}) =>
⋮----
// Add assistant message to history
⋮----
const cliChatWithBedrockDirectly = async (options: {
  includeExternalEmail: boolean;
  includeMaliciousEmail: boolean;
  debug: boolean;
  stream: boolean;
  model: string;
  guardrailId: string | null;
  guardrailVersion: string;
}) =>
⋮----
// Add assistant message to history
⋮----
// Check for tool use blocks
⋮----
// Execute each tool call
⋮----
const cliChatWithGuardrails = async () =>
</file>

<file path="platform/frontend/src/app/_parts/forbidden-page.tsx">
export function ForbiddenPage()
</file>

<file path="platform/frontend/src/app/_parts/websocket-initializer.tsx">
import { useEffect } from "react";
import websocketService from "@/lib/websocket";
export function WebsocketInitializer()
</file>

<file path="platform/frontend/src/app/_parts/with-auth-check.test.tsx">
import { render, screen } from "@testing-library/react";
import { usePathname, useRouter } from "next/navigation";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { useHasPermissions } from "@/lib/auth.query";
import { authClient } from "@/lib/clients/auth/auth-client";
import { WithAuthCheck } from "./with-auth-check";
⋮----
const MockChild = () => (
  <div data-testid="protected-content">Protected Content</div>
);
</file>

<file path="platform/frontend/src/app/_parts/with-page-permissions.tsx">
import { requiredPagePermissionsMap } from "@shared";
import { usePathname } from "next/navigation";
import type React from "react";
import { ForbiddenPage } from "@/app/_parts/forbidden-page";
import { useHasPermissions } from "@/lib/auth.query";
</file>

<file path="platform/frontend/src/app/auth/[path]/page.tsx">
import { authViewPaths } from "@daveyplate/better-auth-ui/server";
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { AuthPageWithInvitationCheck } from "@/app/auth/[path]/auth-page-with-invitation-check";
import { LoadingSpinner } from "@/components/loading";
⋮----
export function generateStaticParams()
</file>

<file path="platform/frontend/src/app/auth/sign-up-with-invitation/page.tsx">
import { AuthView } from "@daveyplate/better-auth-ui";
import { useRouter, useSearchParams } from "next/navigation";
import { Suspense, useEffect, useState } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
import { authClient } from "@/lib/clients/auth/auth-client";
import { useInvitationCheck } from "@/lib/invitation.query";
import { useAcceptInvitation } from "@/lib/organization.query";
⋮----
const prefillEmail = () =>
</file>

<file path="platform/frontend/src/app/auth/auth-provider.tsx">
import { AuthUIProvider } from "@daveyplate/better-auth-ui";
import { EMAIL_PLACEHOLDER, PASSWORD_PLACEHOLDER } from "@shared";
import Link from "next/link";
import { useRouter } from "next/navigation";
import type { ReactNode } from "react";
import { authClient } from "@/lib/clients/auth/auth-client";
import { useCustomRoles } from "@/lib/role.query";
</file>

<file path="platform/frontend/src/app/cost/token-price/page.tsx">
import type { archestraApiTypes } from "@shared";
import { Edit, Plus, Save, Settings, Trash2, X } from "lucide-react";
import { useCallback, useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  useCreateTokenPrice,
  useDeleteTokenPrice,
  useTokenPrices,
  useUpdateTokenPrice,
} from "@/lib/token-price.query";
type TokenPriceData = archestraApiTypes.GetTokenPricesResponses["200"][number];
⋮----
const handleDeleteTokenPrice = async (id: string) =>
const handleCreateTokenPrice = async (
    data: archestraApiTypes.CreateTokenPriceData["body"],
) =>
const handleUpdateTokenPrice = async (
    id: string,
    data: archestraApiTypes.UpdateTokenPriceData["body"],
) =>
const handleCancelEdit = () =>
⋮----
onEdit=
</file>

<file path="platform/frontend/src/app/cost/layout.tsx">
import { PageLayout } from "@/components/page-layout";
</file>

<file path="platform/frontend/src/app/logs/mcp-gateway/page.client.tsx">
import type { archestraApiTypes } from "@shared";
import type { ColumnDef, SortingState } from "@tanstack/react-table";
import { ChevronDown, ChevronUp } from "lucide-react";
import { useState } from "react";
import { TruncatedText } from "@/components/truncated-text";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { DataTable } from "@/components/ui/data-table";
import { useProfiles } from "@/lib/agent.query";
import { useMcpToolCalls } from "@/lib/mcp-tool-call.query";
import { DEFAULT_TABLE_LIMIT, formatDate } from "@/lib/utils";
import { ErrorBoundary } from "../../_parts/error-boundary";
type McpToolCallData =
  archestraApiTypes.GetMcpToolCallsResponses["200"]["data"][number];
function SortIcon(
export default function McpGatewayLogsPage({
  initialData,
}: {
  initialData?: {
    mcpToolCalls: archestraApiTypes.GetMcpToolCallsResponses["200"];
    agents: archestraApiTypes.GetAllAgentsResponses["200"];
  };
})
function McpToolCallsTable({
  initialData,
}: {
  initialData?: {
    mcpToolCalls: archestraApiTypes.GetMcpToolCallsResponses["200"];
    agents: archestraApiTypes.GetAllAgentsResponses["200"];
  };
})
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/CatalogFilters.tsx">
import type { archestraCatalogTypes } from "@shared";
import { useState } from "react";
import { Badge } from "@/components/ui/badge";
import { useMcpServerCategories } from "@/lib/external-mcp-catalog.query";
export type ServerType = "all" | "remote" | "local";
export type SelectedCategory =
  | "all"
  | archestraCatalogTypes.GetMcpServerCategoriesResponse["categories"][number];
interface CatalogFiltersProps {
  onFiltersChange: (filters: {
    type: ServerType;
    category: SelectedCategory;
  }) => void;
}
⋮----
const handleTypeChange = (type: ServerType) =>
const handleCategoryToggle = (category: SelectedCategory) =>
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/create-catalog-dialog.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { LOCAL_MCP_DISABLED_MESSAGE } from "@/consts";
import { useFeatureFlag } from "@/lib/features.hook";
import {
  useCreateInternalMcpCatalogItem,
  useInternalMcpCatalog,
} from "@/lib/internal-mcp-catalog.query";
import { cn } from "@/lib/utils";
import { ArchestraCatalogTab } from "./archestra-catalog-tab";
import { McpCatalogForm } from "./mcp-catalog-form";
import type { McpCatalogFormValues } from "./mcp-catalog-form.types";
import { transformFormToApiData } from "./mcp-catalog-form.utils";
interface CreateCatalogDialogProps {
  isOpen: boolean;
  onClose: () => void;
}
type TabType = "archestra-catalog" | "remote" | "local";
⋮----
const handleClose = () =>
const onSubmit = async (values: McpCatalogFormValues) =>
⋮----
onClick=
⋮----
className=
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/custom-server-request-dialog.tsx">
import { zodResolver } from "@hookform/resolvers/zod";
import type { archestraApiTypes } from "@shared";
import { EnvironmentVariableSchema } from "@shared";
import { Loader2 } from "lucide-react";
import { useFieldArray, useForm } from "react-hook-form";
import { z } from "zod";
import { EnvironmentVariablesFormField } from "@/components/environment-variables-form-field";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { useCreateMcpServerInstallationRequest } from "@/lib/mcp-server-installation-request.query";
⋮----
type CustomServerRequestFormValues = z.infer<typeof customServerRequestSchema>;
⋮----
const onSubmit = async (values: CustomServerRequestFormValues) =>
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/details-dialog.tsx">
import type { archestraCatalogTypes } from "@shared";
import {
  BookOpen,
  Calendar,
  Code2,
  ExternalLink,
  FileText,
  Github,
  Globe,
  Info,
  Link,
  Settings,
  Star,
  Terminal,
  Users,
} from "lucide-react";
import type { Components } from "react-markdown";
import ReactMarkdown from "react-markdown";
import rehypeHighlight from "rehype-highlight";
import rehypeRaw from "rehype-raw";
import remarkBreaks from "remark-breaks";
import remarkGfm from "remark-gfm";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
interface DetailsDialogProps {
  server: archestraCatalogTypes.ArchestraMcpServerManifest | null;
  onClose: () => void;
}
⋮----
Default:
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/docker-args-parser.ts">
export function parseDockerArgsToLocalConfig(
  command: string,
  args: string[] | undefined,
  dockerImage: string | undefined,
):
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/edit-catalog-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useUpdateInternalMcpCatalogItem } from "@/lib/internal-mcp-catalog.query";
import { McpCatalogForm } from "./mcp-catalog-form";
import type { McpCatalogFormValues } from "./mcp-catalog-form.types";
import { transformFormToApiData } from "./mcp-catalog-form.utils";
interface EditCatalogDialogProps {
  item: archestraApiTypes.GetInternalMcpCatalogResponses["200"][number] | null;
  onClose: () => void;
}
export function EditCatalogDialog(
⋮----
const handleClose = () =>
const onSubmit = async (values: McpCatalogFormValues) =>
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/manage-teams-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { format } from "date-fns";
import { Building2, Trash, X } from "lucide-react";
import { useEffect, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  useGrantTeamMcpServerAccess,
  useMcpServers,
  useRevokeTeamMcpServerAccess,
} from "@/lib/mcp-server.query";
import { useTeams } from "@/lib/team.query";
type McpServer = archestraApiTypes.GetMcpServersResponses["200"][number];
interface ManageTeamsDialogProps {
  isOpen: boolean;
  onClose: () => void;
  server: McpServer | null | undefined;
  label?: string;
}
⋮----
// Subscribe to live mcp-servers query to get fresh data
⋮----
// Find all servers with the same catalogId and aggregate their team details
⋮----
// Fallback to server teamDetails if available, but add serverId
⋮----
// Find all servers with the same catalogId
⋮----
// Aggregate team details from all servers
⋮----
// Only add if not already present
⋮----
// Get all team-auth servers for this catalogId
⋮----
// Reset state when dialog closes
⋮----
// Get teams that are not already assigned
⋮----
const handleAddTeam = (teamId: string) =>
const handleRemoveSelectedTeam = (teamId: string) =>
const getTeamById = (teamId: string) =>
const getOwnerEmailByServerId = (serverId: string) =>
const handleGrantAccess = async () =>
const handleRevoke = async (teamId: string, serverId?: string) =>
⋮----
// Use the specific serverId from the team details row
⋮----
<Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={() => handleRemoveSelectedTeam(teamId)}
                            className="h-auto p-0.5 ml-1 hover:bg-destructive/20"
                          >
                            <X className="h-3 w-3" />
                          </Button>
                        </Badge>
                      );
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-logs-dialog.tsx">
import {
  ArrowDown,
  Copy,
  Play,
  RefreshCw,
  Square,
  Terminal,
} from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useMcpServerLogs } from "@/lib/mcp-server.query";
interface McpLogsDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  serverName: string;
  installs: {
    id: string;
    name: string;
  }[];
}
⋮----
// State for selected installation
⋮----
// Default to first installation when dialog opens
⋮----
// Fetch logs for selected installation
⋮----
// Use streamed logs when following, otherwise use fetched logs
⋮----
// Auto-scroll to bottom when new logs arrive (with a slight delay to ensure DOM update)
⋮----
const handleScroll = () =>
⋮----
setAutoScroll(true); // Reset auto-scroll when dialog reopens
⋮----
// Cleanup on unmount
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/request-installation-dialog.tsx">
import type { archestraCatalogTypes } from "@shared";
import { Loader2 } from "lucide-react";
import { useCallback, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { useCreateMcpServerInstallationRequest } from "@/lib/mcp-server-installation-request.query";
⋮----
onChange=
</file>

<file path="platform/frontend/src/app/mcp-catalog/installation-requests/[id]/page.tsx">
import {
  ArrowLeft,
  CheckCircle,
  Clock,
  Loader2,
  Send,
  XCircle,
} from "lucide-react";
import Link from "next/link";
import { use, useCallback, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { PermissionButton } from "@/components/ui/permission-button";
import { Separator } from "@/components/ui/separator";
import { Skeleton } from "@/components/ui/skeleton";
import { Textarea } from "@/components/ui/textarea";
import { useHasPermissions } from "@/lib/auth.query";
import {
  useAddMcpServerInstallationRequestNote,
  useApproveMcpServerInstallationRequest,
  useDeclineMcpServerInstallationRequest,
  useMcpServerInstallationRequest,
} from "@/lib/mcp-server-installation-request.query";
</file>

<file path="platform/frontend/src/app/mcp-catalog/installation-requests/page.tsx">
import { CheckCircle, Clock, XCircle } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  type McpServerInstallationRequest,
  useMcpServerInstallationRequests,
} from "@/lib/mcp-server-installation-request.query";
</file>

<file path="platform/frontend/src/app/profiles/page.tsx">
import ProfilesPage from "./page.client";
⋮----
export default async function ProfilesPageServer()
</file>

<file path="platform/frontend/src/app/settings/appearance/_components/logo-upload.tsx">
import { Upload, X } from "lucide-react";
import Image from "next/image";
import { useCallback, useRef, useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { PermissionButton } from "@/components/ui/permission-button";
import { useUpdateOrganization } from "@/lib/organization.query";
interface LogoUploadProps {
  currentLogo?: string | null;
  onLogoChange?: () => void;
}
</file>

<file path="platform/frontend/src/app/settings/appearance/page.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useCallback, useState } from "react";
import { Button } from "@/components/ui/button";
import { PermissionButton } from "@/components/ui/permission-button";
import { useOnUnmount } from "@/lib/lifecycle.hook";
import {
  organizationKeys,
  useUpdateOrganization,
} from "@/lib/organization.query";
import { useOrgTheme } from "@/lib/theme.hook";
import { FontSelector } from "./_components/font-selector";
import { LightDarkToggle } from "./_components/light-dark-toggle";
import { LogoUpload } from "./_components/logo-upload";
import { ThemeSelector } from "./_components/theme-selector";
⋮----
onFontSelect=
</file>

<file path="platform/frontend/src/app/settings/chat/page.tsx">
import { CheckCircle2, Loader2, RotateCcw } from "lucide-react";
import { Suspense, useCallback, useEffect, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  useChatSettings,
  useUpdateChatSettings,
} from "@/lib/chat-settings.query";
⋮----
// Set placeholder dots when API key is configured
⋮----
// Mark as changed if user modified the field
⋮----
// If key exists, changed means it's different from placeholder
⋮----
// If no key exists, any non-empty value is a change
⋮----
// Only send the API key if it's been changed from the placeholder
</file>

<file path="platform/frontend/src/app/settings/sso-providers/_parts/create-sso-provider-dialog.tsx">
import { zodResolver } from "@hookform/resolvers/zod";
import { SsoProviderFormSchema, type SsoProviderFormValues } from "@shared";
import { useCallback } from "react";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Form } from "@/components/ui/form";
import { PermissionButton } from "@/components/ui/permission-button";
import { useCreateSsoProvider } from "@/lib/sso-provider.query";
import { OidcConfigForm } from "./oidc-config-form";
import { SamlConfigForm } from "./saml-config-form";
interface CreateSsoProviderDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  defaultValues?: Partial<SsoProviderFormValues>;
  providerName?: string;
  hidePkce?: boolean;
  hideProviderId?: boolean;
  providerType?: "oidc" | "saml";
}
⋮----
onSubmit=
</file>

<file path="platform/frontend/src/app/settings/sso-providers/_parts/edit-sso-provider-dialog.tsx">
import { zodResolver } from "@hookform/resolvers/zod";
import { SsoProviderFormSchema, type SsoProviderFormValues } from "@shared";
import { Trash2 } from "lucide-react";
import { useCallback, useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import {
  AlertDialog,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Form } from "@/components/ui/form";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  useDeleteSsoProvider,
  useSsoProvider,
  useUpdateSsoProvider,
} from "@/lib/sso-provider.query";
import { OidcConfigForm } from "./oidc-config-form";
interface EditSsoProviderDialogProps {
  ssoProviderId: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
⋮----
onSubmit=
⋮----
onClick=
</file>

<file path="platform/frontend/src/app/settings/sso-providers/_parts/oidc-config-form.tsx">
import type { SsoProviderFormValues } from "@shared";
import { Plus, X } from "lucide-react";
import { useCallback, useState } from "react";
import type { UseFormReturn } from "react-hook-form";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
interface OidcConfigFormProps {
  form: UseFormReturn<SsoProviderFormValues>;
  hidePkce?: boolean;
  hideProviderId?: boolean;
}
⋮----
<button
</file>

<file path="platform/frontend/src/app/settings/sso-providers/_parts/saml-config-form.tsx">
import type { SsoProviderFormValues } from "@shared";
import type { UseFormReturn } from "react-hook-form";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Textarea } from "@/components/ui/textarea";
interface SamlConfigFormProps {
  form: UseFormReturn<SsoProviderFormValues>;
  hideProviderId?: boolean;
}
</file>

<file path="platform/frontend/src/app/settings/sso-providers/page.tsx">
import {
  SSO_PROVIDER_ID,
  SSO_TRUSTED_PROVIDER_IDS,
  type SsoProviderId,
} from "@shared";
import { Suspense, useCallback, useState } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { LoadingSpinner } from "@/components/loading";
import { SsoProviderIcon } from "@/components/sso-provider-icons";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useSsoProviders } from "@/lib/sso-provider.query";
import { CreateSsoProviderDialog } from "./_parts/create-sso-provider-dialog";
import { EditSsoProviderDialog } from "./_parts/edit-sso-provider-dialog";
interface SsoProviderConfig {
  id: string;
  providerId: string;
  name: string;
  description: string;
  bgColor: string;
  hideProviderId: boolean;
  disablePkce?: boolean;
  providerType: "oidc" | "saml";
  defaultOidcConfig?: {
    issuer: string;
    discoveryEndpoint: string;
    authorizationEndpoint?: string;
    tokenEndpoint?: string;
    userInfoEndpoint?: string;
    jwksEndpoint?: string;
    scopes: string[];
    mapping: {
      id: string;
      email: string;
      name: string;
    };
  };
  defaultSamlConfig?: {
    issuer: string;
    entryPoint: string;
    cert: string;
    callbackUrl: string;
    mapping?: {
      id?: string;
      email?: string;
      name?: string;
      firstName?: string;
      lastName?: string;
    };
  };
}
⋮----
type SsoProvider = NonNullable<
  ReturnType<typeof useSsoProviders>["data"]
>[number];
function SsoProvidersSettingsContent()
⋮----
onOpenChange=
</file>

<file path="platform/frontend/src/app/settings/layout.tsx">
import { PageLayout } from "@/components/page-layout";
import { useHasPermissions } from "@/lib/auth.query";
export default function SettingsLayout({
  children,
}: {
  children: React.ReactNode;
})
</file>

<file path="platform/frontend/src/components/ai-elements/tool.tsx">
import type { ToolUIPart } from "ai";
import {
  CheckCircleIcon,
  ChevronDownIcon,
  CircleIcon,
  ClockIcon,
  WrenchIcon,
  XCircleIcon,
} from "lucide-react";
import type { ComponentProps, ReactNode } from "react";
import { Badge } from "@/components/ui/badge";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
import { CodeBlock } from "./code-block";
export type ToolProps = ComponentProps<typeof Collapsible>;
export const Tool = ({ className, ...props }: ToolProps) => (
  <Collapsible
    defaultOpen={false}
    className={cn("not-prose mb-4 w-full rounded-md border", className)}
    {...props}
  />
);
⋮----
className=
⋮----
export type ToolHeaderProps = {
  title?: string;
  type: ToolUIPart["type"];
  state: ToolUIPart["state"] | "output-available-dual-llm";
  className?: string;
  icon?: React.ReactNode;
  errorText?: ToolUIPart["errorText"];
  isCollapsible?: boolean;
};
const getStatusBadge = (
  status: ToolUIPart["state"] | "output-available-dual-llm",
) =>
⋮----

⋮----
export const ToolInput = ({ className, input, ...props }: ToolInputProps) => (
  <div className={cn("space-y-2 overflow-hidden p-4", className)} {...props}>
    <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
      Parameters
    </h4>
    <div className="rounded-md bg-muted/50">
      <CodeBlock code={JSON.stringify(input, null, 2)} language="json" />
    </div>
  </div>
);
⋮----
<div className=
⋮----
<CodeBlock code=
</file>

<file path="platform/frontend/src/components/chat/stream-timeout-warning.tsx">
import type { UIMessage } from "@ai-sdk/react";
import { AlertTriangle } from "lucide-react";
import { useEffect, useRef, useState } from "react";
interface StreamTimeoutWarningProps {
  status: "ready" | "submitted" | "streaming" | "error";
  messages: UIMessage[];
  thresholdSeconds?: number;
  checkIntervalSeconds?: number;
}
export function StreamTimeoutWarning({
  status,
  messages,
  thresholdSeconds = 40,
  checkIntervalSeconds = 3,
}: StreamTimeoutWarningProps)
</file>

<file path="platform/frontend/src/components/ui/button-group.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { Separator } from "@/components/ui/separator";
import { cn } from "@/lib/utils";
⋮----
function ButtonGroup({
  className,
  orientation,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof buttonGroupVariants>)
⋮----
className=
</file>

<file path="platform/frontend/src/components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
export type ButtonProps = React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  };
⋮----
className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
</file>

<file path="platform/frontend/src/components/ui/multi-select.tsx">
import { Check, ChevronDown, Search, X } from "lucide-react";
⋮----
import { Badge } from "@/components/ui/badge";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
interface MultiSelectProps {
  value: string[];
  onValueChange: (value: string[]) => void;
  placeholder?: string;
  items: Array<{ value: string; label: string }>;
  className?: string;
  disabled?: boolean;
}
⋮----
const handleToggleItem = (itemValue: string) =>
const handleRemoveItem = (
    itemValue: string,
    e: React.MouseEvent | React.KeyboardEvent,
) =>
⋮----
className=
⋮----
onClick=
</file>

<file path="platform/frontend/src/components/ui/tooltip-button.tsx">
import type React from "react";
import { Button, type ButtonProps } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
type Props = {
  tooltip: string;
  onClick: (e: React.MouseEvent) => void;
} & Omit<ButtonProps, "onClick">;
</file>

<file path="platform/frontend/src/components/ui/tooltip.tsx">
import { cn } from "@/lib/utils";
⋮----
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>)
</file>

<file path="platform/frontend/src/components/agent-labels.tsx">
import { Plus, X } from "lucide-react";
import { forwardRef, useCallback, useImperativeHandle, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useLabelValues } from "@/lib/agent.query";
export interface ProfileLabel {
  key: string;
  value: string;
  keyId?: string;
  valueId?: string;
}
interface ProfileLabelsProps {
  labels: ProfileLabel[];
  onLabelsChange: (labels: ProfileLabel[]) => void;
  availableKeys?: string[];
}
export interface ProfileLabelsRef {
  saveUnsavedLabel: () => ProfileLabel[] | null;
}
⋮----
// Fetch values for the current key (only if key is not empty)
⋮----
// Check if key already exists
⋮----
// Update existing label
⋮----
// Add new label
</file>

<file path="platform/frontend/src/components/connection-options.tsx">
import { McpConnectionInstructions } from "@/components/mcp-connection-instructions";
import { ProxyConnectionInstructions } from "@/components/proxy-connection-instructions";
interface ConnectionOptionsProps {
  agentId?: string;
}
export function ConnectionOptions(
</file>

<file path="platform/frontend/src/components/default-credentials-warning.tsx">
import { DEFAULT_ADMIN_EMAIL, DEFAULT_ADMIN_PASSWORD } from "@shared";
import { Copy, Link } from "lucide-react";
import { useState } from "react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { useDefaultCredentialsEnabled } from "@/lib/auth.query";
import { authClient } from "@/lib/clients/auth/auth-client";
export function DefaultCredentialsWarning({
  alwaysShow = false,
}: {
  alwaysShow?: boolean;
})
⋮----
const copyToClipboard = async (text: string, type: "email" | "password") =>
⋮----
onClick={() => copyToClipboard(DEFAULT_ADMIN_EMAIL, "email")}
            >
              <Copy size={10} />
            </Button>
            {copiedEmail && <span className="ml-1 text-xs">Copied!</span>}
          </div>
          <div className="flex items-center gap-1">
            <code className="break-all">- {DEFAULT_ADMIN_PASSWORD}</code>
            <Button
              variant="ghost"
              size="sm"
              className="h-4 w-4 p-0 hover:bg-transparent"
onClick=
</file>

<file path="platform/frontend/src/components/installation-select.tsx">
import { useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useProfileAvailableTokens } from "@/lib/mcp-server.query";
import { cn } from "@/lib/utils";
import { LoadingSpinner } from "./loading";
interface InstallationSelectProps {
  value?: string | null;
  onValueChange: (value: string | null) => void;
  disabled?: boolean;
  className?: string;
  catalogId: string;
  shouldSetDefaultValue: boolean;
}
</file>

<file path="platform/frontend/src/components/invitations-list.tsx">
import { QueryErrorResetBoundary, useQueryClient } from "@tanstack/react-query";
import { Copy, Mail, Trash2 } from "lucide-react";
import { Suspense } from "react";
import { ErrorBoundary } from "react-error-boundary";
import { toast } from "sonner";
import { LoadingSpinner } from "@/components/loading";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { PermissionButton } from "@/components/ui/permission-button";
import { TooltipButton } from "@/components/ui/tooltip-button";
import {
  organizationKeys,
  useCancelInvitation,
  useInvitationsList,
} from "@/lib/organization.query";
⋮----
const handleCopy = async (id: string, email: string) =>
const handleDelete = async (invitationId: string) =>
</file>

<file path="platform/frontend/src/components/onboarding-dialog.tsx">
import { E2eTestId } from "@shared";
import { CheckCircle2, Loader2 } from "lucide-react";
import { useCallback, useState } from "react";
import { ArchestraArchitectureDiagram } from "@/components/archestra-architecture-diagram";
import { ConnectionOptions } from "@/components/connection-options";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useDefaultProfile } from "@/lib/agent.query";
import {
  useOrganizationOnboardingStatus,
  useUpdateOrganization,
} from "@/lib/organization.query";
import { cn } from "@/lib/utils";
interface OnboardingDialogProps {
  open: boolean;
}
</file>

<file path="platform/frontend/src/components/page-layout.tsx">
import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
⋮----
className=
</file>

<file path="platform/frontend/src/components/proxy-connection-instructions.tsx">
import type { archestraApiTypes } from "@shared";
import { Check, Copy } from "lucide-react";
import { useCallback, useState } from "react";
import { toast } from "sonner";
import { CodeText } from "@/components/code-text";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import config from "@/lib/config";
⋮----
interface ProxyConnectionInstructionsProps {
  agentId?: string;
}
</file>

<file path="platform/frontend/src/components/sso-provider-icons.tsx">
import { SSO_PROVIDER_ID } from "@shared";
import { Globe } from "lucide-react";
import Image from "next/image";
interface SsoProviderIconProps {
  providerId: string;
  size?: number;
  className?: string;
}
</file>

<file path="platform/frontend/src/components/sso-provider-selector.tsx">
import { useCallback } from "react";
import { toast } from "sonner";
import { SsoProviderIcon } from "@/components/sso-provider-icons";
import { Button } from "@/components/ui/button";
import { authClient } from "@/lib/clients/auth/auth-client";
import { usePublicSsoProviders } from "@/lib/sso-provider.query";
export function SsoProviderSelector()
</file>

<file path="platform/frontend/src/components/token-select.tsx">
import { useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useProfileAvailableTokens } from "@/lib/mcp-server.query";
import { cn } from "@/lib/utils";
import { LoadingSpinner } from "./loading";
interface TokenSelectProps {
  value?: string | null;
  onValueChange: (value: string | null) => void;
  disabled?: boolean;
  className?: string;
  catalogId: string;
  shouldSetDefaultValue: boolean;
}
</file>

<file path="platform/frontend/src/contexts/global-chat-context.tsx">
import { type UIMessage, useChat } from "@ai-sdk/react";
import { TOOL_CREATE_MCP_SERVER_INSTALLATION_REQUEST_FULL_NAME } from "@shared";
import { useQueryClient } from "@tanstack/react-query";
import { DefaultChatTransport } from "ai";
import {
  createContext,
  type ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
⋮----
interface ChatSession {
  conversationId: string;
  messages: UIMessage[];
  sendMessage: (
    message: Parameters<ReturnType<typeof useChat>["sendMessage"]>[0],
  ) => void;
  stop: () => void;
  status: "ready" | "submitted" | "streaming" | "error";
  error: Error | undefined;
  setMessages: (messages: UIMessage[]) => void;
  addToolResult: ReturnType<typeof useChat>["addToolResult"];
  lastAccessTime: number;
  pendingCustomServerToolCall: {
    toolCallId: string;
    toolName: string;
  } | null;
  setPendingCustomServerToolCall: (
    value: { toolCallId: string; toolName: string } | null,
  ) => void;
}
interface ChatContextValue {
  registerSession: (conversationId: string) => void;
  getSession: (conversationId: string) => ChatSession | undefined;
  clearSession: (conversationId: string) => void;
  notifySessionUpdate: () => void;
}
⋮----
export function ChatProvider(
</file>

<file path="platform/frontend/src/lib/auth.utils.ts">
import type { Permissions } from "@shared";
import { authClient } from "@/lib/clients/auth/auth-client";
export const hasPermission = async (permissions: Permissions) =>
export function permissionsToStrings(permissions: Permissions): string[]
</file>

<file path="platform/frontend/src/lib/dual-llm-config.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
⋮----
export function useDualLlmConfig(params?: {
  initialData?: archestraApiTypes.GetDefaultDualLlmConfigResponses["200"];
})
export function useUpdateDualLlmConfig()
</file>

<file path="platform/frontend/src/lib/external-mcp-catalog.query.ts">
import { archestraCatalogSdk, type archestraCatalogTypes } from "@shared";
import { useInfiniteQuery, useQuery } from "@tanstack/react-query";
import type { SelectedCategory } from "@/app/mcp-catalog/_parts/CatalogFilters";
type SearchResponse =
  archestraCatalogTypes.SearchMcpServerCatalogResponses[200];
type CategoryType = NonNullable<
  archestraCatalogTypes.SearchMcpServerCatalogData["query"]
>["category"];
export function useMcpRegistryServersInfinite(
  search?: string,
  category?: SelectedCategory,
  limit = 50,
)
export function useMcpRegistryServer(serverName: string | null)
export function useMcpServerCategories()
</file>

<file path="platform/frontend/src/lib/interaction.utils.ts">
import type { archestraApiTypes } from "@shared";
import type { PartialUIMessage } from "@/components/chatbot-demo";
import AnthropicMessagesInteraction from "./llmProviders/anthropic";
import type {
  DualLlmResult,
  Interaction,
  InteractionUtils,
} from "./llmProviders/common";
import GeminiGenerateContentInteraction from "./llmProviders/gemini";
import OpenAiChatCompletionInteraction from "./llmProviders/openai";
export class DynamicInteraction implements InteractionUtils
⋮----
constructor(interaction: Interaction)
private getInteractionClass(interaction: Interaction): InteractionUtils
isLastMessageToolCall(): boolean
getLastToolCallId(): string | null
getToolNamesRefused(): string[]
getToolNamesRequested(): string[]
getToolNamesUsed(): string[]
getToolRefusedCount(): number
getLastUserMessage(): string
getLastAssistantResponse(): string
mapToUiMessages(dualLlmResults?: DualLlmResult[]): PartialUIMessage[]
getToonSavings():
</file>

<file path="platform/frontend/src/lib/invitation.query.ts">
import { useQuery } from "@tanstack/react-query";
export type InvitationCheckResponse = {
  invitation: {
    id: string;
    email: string;
    organizationId: string;
    status: "pending" | "accepted" | "canceled";
    expiresAt: string | null;
  };
  userExists: boolean;
};
export function useInvitationCheck(invitationId: string | null | undefined)
</file>

<file path="platform/frontend/src/lib/limits.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
⋮----
export function useLimits(params?: {
  entityType?: "team" | "organization" | "agent";
  entityId?: string;
  limitType?: "token_cost" | "mcp_server_calls" | "tool_calls";
})
export function useLimit(id: string)
export function useCreateLimit()
export function useUpdateLimit()
export function useDeleteLimit()
</file>

<file path="platform/frontend/src/lib/mcp-server.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
import { toast } from "sonner";
⋮----
export function useMcpServers(params?: {
  initialData?: archestraApiTypes.GetMcpServersResponses["200"];
  hasInstallingServers?: boolean;
})
export function useInstallMcpServer()
export function useDeleteMcpServer()
export function useRevokeUserMcpServerAccess()
export function useGrantTeamMcpServerAccess()
export function useRevokeTeamMcpServerAccess()
export function useRevokeAllTeamsMcpServerAccess()
export function useMcpServerTools(mcpServerId: string | null)
export function useMcpServerInstallationStatus(
  installingMcpServerId: string | null,
)
export function useProfileAvailableTokens(params:
export function useMcpServerLogs(mcpServerId: string | null)
</file>

<file path="platform/frontend/src/lib/optimization-rule.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
⋮----
export type OptimizationRule =
  archestraApiTypes.CreateOptimizationRuleResponses["200"];
export type CreateOptimizationRuleInput =
  archestraApiTypes.CreateOptimizationRuleData["body"];
export type UpdateOptimizationRuleInput = Partial<
  archestraApiTypes.UpdateOptimizationRuleData["body"]
> &
  archestraApiTypes.UpdateOptimizationRuleData["path"];
export function useOptimizationRules()
export function useCreateOptimizationRule()
export function useUpdateOptimizationRule()
export function useDeleteOptimizationRule()
</file>

<file path="platform/frontend/src/lib/sso-provider.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
⋮----
export function usePublicSsoProviders()
export function useSsoProviders()
export function useSsoProvider(id: string)
export function useCreateSsoProvider()
export function useUpdateSsoProvider()
export function useDeleteSsoProvider()
</file>

<file path="platform/frontend/src/lib/websocket.ts">
import type { archestraApiTypes } from "@shared";
import config from "@/lib/config";
type WebSocketMessage = archestraApiTypes.WebSocketMessage;
type MessageHandler<T extends WebSocketMessage = WebSocketMessage> = (
  message: T,
) => void;
class WebSocketService
⋮----
async connect(): Promise<void>
private scheduleReconnect(): void
disconnect(): void
subscribe<T extends WebSocketMessage["type"]>(
    type: T,
    handler: MessageHandler<Extract<WebSocketMessage, { type: T }>>,
): () => void
private handleMessage(message: WebSocketMessage): void
isConnected(): boolean
send(message: WebSocketMessage): void
</file>

<file path="platform/frontend/knip.config.ts">
import type { KnipConfig } from "knip";
</file>

<file path="platform/frontend/next.config.ts">
import { withSentryConfig } from "@sentry/nextjs";
import { MCP_CATALOG_API_BASE_URL } from "@shared";
import type { NextConfig } from "next";
⋮----
async rewrites()
</file>

<file path="platform/frontend/sentry.edge.config.ts">

</file>

<file path="platform/frontend/sentry.server.config.ts">

</file>

<file path="platform/frontend/vitest-setup.ts">

</file>

<file path="platform/frontend/vitest.config.ts">
import tsconfigPaths from "vite-tsconfig-paths";
import { defineConfig } from "vitest/config";
</file>

<file path="platform/shared/knip.config.ts">
import type { KnipConfig } from "knip";
</file>

<file path="platform/docker-banner.sh">
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'
FRONTEND_URL="${ARCHESTRA_FRONTEND_URL:-http://localhost:3000}"
BACKEND_URL="${ARCHESTRA_API_BASE_URL:-http://localhost:9000}"
echo ""
printf "${GREEN}  Welcome to Archestra! <3 ${NC}\n"
echo ""
printf "   > ${BOLD}Frontend:${NC} ${FRONTEND_URL}\n"
printf "   > ${BOLD}Backend:${NC}  ${BACKEND_URL}\n"
echo ""
echo "   Our team is working hard to make Archestra great for you!"
echo "   Please reach out to us with any questions, requests or feedback"
echo ""
printf "   ${BLUE}Slack Community:${NC} https://join.slack.com/t/archestracommunity/shared_invite/zt-39yk4skox-zBF1NoJ9u4t59OU8XxQChg\n"
printf "   ${BLUE}Give us a star on GitHub:${NC} https://github.com/archestra-ai/archestra\n"
echo ""
echo ""
</file>

<file path=".gitignore">
# Local Claude settings
**/.claude/settings.local.json

# Editor directories and files
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.log
</file>

<file path="platform/backend/src/auth/fastify-plugin/middleware.ts">
import { type RouteId, requiredEndpointPermissionsMap } from "@shared";
import type { FastifyReply, FastifyRequest } from "fastify";
import { betterAuth, hasPermission } from "@/auth";
import config from "@/config";
import { UserModel } from "@/models";
import { ApiError } from "@/types";
export class Authnz
</file>

<file path="platform/backend/src/database/schemas/agent-tool.ts">
import {
  boolean,
  pgTable,
  text,
  timestamp,
  unique,
  uuid,
} from "drizzle-orm/pg-core";
import type { ToolResultTreatment } from "@/types";
import agentsTable from "./agent";
import mcpServerTable from "./mcp-server";
import toolsTable from "./tool";
</file>

<file path="platform/backend/src/database/schemas/interaction.ts">
import {
  index,
  integer,
  jsonb,
  numeric,
  pgTable,
  timestamp,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import type {
  InteractionRequest,
  InteractionResponse,
  SupportedProviderDiscriminator,
} from "@/types";
import agentsTable from "./agent";
</file>

<file path="platform/backend/src/database/schemas/internal-mcp-catalog.ts">
import {
  boolean,
  jsonb,
  pgTable,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import type { InternalMcpCatalogServerType } from "@/types";
</file>

<file path="platform/backend/src/database/schemas/optimization-rule.ts">
import {
  boolean,
  index,
  jsonb,
  pgTable,
  text,
  timestamp,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import type {
  OptimizationRuleConditions,
  OptimizationRuleEntityType,
  OptimizationRuleType,
  SupportedProvider,
} from "@/types";
</file>

<file path="platform/backend/src/database/schemas/tool-invocation-policy.ts">
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import type { AutonomyPolicyOperator, ToolInvocation } from "@/types";
import agentToolsTable from "./agent-tool";
</file>

<file path="platform/backend/src/database/schemas/trusted-data-policy.ts">
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import type { AutonomyPolicyOperator, TrustedData } from "@/types";
import agentToolsTable from "./agent-tool";
</file>

<file path="platform/backend/src/mcp-server-runtime/k8s-pod.test.ts">
import type { Attach, Log } from "@kubernetes/client-node";
import type { LocalConfigSchema } from "@shared";
import { vi } from "vitest";
import type { z } from "zod";
import { describe, expect, test } from "@/test";
import type { McpServer } from "@/types";
import K8sPod from "./k8s-pod";
function createK8sPodInstance(
  environmentValues?: Record<string, string | number | boolean>,
  userConfigValues?: Record<string, string>,
): K8sPod
⋮----
function createMockK8sPod(
    mcpServer: McpServer,
    userConfigValues?: Record<string, string>,
    environmentValues?: Record<string, string>,
): K8sPod
⋮----
function createK8sPodWithMockedApi(
    mockK8sApi: Partial<k8s.CoreV1Api>,
    secretData?: Record<string, string>,
): K8sPod
</file>

<file path="platform/backend/src/models/mcp-server-installation-request.ts">
import { randomUUID } from "node:crypto";
import type { archestraCatalogTypes } from "@shared";
import { archestraCatalogSdk } from "@shared";
import { and, desc, eq } from "drizzle-orm";
import config from "@/config";
import db, { schema } from "@/database";
import logger from "@/logging";
import type {
  InsertMcpServerInstallationRequest,
  McpServerInstallationRequest,
  McpServerInstallationRequestStatus,
  UpdateMcpServerInstallationRequest,
} from "@/types";
import InternalMcpCatalogModel from "./internal-mcp-catalog";
function rewriteOAuthRedirectUris(
  oauthConfig?: archestraCatalogTypes.ArchestraMcpServerManifest["oauth_config"],
):
  | archestraCatalogTypes.ArchestraMcpServerManifest["oauth_config"]
  | undefined {
if (!oauthConfig || oauthConfig.requires_proxy)
class McpServerInstallationRequestModel
⋮----
static async create(
    requestedBy: string,
    request: Omit<InsertMcpServerInstallationRequest, "requestedBy">,
): Promise<McpServerInstallationRequest>
static async findAll(): Promise<McpServerInstallationRequest[]>
static async findById(
    id: string,
): Promise<McpServerInstallationRequest | null>
static async findByStatus(
    status: McpServerInstallationRequestStatus,
): Promise<McpServerInstallationRequest[]>
static async findByRequestedBy(
    userId: string,
): Promise<McpServerInstallationRequest[]>
static async findByExternalCatalogId(
    externalCatalogId: string,
): Promise<McpServerInstallationRequest[]>
static async findPendingByExternalCatalogId(
    externalCatalogId: string,
): Promise<McpServerInstallationRequest | null>
static async update(
    id: string,
    request: Partial<UpdateMcpServerInstallationRequest>,
): Promise<McpServerInstallationRequest | null>
static async approve(
    id: string,
    reviewedBy: string,
    adminResponse?: string,
): Promise<McpServerInstallationRequest | null>
static async decline(
    id: string,
    reviewedBy: string,
    adminResponse?: string,
): Promise<McpServerInstallationRequest | null>
static async addNote(
    id: string,
    userId: string,
    userName: string,
    content: string,
): Promise<McpServerInstallationRequest | null>
static async delete(id: string): Promise<boolean>
</file>

<file path="platform/backend/src/models/tool-invocation-policy.test.ts">
import { beforeEach, describe, expect, test } from "@/test";
import AgentToolModel from "./agent-tool";
import ToolModel from "./tool";
import ToolInvocationPolicyModel from "./tool-invocation-policy";
</file>

<file path="platform/backend/src/models/tool-invocation-policy.ts">
import { and, desc, eq, getTableColumns } from "drizzle-orm";
import { get } from "lodash-es";
import { isArchestraMcpServerTool } from "@/archestra-mcp-server";
import db, { schema } from "@/database";
import type { ToolInvocation } from "@/types";
import AgentToolModel from "./agent-tool";
type EvaluationResult = {
  isAllowed: boolean;
  reason: string;
};
class ToolInvocationPolicyModel
⋮----
static async create(
    policy: ToolInvocation.InsertToolInvocationPolicy,
): Promise<ToolInvocation.ToolInvocationPolicy>
static async findAll(): Promise<ToolInvocation.ToolInvocationPolicy[]>
static async findById(
    id: string,
): Promise<ToolInvocation.ToolInvocationPolicy | null>
static async update(
    id: string,
    policy: Partial<ToolInvocation.InsertToolInvocationPolicy>,
): Promise<ToolInvocation.ToolInvocationPolicy | null>
static async delete(id: string): Promise<boolean>
static async evaluate(
    agentId: string,
    toolName: string,
    toolInput: Record<string, any>,
    isContextTrusted: boolean,
): Promise<EvaluationResult>
⋮----
// If context is untrusted and we don't have an explicit allow rule, block
</file>

<file path="platform/backend/src/models/trusted-data-policy.test.ts">
import { AgentToolModel, ToolModel } from "@/models";
import { beforeEach, describe, expect, test } from "@/test";
import TrustedDataPolicyModel from "./trusted-data-policy";
</file>

<file path="platform/backend/src/models/trusted-data-policy.ts">
import { and, desc, eq, inArray } from "drizzle-orm";
import { get } from "lodash-es";
import { isArchestraMcpServerTool } from "@/archestra-mcp-server";
import db, { schema } from "@/database";
import type { AutonomyPolicyOperator, TrustedData } from "@/types";
class TrustedDataPolicyModel
⋮----
static async create(
    policy: TrustedData.InsertTrustedDataPolicy,
): Promise<TrustedData.TrustedDataPolicy>
static async findAll(): Promise<TrustedData.TrustedDataPolicy[]>
static async findById(
    id: string,
): Promise<TrustedData.TrustedDataPolicy | null>
static async update(
    id: string,
    policy: Partial<TrustedData.InsertTrustedDataPolicy>,
): Promise<TrustedData.TrustedDataPolicy | null>
static async delete(id: string): Promise<boolean>
private static extractValuesFromPath(obj: any, path: string): any[]
private static evaluateCondition(
    value: any,
    operator: AutonomyPolicyOperator.SupportedOperator,
    policyValue: string,
): boolean
static async evaluate(
    agentId: string,
    toolName: string,
    toolOutput: any,
): Promise<
static async evaluateBulk(
    agentId: string,
    toolCalls: Array<{
      toolName: string;
      toolOutput: any;
    }>,
  ): Promise<
    Map<
      string,
      {
        isTrusted: boolean;
        isBlocked: boolean;
        shouldSanitizeWithDualLlm: boolean;
        reason: string;
      }
    >
  > {
    const results = new Map<
      string,
      {
        isTrusted: boolean;
        isBlocked: boolean;
        shouldSanitizeWithDualLlm: boolean;
        reason: string;
      }
    >();
</file>

<file path="platform/backend/src/routes/proxy/utils/index.ts">
import { AgentModel } from "@/models";
export const getAgentIdFromRequest = async (
  userAgentHeader?: string,
): Promise<string>
</file>

<file path="platform/backend/src/routes/proxy/utils/toon-conversion.ts">
import { inArray } from "drizzle-orm";
import db, { schema } from "@/database";
import logger from "@/logging";
import { AgentTeamModel, OrganizationModel, TeamModel } from "@/models";
export interface CompressionStats {
  toonTokensBefore: number | null;
  toonTokensAfter: number | null;
  toonCostSavings: number | null;
}
export async function shouldApplyToonCompression(
  agentId: string,
): Promise<boolean>
</file>

<file path="platform/backend/src/routes/proxy/utils/trusted-data.test.ts">
import { AgentToolModel, ToolModel, TrustedDataPolicyModel } from "@/models";
import { beforeEach, describe, expect, test } from "@/test";
import type { CommonMessage, Tool } from "@/types";
import { evaluateIfContextIsTrusted } from "./trusted-data";
</file>

<file path="platform/backend/src/routes/agent.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { initializeMetrics } from "@/llm-metrics";
import { AgentLabelModel, AgentModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  createPaginatedResponseSchema,
  createSortingQuerySchema,
  DeleteObjectResponseSchema,
  InsertAgentSchema,
  PaginationQuerySchema,
  SelectAgentSchema,
  UpdateAgentSchema,
  UuidIdSchema,
} from "@/types";
const agentRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/tool.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { ToolModel } from "@/models";
import { constructResponseSchema, ExtendedSelectToolSchema } from "@/types";
const toolRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/user.ts">
import { PermissionsSchema, RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { MemberModel, OrganizationRoleModel } from "@/models";
import { ApiError, constructResponseSchema } from "@/types";
const userRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/standalone-scripts/seed-mock-data.ts">
import { pathToFileURL } from "node:url";
import { ADMIN_ROLE_NAME, MEMBER_ROLE_NAME } from "@shared";
import db, { schema } from "@/database";
import { seedDefaultUserAndOrg } from "@/database/seed";
import logger from "@/logging";
import { AgentModel, OrganizationModel, TeamModel, ToolModel } from "@/models";
import {
  generateMockAgents,
  generateMockInteractions,
  generateMockTools,
} from "./mocks";
⋮----
async function seedMockData()
</file>

<file path="platform/backend/src/types/agent-tool.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { UuidIdSchema } from "./api";
import { ToolParametersContentSchema } from "./tool";
⋮----
export type AgentTool = z.infer<typeof SelectAgentToolSchema>;
export type InsertAgentTool = z.infer<typeof InsertAgentToolSchema>;
export type UpdateAgentTool = z.infer<typeof UpdateAgentToolSchema>;
export type ToolResultTreatment = z.infer<typeof ToolResultTreatmentSchema>;
export type AgentToolFilters = z.infer<typeof AgentToolFilterSchema>;
export type AgentToolSortBy = z.infer<typeof AgentToolSortBySchema>;
export type AgentToolSortDirection = z.infer<
  typeof AgentToolSortDirectionSchema
>;
⋮----
export type BulkUpdateAgentToolsRequest = z.infer<
  typeof BulkUpdateAgentToolsRequestSchema
>;
export type BulkUpdateAgentToolsResponse = z.infer<
  typeof BulkUpdateAgentToolsResponseSchema
>;
</file>

<file path="platform/backend/src/types/prompt.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";
⋮----
export type Prompt = z.infer<typeof SelectPromptSchema>;
export type InsertPrompt = z.infer<typeof InsertPromptSchema>;
export type UpdatePrompt = z.infer<typeof UpdatePromptSchema>;
</file>

<file path="platform/backend/src/types/tool.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { OpenAi } from "./llm-providers";
⋮----
export type Tool = z.infer<typeof SelectToolSchema>;
export type ExtendedTool = z.infer<typeof ExtendedSelectToolSchema>;
export type InsertTool = z.infer<typeof InsertToolSchema>;
export type UpdateTool = z.infer<typeof UpdateToolSchema>;
export type ToolParametersContent = z.infer<typeof ToolParametersContentSchema>;
</file>

<file path="platform/backend/tsdown.config.ts">
import { defineConfig, type UserConfig } from "tsdown";
</file>

<file path="platform/e2e-tests/tests/api/fixtures.ts">
import { type APIRequestContext, test as base } from "@playwright/test";
import { API_BASE_URL, UI_BASE_URL } from "../../consts";
export interface TestFixtures {
  makeApiRequest: typeof makeApiRequest;
  createAgent: typeof createAgent;
  deleteAgent: typeof deleteAgent;
  createApiKey: typeof createApiKey;
  deleteApiKey: typeof deleteApiKey;
  createToolInvocationPolicy: typeof createToolInvocationPolicy;
  deleteToolInvocationPolicy: typeof deleteToolInvocationPolicy;
  createTrustedDataPolicy: typeof createTrustedDataPolicy;
  deleteTrustedDataPolicy: typeof deleteTrustedDataPolicy;
  createMcpCatalogItem: typeof createMcpCatalogItem;
  deleteMcpCatalogItem: typeof deleteMcpCatalogItem;
  installMcpServer: typeof installMcpServer;
  uninstallMcpServer: typeof uninstallMcpServer;
  createRole: typeof createRole;
  deleteRole: typeof deleteRole;
}
const makeApiRequest = async ({
  request,
  method,
  urlSuffix,
  data = null,
  headers = {
    "Content-Type": "application/json",
    Origin: UI_BASE_URL,
  },
  ignoreStatusCheck = false,
}: {
  request: APIRequestContext;
  method: "get" | "post" | "put" | "patch" | "delete";
  urlSuffix: string;
  data?: unknown;
  headers?: Record<string, string>;
  ignoreStatusCheck?: boolean;
}) =>
const createAgent = async (request: APIRequestContext, name: string)
const deleteAgent = async (request: APIRequestContext, agentId: string)
const createApiKey = async (
  request: APIRequestContext,
  name: string = "Test API Key",
)
const deleteApiKey = async (request: APIRequestContext, keyId: string)
const createToolInvocationPolicy = async (
  request: APIRequestContext,
  policy: {
    agentToolId: string;
    argumentPath: string;
    operator: string;
    value: string;
    action: "allow_when_context_is_untrusted" | "block_always";
    reason?: string;
  },
)
const deleteToolInvocationPolicy = async (
  request: APIRequestContext,
  policyId: string,
)
const createTrustedDataPolicy = async (
  request: APIRequestContext,
  policy: {
    agentToolId: string;
    description: string;
    attributePath: string;
    operator: string;
    value: string;
    action: "block_always" | "mark_as_trusted" | "sanitize_with_dual_llm";
  },
)
const deleteTrustedDataPolicy = async (
  request: APIRequestContext,
  policyId: string,
)
const createMcpCatalogItem = async (
  request: APIRequestContext,
  catalogItem: {
    name: string;
    description: string;
    serverType: "local" | "remote";
    localConfig?: unknown;
    serverUrl?: string;
    authFields?: unknown;
  },
)
const deleteMcpCatalogItem = async (
  request: APIRequestContext,
  catalogId: string,
)
const installMcpServer = async (
  request: APIRequestContext,
  serverData: {
    name: string;
    catalogId?: string;
    teams?: string[];
    userConfigValues?: Record<string, string>;
    environmentValues?: Record<string, string>;
    accessToken?: string;
  },
)
const uninstallMcpServer = async (
  request: APIRequestContext,
  serverId: string,
)
const createRole = async (
  request: APIRequestContext,
  roleData: {
    name: string;
    permission: Record<string, string[]>;
  },
)
const deleteRole = async (request: APIRequestContext, roleId: string)
</file>

<file path="platform/e2e-tests/tests/api/llm-proxy.spec.ts">
import { expect, test } from "./fixtures";
</file>

<file path="platform/e2e-tests/tests/api/prompts.spec.ts">
import { expect, test } from "./fixtures";
</file>

<file path="platform/frontend/src/app/auth/_components/auth-view-with-error-handling.tsx">
import { AuthView } from "@daveyplate/better-auth-ui";
import { AlertCircle, ExternalLink } from "lucide-react";
import { useEffect, useState } from "react";
import { SsoProviderSelector } from "@/components/sso-provider-selector";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
interface AuthViewWithErrorHandlingProps {
  path: string;
  callbackURL?: string;
}
</file>

<file path="platform/frontend/src/app/auth/[path]/auth-page-with-invitation-check.tsx">
import { useRouter, useSearchParams } from "next/navigation";
import { useEffect } from "react";
import { AuthViewWithErrorHandling } from "@/app/auth/_components/auth-view-with-error-handling";
import { DefaultCredentialsWarning } from "@/components/default-credentials-warning";
import { LoadingSpinner } from "@/components/loading";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useInvitationCheck } from "@/lib/invitation.query";
</file>

<file path="platform/frontend/src/app/cost/compression/page.tsx">
import { archestraApiSdk } from "@shared";
import { useQueryClient } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { MultiSelect } from "@/components/ui/multi-select";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  useOrganization,
  useUpdateOrganization,
} from "@/lib/organization.query";
import { useTeams } from "@/lib/team.query";
⋮----
const checkForChanges = (
    mode: "disabled" | "organization" | "team",
    teamIds: string[],
) =>
const handleSave = async () =>
const handleCancel = () =>
</file>

<file path="platform/frontend/src/app/cost/limits/page.tsx">
import type { archestraApiTypes } from "@shared";
import {
  ChevronsUpDown,
  Edit,
  Plus,
  Save,
  Settings,
  Trash2,
  X,
} from "lucide-react";
import { useCallback, useState } from "react";
import type { CatalogItem } from "@/app/mcp-catalog/_parts/mcp-server-card";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Progress } from "@/components/ui/progress";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useInternalMcpCatalog } from "@/lib/internal-mcp-catalog.query";
import {
  useCreateLimit,
  useDeleteLimit,
  useLimits,
  useUpdateLimit,
} from "@/lib/limits.query";
import {
  useOrganization,
  useUpdateOrganization,
} from "@/lib/organization.query";
import { useTeams } from "@/lib/team.query";
import { useTokenPrices } from "@/lib/token-price.query";
type LimitData = archestraApiTypes.GetLimitsResponses["200"][number];
type TokenPriceData = archestraApiTypes.GetTokenPricesResponses["200"][number];
type TeamData = archestraApiTypes.GetTeamsResponses["200"][number];
type UsageStatus = "safe" | "warning" | "danger";
type LimitType = Pick<LimitData, "limitType">["limitType"];
type TokenCostLimitType = Extract<LimitType, "token_cost">;
type McpServerCallsLimitType = Extract<LimitType, "mcp_server_calls">;
⋮----
disabled=
⋮----
// Remove commas and keep only numbers
⋮----
onEdit=
</file>

<file path="platform/frontend/src/app/logs/[id]/page.client.tsx">
import type { archestraApiTypes } from "@shared";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { Suspense } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import ChatBotDemo from "@/components/chatbot-demo";
import { LoadingSpinner } from "@/components/loading";
import { Savings } from "@/components/savings";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { useDualLlmResultsByInteraction } from "@/lib/dual-llm-result.query";
import { useInteraction } from "@/lib/interaction.query";
import { DynamicInteraction } from "@/lib/interaction.utils";
import { formatDate } from "@/lib/utils";
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/archestra-catalog-tab.tsx">
import type { archestraApiTypes, archestraCatalogTypes } from "@shared";
import { BookOpen, Github, Info, Loader2, Search } from "lucide-react";
import { useMemo, useState } from "react";
import { DebouncedInput } from "@/components/debounced-input";
import { TruncatedText } from "@/components/truncated-text";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Skeleton } from "@/components/ui/skeleton";
import { useHasPermissions } from "@/lib/auth.query";
import {
  useMcpRegistryServersInfinite,
  useMcpServerCategories,
} from "@/lib/external-mcp-catalog.query";
import {
  useCreateInternalMcpCatalogItem,
  useInternalMcpCatalog,
} from "@/lib/internal-mcp-catalog.query";
import type { SelectedCategory } from "./CatalogFilters";
import { DetailsDialog } from "./details-dialog";
import { parseDockerArgsToLocalConfig } from "./docker-args-parser";
import { RequestInstallationDialog } from "./request-installation-dialog";
import { TransportBadges } from "./transport-badges";
type ServerType = "all" | "remote" | "local";
⋮----
const handleAddToCatalog = async (
    server: archestraCatalogTypes.ArchestraMcpServerManifest,
) =>
⋮----
const getValue = (
      config: NonNullable<
        archestraCatalogTypes.ArchestraMcpServerManifest["user_config"]
      >[string],
) =>
⋮----
const getEnvVarType = (
        userConfigEntry: NonNullable<
          archestraCatalogTypes.ArchestraMcpServerManifest["user_config"]
        >[string],
) =>
⋮----
value: "", // Empty - will be prompted
⋮----
// Static env var (no user_config reference)
⋮----
// Second pass: Add user_config entries NOT referenced in server.env
⋮----
// For remote servers, proceed with direct addition
⋮----
const addServerToCatalog = async (
    server: archestraCatalogTypes.ArchestraMcpServerManifest,
    environment?: Array<{
      key: string;
      type: "plain_text" | "secret" | "boolean" | "number";
      value?: string;
      promptOnInstallation: boolean;
    }>,
) =>
const handleRequestInstallation = async (
    server: archestraCatalogTypes.ArchestraMcpServerManifest,
) =>
⋮----
onClick=
⋮----
? onAddToCatalog(server)
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/InternalMCPCatalog.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { Plus, Search } from "lucide-react";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { OAuthConfirmationDialog } from "@/components/oauth-confirmation-dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useHasPermissions } from "@/lib/auth.query";
import { authClient } from "@/lib/clients/auth/auth-client";
import { useDialogs } from "@/lib/dialog.hook";
import { useMcpRegistryServer } from "@/lib/external-mcp-catalog.query";
import { useInternalMcpCatalog } from "@/lib/internal-mcp-catalog.query";
import {
  useDeleteMcpServer,
  useInstallMcpServer,
  useMcpServers,
} from "@/lib/mcp-server.query";
import { CreateCatalogDialog } from "./create-catalog-dialog";
import { CustomServerRequestDialog } from "./custom-server-request-dialog";
import { DeleteCatalogDialog } from "./delete-catalog-dialog";
import { DetailsDialog } from "./details-dialog";
import { EditCatalogDialog } from "./edit-catalog-dialog";
import { LocalServerInstallDialog } from "./local-server-install-dialog";
import {
  type CatalogItem,
  type InstalledServer,
  McpServerCard,
} from "./mcp-server-card";
import { NoAuthInstallDialog } from "./no-auth-install-dialog";
import { ReinstallConfirmationDialog } from "./reinstall-confirmation-dialog";
import { RemoteServerInstallDialog } from "./remote-server-install-dialog";
⋮----
const handleInstallRemoteServer = async (
    catalogItem: CatalogItem,
    teamMode: boolean,
) =>
const handleInstallRemoteServerTeam = async (catalogItem: CatalogItem) =>
const handleInstallLocalServerTeam = async (catalogItem: CatalogItem) =>
const handleInstallLocalServer = async (catalogItem: CatalogItem) =>
const handleNoAuthConfirm = async (teams: string[] = []) =>
const handleLocalServerInstallConfirm = async (
    environmentValues: Record<string, string>,
    teams?: string[],
) =>
const handleRemoteServerInstallConfirm = async (
    catalogItem: CatalogItem,
    metadata?: Record<string, unknown>,
    teams: string[] = [],
) =>
const handleOAuthConfirm = async (teams: string[] = []) =>
const getAggregatedInstallation = (catalogId: string) =>
const handleReinstall = (catalogItem: CatalogItem) =>
const handleReinstallConfirm = async () =>
const handleCancelInstallation = (serverId: string) =>
const sortInstalledFirst = (items: CatalogItem[])
const filterCatalogItems = (items: CatalogItem[], query: string) =>
⋮----
const getInstalledServerInfo = (item: CatalogItem) =>
⋮----
// For local servers, count installations and check ownership
⋮----
? openDialog("create")
⋮----
onInstallRemoteServer=
⋮----
onInstallRemoteServerTeam=
⋮----
onInstallLocalServer=
onInstallLocalServerTeam=
⋮----
onReinstall=
onEdit=
⋮----
onDelete=
⋮----
if (item)
setEditingItem(null);
const serverInfo = getInstalledServerInfo(item);
if (serverInfo.installedServer?.reinstallRequired)
handleReinstall(item);
⋮----
deletingItem
⋮----
open=
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/local-server-install-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { X } from "lucide-react";
import { useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useTeams } from "@/lib/team.query";
type CatalogItem =
  archestraApiTypes.GetInternalMcpCatalogResponses["200"][number];
interface LocalServerInstallDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: (
    environmentValues: Record<string, string>,
    teams?: string[],
  ) => Promise<void>;
  catalogItem: CatalogItem | null;
  isInstalling: boolean;
  authType?: "personal" | "team";
}
⋮----
const handleEnvVarChange = (key: string, value: string) =>
const handleAddTeam = (teamId: string) =>
const handleRemoveSelectedTeam = (teamId: string) =>
const getTeamById = (teamId: string) =>
const handleInstall = async () =>
⋮----
// Validate required fields only
⋮----
// Skip validation for optional fields
⋮----
// Boolean fields are always valid if they have a value (should be "true" or "false")
⋮----
const handleClose = () =>
// Check if there are any fields to show
⋮----
<Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => handleRemoveSelectedTeam(teamId)}
                          className="h-auto p-0.5 ml-1 hover:bg-destructive/20"
                        >
                          <X className="h-3 w-3" />
                        </Button>
                      </Badge>
                    );
⋮----
handleEnvVarChange(
⋮----
handleEnvVarChange(env.key, e.target.value)
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-catalog-form.tsx">
import { zodResolver } from "@hookform/resolvers/zod";
import type { archestraApiTypes } from "@shared";
import { AlertCircle, Info } from "lucide-react";
import { useEffect } from "react";
import { useFieldArray, useForm } from "react-hook-form";
import { EnvironmentVariablesFormField } from "@/components/environment-variables-form-field";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Textarea } from "@/components/ui/textarea";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import config from "@/lib/config";
import {
  formSchema,
  type McpCatalogFormValues,
} from "./mcp-catalog-form.types";
import { transformCatalogItemToFormValues } from "./mcp-catalog-form.utils";
interface McpCatalogFormProps {
  mode: "create" | "edit";
  initialValues?: archestraApiTypes.GetInternalMcpCatalogResponses["200"][number];
  onSubmit: (values: McpCatalogFormValues) => void;
  serverType?: "remote" | "local";
  footer?: React.ReactNode;
}
⋮----
<form onSubmit=
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-catalog-form.utils.ts">
import type { archestraApiTypes } from "@shared";
import type { McpCatalogFormValues } from "./mcp-catalog-form.types";
type McpCatalogApiData =
  archestraApiTypes.CreateInternalMcpCatalogItemData["body"];
export function transformFormToApiData(
  values: McpCatalogFormValues,
): McpCatalogApiData
⋮----
server_url: values.serverUrl || "", // Use serverUrl as OAuth server URL
⋮----
export function transformCatalogItemToFormValues(
  item: archestraApiTypes.GetInternalMcpCatalogResponses["200"][number],
): McpCatalogFormValues
⋮----
// Extract local config if present
⋮----
// Add promptOnInstallation with default value if missing
⋮----
// Preserve required and description fields
⋮----
/**
 * Strips surrounding quotes from an environment variable value.
 * Handles both double quotes (") and single quotes (').
 * Only strips quotes if they match at both the beginning and end.
 *
 * @param value - The raw environment variable value that may contain quotes
 * @returns The value with surrounding quotes removed if present
 *
 * @example
 * stripEnvVarQuotes('"http://grafana:80"') // returns 'http:
 * stripEnvVarQuotes("'value'")
 * stripEnvVarQuotes('no-quotes')
 * stripEnvVarQuotes('"mismatched\'')
 * stripEnvVarQuotes('') // returns ''
 */
export function stripEnvVarQuotes(value: string): string
⋮----
// Only strip if first and last chars are matching quotes
</file>

<file path="platform/frontend/src/app/settings/dual-llm/page.tsx">
import type { archestraApiTypes } from "@shared";
import { Suspense, useCallback, useEffect, useRef, useState } from "react";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import { CodeText } from "@/components/code-text";
import { LoadingSpinner } from "@/components/loading";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import { Textarea } from "@/components/ui/textarea";
import {
  useDualLlmConfig,
  useUpdateDualLlmConfig,
} from "@/lib/dual-llm-config.query";
⋮----
const createParticle = () =>
⋮----
const animate = (currentTime: number) =>
⋮----
const handleSave = () =>
</file>

<file path="platform/frontend/src/app/settings/gateways/page.tsx">
import { ArchestraArchitectureDiagram } from "@/components/archestra-architecture-diagram";
import { ConnectionOptions } from "@/components/connection-options";
import { useDefaultProfile } from "@/lib/agent.query";
export default function GatewaysSettingsPage()
</file>

<file path="platform/frontend/src/app/tools/_parts/policy-card.tsx">
export function PolicyCard(
</file>

<file path="platform/frontend/src/app/tools/_parts/tool-readonly-details.tsx">
import type { archestraApiTypes } from "@shared";
</file>

<file path="platform/frontend/src/components/roles/role-permission-builder.tsx">
import {
  type Action,
  ActionSchema,
  type Permissions,
  type Resource,
} from "@shared";
import { Check, ChevronDown, ChevronRight } from "lucide-react";
import { useCallback, useState } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
interface RolePermissionBuilderProps {
  permission: Permissions;
  onChange: (permission: Permissions) => void;
  userPermissions: Permissions;
}
⋮----

⋮----
if (checked)
selectAllForResource(resource);
</file>

<file path="platform/frontend/src/components/teams/teams-list.tsx">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Plus, Settings, Trash2, Users } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import { Textarea } from "@/components/ui/textarea";
import { TeamMembersDialog } from "./team-members-dialog";
type Team = archestraApiTypes.GetTeamsResponses["200"][number];
⋮----
const handleCreateTeam = () =>
const handleDeleteTeam = () =>
⋮----
onClick=
⋮----
onChange=
</file>

<file path="platform/frontend/src/components/ui/permission-button.tsx">
import type { Permissions } from "@shared";
import type React from "react";
import { Button, type ButtonProps } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useHasPermissions } from "@/lib/auth.query";
import { permissionsToStrings } from "@/lib/auth.utils";
type PermissionButtonProps = ButtonProps & {
  permissions: Permissions;
  tooltip?: string;
};
export function PermissionButton({
  permissions,
  tooltip,
  children,
  ...props
}: PermissionButtonProps)
⋮----
e.preventDefault();
e.stopPropagation();
⋮----
Missing permissions:
</file>

<file path="platform/frontend/src/components/invite-by-link-card.tsx">
import {
  ADMIN_ROLE_NAME,
  type AnyRoleName,
  E2eTestId,
  MEMBER_ROLE_NAME,
} from "@shared";
import { QueryErrorResetBoundary } from "@tanstack/react-query";
import { Check, Copy, Link as LinkIcon, Loader2 } from "lucide-react";
import { Suspense, useCallback, useState } from "react";
import { ErrorBoundary } from "react-error-boundary";
import { toast } from "sonner";
import { LoadingSpinner } from "@/components/loading";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useCreateInvitation } from "@/lib/organization.query";
import { useRoles } from "@/lib/role.query";
interface InviteByLinkCardProps {
  organizationId?: string;
  onInvitationCreated?: () => void;
}
⋮----
// Validate email format
⋮----
onChange=
</file>

<file path="platform/frontend/src/components/mcp-connection-instructions.tsx">
import { Check, Copy } from "lucide-react";
import { useCallback, useState } from "react";
import { toast } from "sonner";
import { CodeText } from "@/components/code-text";
import { Button } from "@/components/ui/button";
import config from "@/lib/config";
⋮----
interface McpConnectionInstructionsProps {
  agentId: string;
}
</file>

<file path="platform/frontend/src/lib/clients/auth/auth-client.ts">
import { ssoClient } from "@better-auth/sso/client";
import { ac, adminRole, memberRole } from "@shared";
import {
  adminClient,
  apiKeyClient,
  inferOrgAdditionalFields,
  organizationClient,
  twoFactorClient,
} from "better-auth/client/plugins";
import { nextCookies } from "better-auth/next-js";
import { createAuthClient } from "better-auth/react";
import config from "@/lib/config";
⋮----
baseURL: "", // Always use relative URLs (proxied through Next.js)
⋮----
enabled: true, // Enable dynamic access control on client
</file>

<file path="platform/frontend/src/lib/agent.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
⋮----
export function useProfiles(
  params: {
    initialData?: archestraApiTypes.GetAllAgentsResponses["200"];
    filters?: archestraApiTypes.GetAllAgentsData["query"];
  } = {},
)
export function useProfilesPaginated(params?: {
  limit?: number;
  offset?: number;
  sortBy?: "name" | "createdAt" | "toolsCount" | "team";
  sortDirection?: "asc" | "desc";
  name?: string;
})
export function useDefaultProfile(params?: {
  initialData?: archestraApiTypes.GetDefaultAgentResponses["200"];
})
export function useProfile(id: string | undefined)
export function useCreateProfile()
export function useUpdateProfile()
export function useDeleteProfile()
export function useLabelKeys()
export function useLabelValues(params?:
</file>

<file path="platform/frontend/src/lib/auth.query.test.tsx">
import { archestraApiSdk, type Permissions } from "@shared";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { renderHook, waitFor } from "@testing-library/react";
import { beforeEach, describe, expect, it, vi } from "vitest";
import {
  useCurrentOrgMembers,
  useDefaultCredentialsEnabled,
  useHasPermissions,
  usePermissionMap,
  useSession,
} from "./auth.query";
import { authClient } from "./clients/auth/auth-client";
⋮----
const createWrapper = () =>
</file>

<file path="platform/frontend/src/lib/auth.query.ts">
import { archestraApiSdk, type Permissions } from "@shared";
import { useQuery } from "@tanstack/react-query";
import { useIsAuthenticated } from "@/lib/auth.hook";
import { authClient } from "@/lib/clients/auth/auth-client";
export function useSession()
export function useCurrentOrgMembers()
function useAllPermissions()
export function useHasPermissions(permissionsToCheck: Permissions)
export function usePermissionMap<Key extends string>(
  map: Record<Key, Permissions>,
): Record<Key, boolean>
export function useDefaultCredentialsEnabled()
</file>

<file path="platform/frontend/src/lib/chat.query.ts">
import { archestraApiSdk } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
⋮----
export function useConversation(conversationId?: string)
export function useConversations()
export function useCreateConversation()
export function useUpdateConversation()
export function useDeleteConversation()
export function useChatProfileMcpTools(agentId: string | undefined)
</file>

<file path="platform/frontend/src/lib/prompts.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
⋮----
export function usePrompts(params?: {
  initialData?: archestraApiTypes.GetPromptsResponses["200"];
})
export function usePrompt(id: string)
export function usePromptVersions(id: string)
export function useCreatePrompt()
export function useUpdatePrompt()
export function useRollbackPrompt()
export function useDeletePrompt()
</file>

<file path="platform/frontend/src/lib/role.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useIsAuthenticated } from "./auth.hook";
⋮----
export function useRoles(params?: {
  initialData?: archestraApiTypes.GetRolesResponses["200"];
})
export function useRole(roleId: string)
export function useCreateRole()
export function useUpdateRole()
export function useDeleteRole()
export function useCustomRoles()
</file>

<file path="platform/frontend/src/lib/statistics.query.ts">
import {
  archestraApiSdk,
  type archestraApiTypes,
  type StatisticsTimeFrame,
} from "@shared";
import { useSuspenseQuery } from "@tanstack/react-query";
⋮----
export function useTeamStatistics({
  timeframe = "24h",
  initialData,
}: {
  timeframe?: StatisticsTimeFrame;
  initialData?: archestraApiTypes.GetTeamStatisticsResponses["200"];
} =
export function useProfileStatistics({
  timeframe = "24h",
  initialData,
}: {
  timeframe?: StatisticsTimeFrame;
  initialData?: archestraApiTypes.GetAgentStatisticsResponses["200"];
} =
export function useModelStatistics({
  timeframe = "24h",
  initialData,
}: {
  timeframe?: StatisticsTimeFrame;
  initialData?: archestraApiTypes.GetModelStatisticsResponses["200"];
} =
export function useOverviewStatistics({
  timeframe = "24h",
  initialData,
}: {
  timeframe?: StatisticsTimeFrame;
  initialData?: archestraApiTypes.GetOverviewStatisticsResponses["200"];
} =
export function useCostSavingsStatistics({
  timeframe = "24h",
  initialData,
}: {
  timeframe?: StatisticsTimeFrame;
  initialData?: archestraApiTypes.GetCostSavingsStatisticsResponses["200"];
} =
</file>

<file path="platform/frontend/src/lib/tool.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useSuspenseQuery } from "@tanstack/react-query";
⋮----
export function useTools({
  initialData,
}: {
  initialData?: archestraApiTypes.GetToolsResponses["200"];
})
</file>

<file path="platform/frontend/src/lib/tool.utils.ts">
import type { archestraApiTypes } from "@shared";
export function isMcpTool(
  tool: archestraApiTypes.GetAllAgentToolsResponses["200"]["data"][number]["tool"],
)
</file>

<file path="platform/.env.example">
# OpenAI API Key
# FIXME Consider keeping OPENAI_API_KEY empty by default so that it triggers validation if left empty
OPENAI_API_KEY=your-api-key-here

# LLM Provider Base URLs
ARCHESTRA_OPENAI_BASE_URL=https://api.openai.com/v1
ARCHESTRA_ANTHROPIC_BASE_URL=https://api.anthropic.com
# NOTE: use the following base URLs for testing w/ local wiremock service for e2e tests
# (see dev/Tiltfile.test)
# ARCHESTRA_OPENAI_BASE_URL=http://localhost:30080/v1
# ARCHESTRA_ANTHROPIC_BASE_URL=http://localhost:8080

# Database URL
ARCHESTRA_DATABASE_URL="postgresql://archestra:archestra_dev_password@localhost:5432/archestra_dev?schema=public"

# OpenTelemetry Configuration
# OTEL Exporter endpoint for sending traces (defaults to http://localhost:4318/v1/traces)
ARCHESTRA_OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318/v1/traces
# OTEL Authentication - Basic auth credentials (both required if using basic auth)
ARCHESTRA_OTEL_EXPORTER_OTLP_AUTH_USERNAME=""
ARCHESTRA_OTEL_EXPORTER_OTLP_AUTH_PASSWORD=""
# OTEL Authentication - Bearer token (takes precedence over basic auth if provided)
ARCHESTRA_OTEL_EXPORTER_OTLP_AUTH_BEARER=""

# Bearer token auth secret for exposed /metrics endpoint (port 9050)
ARCHESTRA_METRICS_SECRET=""

# Sentry Configuration
# Sentry DSN for backend error tracking (leave empty to disable)
ARCHESTRA_SENTRY_BACKEND_DSN=""
# Environment identifier for Sentry
ARCHESTRA_SENTRY_ENVIRONMENT=""
# Sentry DSN for frontend error tracking (leave empty to disable)
NEXT_PUBLIC_ARCHESTRA_SENTRY_FRONTEND_DSN=""

# Optional for local dev
# API Base URL - The backend URL (used by Next.js server for proxying)
ARCHESTRA_API_BASE_URL="http://localhost:9000"

# Optional for local dev
# Frontend URL - The URL where users access the frontend
ARCHESTRA_FRONTEND_URL=http://localhost:3000

# Optional for local dev
# Cookie Domain - Required if different domains or subdomains for frontend and backend are used
# Should be set to the domain of the ARCHESTRA_FRONTEND_URL, e.g. "example.com"
ARCHESTRA_AUTH_COOKIE_DOMAIN=""

# Configuration for docker compose demos, e.g. docker-compose-n8n.yml and docker-compose-mastra.yml
DOMAIN_NAME=localhost
SSL_EMAIL=admin@localhost
GENERIC_TIMEZONE=UTC

# n8n
SUBDOMAIN=n8n

# Mastra
MASTRA_SUBDOMAIN=mastra
GITHUB_TOKEN=

# Analytics configuration for PostHog
ARCHESTRA_ANALYTICS=

# Auth
ARCHESTRA_AUTH_SECRET=
ARCHESTRA_AUTH_ADMIN_EMAIL=admin@example.com
ARCHESTRA_AUTH_ADMIN_PASSWORD=password

# Feature Flags
# FEATURES_XYZ_ENABLED=false

# Kubernetes Configuration for MCP Server Runtime

# Whether to load kubeconfig from current cluster (set to "true" when running inside K8s)
ARCHESTRA_ORCHESTRATOR_LOAD_KUBECONFIG_FROM_CURRENT_CLUSTER=false
# Path to kubeconfig file (optional if running inside K8s cluster or using default ~/.kube/config)
ARCHESTRA_ORCHESTRATOR_KUBECONFIG=
# Kubernetes namespace for MCP server pods (defaults to "default")
ARCHESTRA_ORCHESTRATOR_K8S_NAMESPACE=default
# Base image for MCP server containers
ARCHESTRA_ORCHESTRATOR_MCP_SERVER_BASE_IMAGE=europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-base:0.0.3
# Frontend-accessible base image (for display purposes in UI)
NEXT_PUBLIC_ARCHESTRA_ORCHESTRATOR_MCP_SERVER_BASE_IMAGE=europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-base:0.0.3

# Logging
ARCHESTRA_LOGGING_LEVEL=info

# Bearer token for /metrics endpoint
ARCHESTRA_METRICS_SECRET=foo-bar

# Secrets Manager Configuration
# SECRETS_MANAGER: "DB" (default) or "Vault"
# - DB: Stores secrets directly in PostgreSQL database
# - Vault: Stores secrets in HashiCorp Vault (requires HASHICORP_VAULT_ADDR and HASHICORP_VAULT_TOKEN)
SECRETS_MANAGER=DB

# HashiCorp Vault Configuration (required when SECRETS_MANAGER=Vault)
HASHICORP_VAULT_ADDR=http://localhost:8200
HASHICORP_VAULT_TOKEN=dev-root-token
</file>

<file path="platform/backend/src/clients/mcp-client.test.ts">
import { vi } from "vitest";
import db, { schema } from "@/database";
import {
  AgentModel,
  AgentToolModel,
  InternalMcpCatalogModel,
  McpServerModel,
  ToolModel,
} from "@/models";
import { secretManager } from "@/secretsmanager";
import { beforeEach, describe, expect, test } from "@/test";
import mcpClient from "./mcp-client";
</file>

<file path="platform/backend/src/models/agent-team.ts">
import { and, eq, inArray } from "drizzle-orm";
import db, { schema } from "@/database";
import logger from "@/logging";
class AgentTeamModel
⋮----
static async getUserAccessibleAgentIds(
    userId: string,
    isAgentAdmin: boolean,
): Promise<string[]>
static async userHasAgentAccess(
    userId: string,
    agentId: string,
    isAgentAdmin: boolean,
): Promise<boolean>
static async getTeamsForAgent(agentId: string): Promise<string[]>
static async syncAgentTeams(
    agentId: string,
    teamIds: string[],
): Promise<number>
static async assignTeamsToAgent(
    agentId: string,
    teamIds: string[],
): Promise<void>
static async removeTeamFromAgent(
    agentId: string,
    teamId: string,
): Promise<boolean>
static async getTeamsForAgents(
    agentIds: string[],
): Promise<Map<string, string[]>>
static async agentAndMcpServerShareTeam(
    agentId: string,
    mcpServerId: string,
): Promise<boolean>
</file>

<file path="platform/backend/src/models/agent-tool.test.ts">
import db, { schema } from "@/database";
import { describe, expect, test } from "@/test";
import AgentToolModel from "./agent-tool";
</file>

<file path="platform/backend/src/models/agent-tool.ts">
import {
  and,
  asc,
  count,
  desc,
  eq,
  getTableColumns,
  inArray,
  or,
  type SQL,
  sql,
} from "drizzle-orm";
import db, { schema } from "@/database";
import {
  createPaginatedResult,
  type PaginatedResult,
} from "@/database/utils/pagination";
import type {
  AgentTool,
  AgentToolFilters,
  AgentToolSortBy,
  AgentToolSortDirection,
  InsertAgentTool,
  PaginationQuery,
  UpdateAgentTool,
} from "@/types";
import AgentTeamModel from "./agent-team";
class AgentToolModel
⋮----
static async create(
    agentId: string,
    toolId: string,
    options?: Partial<
      Pick<
        InsertAgentTool,
        | "allowUsageWhenUntrustedDataIsPresent"
        | "toolResultTreatment"
        | "responseModifierTemplate"
        | "credentialSourceMcpServerId"
        | "executionSourceMcpServerId"
      >
    >,
)
static async delete(agentId: string, toolId: string): Promise<boolean>
static async findToolIdsByAgent(agentId: string): Promise<string[]>
static async findAgentIdsByTool(toolId: string): Promise<string[]>
static async findAllAssignedToolIds(): Promise<string[]>
static async exists(agentId: string, toolId: string): Promise<boolean>
static async createIfNotExists(
    agentId: string,
    toolId: string,
    credentialSourceMcpServerId?: string | null,
    executionSourceMcpServerId?: string | null,
)
static async createManyIfNotExists(
    agentId: string,
    toolIds: string[],
): Promise<void>
static async bulkCreateForAgentsAndTools(
    agentIds: string[],
    toolIds: string[],
    options?: Partial<
      Pick<
        InsertAgentTool,
        | "allowUsageWhenUntrustedDataIsPresent"
        | "toolResultTreatment"
        | "responseModifierTemplate"
        | "credentialSourceMcpServerId"
        | "executionSourceMcpServerId"
      >
    >,
): Promise<void>
static async createOrUpdateCredentials(
    agentId: string,
    toolId: string,
    credentialSourceMcpServerId?: string | null,
    executionSourceMcpServerId?: string | null,
): Promise<
static async update(
    id: string,
    data: Partial<
      Pick<
        UpdateAgentTool,
        | "allowUsageWhenUntrustedDataIsPresent"
        | "toolResultTreatment"
        | "responseModifierTemplate"
        | "credentialSourceMcpServerId"
        | "executionSourceMcpServerId"
      >
    >,
)
static async bulkUpdateSameValue(
    ids: string[],
    field: "allowUsageWhenUntrustedDataIsPresent" | "toolResultTreatment",
    value: boolean | "trusted" | "sanitize_with_dual_llm" | "untrusted",
): Promise<number>
static async findAll(
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<AgentTool[]>
static async findAllPaginated(
    pagination: PaginationQuery,
    sorting?: {
      sortBy?: AgentToolSortBy;
      sortDirection?: AgentToolSortDirection;
    },
    filters?: AgentToolFilters,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<PaginatedResult<AgentTool>>
⋮----
// Filter by agent
⋮----
// Filter by origin (either "llm-proxy" or a catalogId)
⋮----
// LLM Proxy tools have null catalogId
⋮----
// Determine the ORDER BY clause based on sorting params
⋮----
// Sort by catalogId (null values last for LLM Proxy)
⋮----
static async getSecurityConfig(
    agentId: string,
    toolName: string,
): Promise<
static async cleanupInvalidCredentialSourcesForUser(
    userId: string,
    teamId: string,
    isAgentAdmin: boolean,
): Promise<number>
</file>

<file path="platform/backend/src/models/prompt.test.ts">
import { describe, expect, test } from "@/test";
import AgentModel from "./agent";
import PromptModel from "./prompt";
</file>

<file path="platform/backend/src/models/token-price.ts">
import { asc, eq, sql } from "drizzle-orm";
import db, { schema } from "@/database";
import getDefaultModelPrice from "@/default-model-prices";
import type { CreateTokenPrice, InsertTokenPrice, TokenPrice } from "@/types";
class TokenPriceModel
⋮----
static async findAll(): Promise<TokenPrice[]>
static async findById(id: string): Promise<TokenPrice | null>
static async findByModel(model: string): Promise<TokenPrice | null>
static async create(data: CreateTokenPrice): Promise<TokenPrice>
static async update(
    id: string,
    data: Partial<CreateTokenPrice>,
): Promise<TokenPrice | null>
static async upsertForModel(
    model: string,
    data: Omit<CreateTokenPrice, "model">,
): Promise<TokenPrice>
static async createIfNotExists(
    model: string,
    data: Omit<CreateTokenPrice, "model">,
): Promise<TokenPrice | null>
static async delete(id: string): Promise<boolean>
static async getAllModelsFromInteractions(): Promise<string[]>
static async ensureAllModelsHavePricing(): Promise<void>
</file>

<file path="platform/backend/src/models/tool.ts">
import { MCP_SERVER_TOOL_NAME_SEPARATOR } from "@shared";
import { and, desc, eq, inArray, isNotNull, isNull, or } from "drizzle-orm";
import { getArchestraMcpTools } from "@/archestra-mcp-server";
import db, { schema } from "@/database";
import type { ExtendedTool, InsertTool, Tool } from "@/types";
import AgentTeamModel from "./agent-team";
import AgentToolModel from "./agent-tool";
class ToolModel
⋮----
static slugifyName(mcpServerName: string, toolName: string): string
static unslugifyName(slugifiedName: string): string
static async create(tool: InsertTool): Promise<Tool>
static async createToolIfNotExists(tool: InsertTool): Promise<Tool>
static async findById(
    id: string,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<Tool | null>
static async findAll(
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<ExtendedTool[]>
static async findByName(
    name: string,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<Tool | null>
static async getToolsByAgent(agentId: string): Promise<Tool[]>
static async getMcpToolsByAgent(agentId: string): Promise<Tool[]>
static async bulkCreateToolsIfNotExists(
    tools: Array<{
      name: string;
      description: string | null;
      parameters: Record<string, unknown>;
      catalogId: string;
      mcpServerId: string;
    }>,
): Promise<Tool[]>
static async assignArchestraToolsToAgent(agentId: string): Promise<void>
static async getMcpToolNamesByAgent(agentId: string): Promise<string[]>
static async getMcpToolsAssignedToAgent(
    toolNames: string[],
    agentId: string,
  ): Promise<
    Array<{
      toolName: string;
      responseModifierTemplate: string | null;
      mcpServerSecretId: string | null;
      mcpServerName: string | null;
      mcpServerCatalogId: string | null;
      mcpServerId: string | null;
      credentialSourceMcpServerId: string | null;
      executionSourceMcpServerId: string | null;
      catalogId: string | null;
      catalogName: string | null;
    }>
  > {
if (toolNames.length === 0)
static async findByMcpServerId(mcpServerId: string): Promise<
    Array<{
      id: string;
      name: string;
      description: string | null;
      parameters: Record<string, unknown>;
      createdAt: Date;
      assignedAgentCount: number;
      assignedAgents: Array<{ id: string; name: string }>;
    }>
  > {
    const tools = await db
      .select({
        id: schema.toolsTable.id,
        name: schema.toolsTable.name,
        description: schema.toolsTable.description,
        parameters: schema.toolsTable.parameters,
        createdAt: schema.toolsTable.createdAt,
      })
      .from(schema.toolsTable)
      .where(eq(schema.toolsTable.mcpServerId, mcpServerId))
      .orderBy(desc(schema.toolsTable.createdAt));
static async findByCatalogId(catalogId: string): Promise<
    Array<{
      id: string;
      name: string;
      description: string | null;
      parameters: Record<string, unknown>;
      createdAt: Date;
      assignedAgentCount: number;
      assignedAgents: Array<{ id: string; name: string }>;
    }>
  > {
    const tools = await db
      .select({
        id: schema.toolsTable.id,
        name: schema.toolsTable.name,
        description: schema.toolsTable.description,
        parameters: schema.toolsTable.parameters,
        createdAt: schema.toolsTable.createdAt,
      })
      .from(schema.toolsTable)
      .where(eq(schema.toolsTable.catalogId, catalogId))
      .orderBy(desc(schema.toolsTable.createdAt));
static async deleteByCatalogId(catalogId: string): Promise<number>
static async getByIds(ids: string[]): Promise<Tool[]>
</file>

<file path="platform/backend/src/routes/auth.ts">
import { DEFAULT_ADMIN_EMAIL, RouteId } from "@shared";
import { verifyPassword } from "better-auth/crypto";
import { and, eq } from "drizzle-orm";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { betterAuth } from "@/auth";
import config from "@/config";
import db, { schema } from "@/database";
import logger from "@/logging";
import { AccountModel, UserModel } from "@/models";
const authRoutes: FastifyPluginAsyncZod = async (fastify) =>
⋮----
async handler(request, reply)
</file>

<file path="platform/backend/src/routes/chat.ts">
import { createAnthropic } from "@ai-sdk/anthropic";
import { RouteId } from "@shared";
import { convertToModelMessages, stepCountIs, streamText } from "ai";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { getChatMcpTools } from "@/clients/chat-mcp-client";
import config from "@/config";
import {
  AgentModel,
  ChatSettingsModel,
  ConversationModel,
  MessageModel,
  PromptModel,
} from "@/models";
import { secretManager } from "@/secretsmanager";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  ErrorResponsesSchema,
  InsertConversationSchema,
  SelectConversationSchema,
  UpdateConversationSchema,
  UuidIdSchema,
} from "@/types";
const chatRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/mcp-server.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import logger from "@/logging";
import { McpServerRuntimeManager } from "@/mcp-server-runtime";
import {
  AgentToolModel,
  InternalMcpCatalogModel,
  McpServerModel,
  McpServerTeamModel,
  ToolModel,
} from "@/models";
import { secretManager } from "@/secretsmanager";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  InsertMcpServerSchema,
  type InternalMcpCatalogServerType,
  LocalMcpServerInstallationStatusSchema,
  SelectMcpServerSchema,
  UuidIdSchema,
} from "@/types";
const mcpServerRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/routes/prompts.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { AgentTeamModel, PromptModel } from "@/models";
import {
  ApiError,
  constructResponseSchema,
  DeleteObjectResponseSchema,
  InsertPromptSchema,
  SelectPromptSchema,
  UpdatePromptSchema,
  UuidIdSchema,
} from "@/types";
const promptRoutes: FastifyPluginAsyncZod = async (fastify) =>
</file>

<file path="platform/backend/src/types/optimization-rule.ts">
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import { z } from "zod";
import { schema } from "@/database";
import { SupportedProvidersSchema } from "./llm-providers";
⋮----
export type ContentLengthConditions = z.infer<
  typeof ContentLengthConditionsSchema
>;
export type ToolPresenceConditions = z.infer<
  typeof ToolPresenceConditionsSchema
>;
export type OptimizationRuleConditions = z.infer<
  typeof OptimizationRuleConditionsSchema
>;
export type OptimizationRuleType = z.infer<typeof OptimizationRuleTypeSchema>;
export type OptimizationRuleEntityType = z.infer<
  typeof OptimizationRuleEntityTypeSchema
>;
export type OptimizationRule = z.infer<typeof SelectOptimizationRuleSchema>;
export type InsertOptimizationRule = z.infer<
  typeof InsertOptimizationRuleSchema
>;
export type UpdateOptimizationRule = z.infer<
  typeof UpdateOptimizationRuleSchema
>;
</file>

<file path="platform/backend/src/archestra-mcp-server.ts">
import type { CallToolResult, Tool } from "@modelcontextprotocol/sdk/types.js";
import {
  ARCHESTRA_MCP_SERVER_NAME,
  MCP_SERVER_TOOL_NAME_SEPARATOR,
  TOOL_CREATE_MCP_SERVER_INSTALLATION_REQUEST_FULL_NAME,
} from "@shared";
import logger from "@/logging";
import {
  AgentModel,
  InternalMcpCatalogModel,
  LimitModel,
  McpServerModel,
  ToolInvocationPolicyModel,
  ToolModel,
  TrustedDataPolicyModel,
} from "@/models";
import { assignToolToAgent } from "@/routes/agent-tool";
import type { InternalMcpCatalog } from "@/types";
import {
  AutonomyPolicyOperator,
  type LimitEntityType,
  type LimitType,
  LimitTypeSchema,
  type ToolInvocation,
  type TrustedData,
} from "@/types";
⋮----
export interface ArchestraContext {
  profile: {
    id: string;
    name: string;
  };
}
export const isArchestraMcpServerTool = (toolName: string): boolean =>
export async function executeArchestraTool(
  toolName: string,
  args: Record<string, unknown> | undefined,
  context: ArchestraContext,
): Promise<CallToolResult>
⋮----
// Search by name or description
⋮----
// Return all catalog items
⋮----
export function getArchestraMcpTools(): Tool[]
</file>

<file path="platform/backend/src/config.ts">
import path from "node:path";
import { fileURLToPath } from "node:url";
import type { OTLPExporterNodeConfigBase } from "@opentelemetry/otlp-exporter-base";
import {
  DEFAULT_ADMIN_EMAIL,
  DEFAULT_ADMIN_EMAIL_ENV_VAR_NAME,
  DEFAULT_ADMIN_PASSWORD,
  DEFAULT_ADMIN_PASSWORD_ENV_VAR_NAME,
} from "@shared";
import dotenv from "dotenv";
import logger from "@/logging";
import packageJson from "../../package.json";
⋮----
export const getOtlpAuthHeaders = (): Record<string, string> | undefined =>
export const getDatabaseUrl = (): string =>
const getPortFromUrl = (): number =>
const parseAllowedOrigins = (): string[] =>
const getCorsOrigins = (): RegExp | boolean | string[] =>
const getTrustedOrigins = (): string[] | undefined =>
</file>

<file path="platform/backend/src/server.ts">
import fastifyCors from "@fastify/cors";
import fastifyFormbody from "@fastify/formbody";
import fastifySwagger from "@fastify/swagger";
⋮----
import Fastify from "fastify";
import metricsPlugin from "fastify-metrics";
import {
  jsonSchemaTransform,
  jsonSchemaTransformObject,
  serializerCompiler,
  validatorCompiler,
  type ZodTypeProvider,
} from "fastify-type-provider-zod";
import { z } from "zod";
import { fastifyAuthPlugin } from "@/auth";
import config from "@/config";
import { seedRequiredStartingData } from "@/database/seed";
import { initializeMetrics } from "@/llm-metrics";
import logger from "@/logging";
import { McpServerRuntimeManager } from "@/mcp-server-runtime";
import { AgentLabelModel } from "@/models";
import {
  Anthropic,
  ApiError,
  Gemini,
  OpenAi,
  SupportedProvidersDiscriminatorSchema,
  SupportedProvidersSchema,
  WebSocketMessageSchema,
} from "@/types";
import websocketService from "@/websocket";
⋮----
export const createFastifyInstance = ()
const registerMetricsPlugin = async (
  fastify: ReturnType<typeof createFastifyInstance>,
  endpointEnabled: boolean,
): Promise<void> =>
⋮----
const startMetricsServer = async () =>
const startMcpServerRuntime = async (
  fastify: ReturnType<typeof createFastifyInstance>,
) =>
const start = async () =>
⋮----
const gracefulShutdown = async (signal: string) =>
</file>

<file path="platform/frontend/src/app/_parts/chat-sidebar-section.tsx">
import { ChevronDown, ChevronRight, Edit2, Trash2 } from "lucide-react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useCallback, useEffect, useRef, useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  useConversations,
  useDeleteConversation,
  useUpdateConversation,
} from "@/lib/chat.query";
⋮----
function getConversationDisplayTitle(
  title: string | null,
  messages?: any[],
): string
⋮----
// If we're deleting the current conversation, navigate to new chat
⋮----
onClick=
⋮----
handleSelectConversation(conv.id)
⋮----
e.stopPropagation();
</file>

<file path="platform/frontend/src/app/logs/llm-proxy/page.client.tsx">
import type { archestraApiTypes } from "@shared";
import type { ColumnDef, SortingState } from "@tanstack/react-table";
import { ChevronDown, ChevronUp } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { Savings } from "@/components/savings";
import { TruncatedText } from "@/components/truncated-text";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { DataTable } from "@/components/ui/data-table";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useProfiles } from "@/lib/agent.query";
import { useInteractions } from "@/lib/interaction.query";
import { DynamicInteraction } from "@/lib/interaction.utils";
import { DEFAULT_TABLE_LIMIT, formatDate } from "@/lib/utils";
import { ErrorBoundary } from "../../_parts/error-boundary";
type InteractionData =
  archestraApiTypes.GetInteractionsResponses["200"]["data"][number];
type ToolBadgeProps = {
  toolName: string;
  type: "requested" | "used" | "blocked";
};
function ToolBadge(
⋮----
const getVariantAndClasses = () =>
⋮----
function SortIcon(
export default function LlmProxyLogsPage({
  initialData,
}: {
  initialData?: {
    interactions: archestraApiTypes.GetInteractionsResponses["200"];
    agents: archestraApiTypes.GetAllAgentsResponses["200"];
  };
})
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-tools-dialog.tsx">
import { MCP_SERVER_TOOL_NAME_SEPARATOR } from "@shared";
import { Search, UserPlus, Users } from "lucide-react";
import { useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
interface McpToolsDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  serverName: string;
  tools: Array<{
    id: string;
    name: string;
    description: string | null;
    assignedAgentCount: number;
    assignedAgents: Array<{ id: string; name: string }>;
    parameters: Record<string, unknown>;
    createdAt: string;
  }>;
  isLoading: boolean;
  onAssignTool: (tool: {
    id: string;
    name: string;
    description: string | null;
    parameters: Record<string, unknown>;
    createdAt: string;
  }) => void;
  onBulkAssignTools: (
    tools: Array<{
      id: string;
      name: string;
      description: string | null;
      parameters: Record<string, unknown>;
      createdAt: string;
    }>,
  ) => void;
}
const formatToolName = (toolName: string) =>
⋮----
const toggleAll = () =>
const toggleTool = (toolId: string) =>
const handleBulkAssign = () =>
⋮----
// Don't clear selection here - it will be cleared when the bulk assign dialog closes
⋮----
const handleDialogChange = (newOpen: boolean) =>
⋮----
onClick=
</file>

<file path="platform/frontend/src/app/tools/_parts/response-modifier-editor.tsx">
import type { archestraApiTypes } from "@shared";
import { Loader2 } from "lucide-react";
import Link from "next/link";
import { useCallback, useState } from "react";
import { toast } from "sonner";
import { Editor } from "@/components/editor";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { useProfileToolPatchMutation } from "@/lib/agent-tools.query";
interface ResponseModifierEditorProps {
  agentTool: archestraApiTypes.GetAllAgentToolsResponses["200"]["data"][number];
}
⋮----
// Show message if not an MCP tool
</file>

<file path="platform/frontend/src/app/tools/_parts/tool-call-policies.tsx">
import type { archestraApiTypes } from "@shared";
import { ArrowRightIcon, Plus, Trash2Icon } from "lucide-react";
import { ButtonWithTooltip } from "@/components/button-with-tooltip";
import { DebouncedInput } from "@/components/debounced-input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { useProfileToolPatchMutation } from "@/lib/agent-tools.query";
import {
  useOperators,
  useToolInvocationPolicies,
  useToolInvocationPolicyCreateMutation,
  useToolInvocationPolicyDeleteMutation,
  useToolInvocationPolicyUpdateMutation,
} from "@/lib/policy.query";
import { PolicyCard } from "./policy-card";
</file>

<file path="platform/frontend/src/app/tools/page.client.tsx">
import type { archestraApiTypes } from "@shared";
import { useQueryClient } from "@tanstack/react-query";
import { Suspense, useEffect, useState } from "react";
import { LoadingSpinner } from "@/components/loading";
import {
  prefetchOperators,
  prefetchToolInvocationPolicies,
  prefetchToolResultPolicies,
} from "@/lib/policy.query";
import { ErrorBoundary } from "../_parts/error-boundary";
import { AssignedToolsTable } from "./_parts/assigned-tools-table";
import { ToolDetailsDialog } from "./_parts/tool-details-dialog";
type ProfileToolData =
  archestraApiTypes.GetAllAgentToolsResponses["200"]["data"][number];
⋮----
onOpenChange=
</file>

<file path="platform/frontend/src/app/layout.tsx">
import type { Metadata } from "next";
import {
  Inter,
  Lato,
  Open_Sans,
  Roboto,
  Source_Sans_3,
} from "next/font/google";
import { PublicEnvScript } from "next-runtime-env";
import { SidebarProvider, SidebarTrigger } from "@/components/ui/sidebar";
import { PostHogProviderWrapper } from "./_parts/posthog-provider";
import { ArchestraQueryClientProvider } from "./_parts/query-client-provider";
import { AppSidebar } from "./_parts/sidebar";
import { ThemeProvider } from "./_parts/theme-provider";
⋮----
import { OnboardingDialogWrapper } from "@/components/onboarding-dialog-wrapper";
import { OrgThemeLoader } from "@/components/org-theme-loader";
import { Toaster } from "@/components/ui/sonner";
import { Version } from "@/components/version";
import { ChatProvider } from "@/contexts/global-chat-context";
import { WebsocketInitializer } from "./_parts/websocket-initializer";
import { WithAuthCheck } from "./_parts/with-auth-check";
import { WithPagePermissions } from "./_parts/with-page-permissions";
import { AuthProvider } from "./auth/auth-provider";
⋮----
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>)
</file>

<file path="platform/frontend/src/components/roles/roles-list.tsx">
import {
  allAvailableActions,
  type archestraApiTypes,
  type Permissions,
} from "@shared";
import { Plus, Shield, Trash2 } from "lucide-react";
import { useCallback, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  useCreateRole,
  useDeleteRole,
  useRoles,
  useUpdateRole,
} from "@/lib/role.query";
import { RolePermissionBuilder } from "./role-permission-builder";
type Role = archestraApiTypes.GetRoleResponses["200"];
⋮----
onChange=
</file>

<file path="platform/frontend/src/components/roles/with-permissions.tsx">
import type { Permissions } from "@shared";
import type React from "react";
import type { ReactElement } from "react";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useHasPermissions } from "@/lib/auth.query";
import { permissionsToStrings } from "@/lib/auth.utils";
type WithPermissionsProps = {
  permissions: Permissions;
} & (
  | {
      noPermissionHandle: "tooltip";
      children: ({ isDisabled }: { isDisabled: boolean }) => ReactElement;
    }
  | {
      noPermissionHandle: "hide";
      children: React.ReactNode;
    }
);
</file>

<file path="platform/frontend/src/components/archestra-architecture-diagram.tsx">
import Link from "next/link";
import { MermaidDiagram } from "@/components/mermaid-wrapper";
export function ArchestraArchitectureDiagram()
</file>

<file path="platform/frontend/src/components/environment-variables-form-field.tsx">
import { Plus, Trash2 } from "lucide-react";
import type {
  Control,
  FieldArrayWithId,
  FieldPath,
  FieldValues,
  UseFieldArrayAppend,
  UseFieldArrayRemove,
  UseFormSetValue,
  UseFormWatch,
} from "react-hook-form";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
interface EnvironmentVariablesFormFieldProps<TFieldValues extends FieldValues> {
  control: Control<TFieldValues>;
  fields: FieldArrayWithId<TFieldValues, any, "id">[];
  append: UseFieldArrayAppend<TFieldValues, any>;
  remove: UseFieldArrayRemove;
  fieldNamePrefix: string;
  form: {
    watch: UseFormWatch<TFieldValues>;
    setValue: UseFormSetValue<TFieldValues>;
  };
  showLabel?: boolean;
  showDescription?: boolean;
}
export function EnvironmentVariablesFormField<
  TFieldValues extends FieldValues,
>({
  control,
  fields,
  append,
  remove,
  fieldNamePrefix,
  form,
  showLabel = true,
  showDescription = true,
}: EnvironmentVariablesFormFieldProps<TFieldValues>)
⋮----
onCheckedChange=
⋮----
onClick=
</file>

<file path="platform/frontend/src/components/savings.tsx">
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { formatCost } from "./cost";
⋮----
<div>Baseline Cost:
⋮----
-
⋮----
<div>Baseline:
</file>

<file path="platform/frontend/src/lib/agent-tools.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
⋮----
type GetAllProfileToolsQueryParams = NonNullable<
  archestraApiTypes.GetAllAgentToolsData["query"]
>;
export function useAllProfileTools({
  initialData,
  pagination,
  sorting,
  filters,
}: {
  initialData?: archestraApiTypes.GetAllAgentToolsResponses["200"];
  pagination?: {
    limit?: number;
    offset?: number;
  };
  sorting?: {
    sortBy?: NonNullable<GetAllProfileToolsQueryParams["sortBy"]>;
    sortDirection?: NonNullable<GetAllProfileToolsQueryParams["sortDirection"]>;
  };
  filters?: {
    search?: string;
    agentId?: string;
    origin?: string;
    credentialSourceMcpServerId?: string;
    mcpServerOwnerId?: string;
  };
})
export function useAssignTool()
export function useBulkAssignTools()
export function useUnassignTool()
export function useProfileToolPatchMutation()
export function useBulkUpdateProfileTools()
</file>

<file path="platform/frontend/src/lib/policy.query.ts">
import { archestraApiSdk, type archestraApiTypes } from "@shared";
import {
  type QueryClient,
  useMutation,
  useQueryClient,
  useSuspenseQuery,
} from "@tanstack/react-query";
⋮----
export function useToolInvocationPolicies()
export function useOperators()
export function useToolInvocationPolicyDeleteMutation()
export function useToolInvocationPolicyCreateMutation()
export function useToolInvocationPolicyUpdateMutation()
export function useToolResultPolicies()
export function useToolResultPoliciesCreateMutation()
export function useToolResultPoliciesUpdateMutation()
export function useToolResultPoliciesDeleteMutation()
export function prefetchOperators(queryClient: QueryClient)
export function prefetchToolInvocationPolicies(queryClient: QueryClient)
export function prefetchToolResultPolicies(queryClient: QueryClient)
</file>

<file path="platform/shared/zod-schemas.ts">
import { z } from "zod";
import { THEME_IDS } from "./themes/theme-config";
⋮----
export type OrganizationTheme = z.infer<typeof OrganizationThemeSchema>;
export type OrganizationCustomFont = z.infer<
  typeof OrganizationCustomFontSchema
>;
⋮----
export type StatisticsTimeFrame = z.infer<typeof StatisticsTimeFrameSchema>;
⋮----
export type SsoProviderOidcConfig = z.infer<typeof SsoProviderOidcConfigSchema>;
export type SsoProviderSamlConfig = z.infer<typeof SsoProviderSamlConfigSchema>;
export type SsoProviderFormValues = z.infer<typeof SsoProviderFormSchema>;
</file>

<file path="platform/.npmrc">
# Security: Prevent automatic execution of install scripts
# Protects against supply-chain attacks like Shai-Hulud
# Packages requiring scripts must be manually rebuilt with: pnpm rebuild <package-name>
ignore-scripts=true

# Security: Delay installation of newly published packages
# Allows time for community detection of malicious releases
# 1440 minutes = 24 hours (provides strong protection against supply chain attacks)
minimum-release-age=1440

# OpenTelemetry instrumentation requires these packages hoisted to root
public-hoist-pattern[]=*import-in-the-middle*
public-hoist-pattern[]=*require-in-the-middle*
</file>

<file path="platform/backend/src/database/schemas/agent.ts">
import { boolean, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
</file>

<file path="platform/backend/src/database/schemas/index.ts">

</file>

<file path="platform/backend/src/models/agent.test.ts">
import { describe, expect, test } from "@/test";
import AgentModel from "./agent";
import TeamModel from "./team";
</file>

<file path="platform/backend/src/models/agent.ts">
import { DEFAULT_PROFILE_NAME } from "@shared";
import {
  and,
  asc,
  count,
  desc,
  eq,
  ilike,
  inArray,
  min,
  type SQL,
  sql,
} from "drizzle-orm";
import { isArchestraMcpServerTool } from "@/archestra-mcp-server";
import db, { schema } from "@/database";
import {
  createPaginatedResult,
  type PaginatedResult,
} from "@/database/utils/pagination";
import type {
  Agent,
  InsertAgent,
  PaginationQuery,
  SortingQuery,
  UpdateAgent,
} from "@/types";
import AgentLabelModel from "./agent-label";
import AgentTeamModel from "./agent-team";
import ToolModel from "./tool";
class AgentModel
⋮----
static async create({
    teams,
    labels,
    ...agent
}: InsertAgent): Promise<Agent>
static async findAll(
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<Agent[]>
static async findAllPaginated(
    pagination: PaginationQuery,
    sorting?: SortingQuery,
    filters?: { name?: string },
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<PaginatedResult<Agent>>
⋮----
// If no agents match, return early
⋮----
// Step 2: Get full agent data with tools for the paginated agent IDs
⋮----
// Sort in memory to maintain the order from the sorted query
⋮----
// Group the flat join results by agent
⋮----
// Add tool if it exists and is not an Archestra MCP tool (leftJoin returns null for agents with no tools)
⋮----
// Populate teams and labels for all agents with bulk queries to avoid N+1
⋮----
// Assign teams and labels to each agent
⋮----
/**
   * Helper to get the appropriate ORDER BY clause based on sorting params
   */
private static getOrderByClause(sorting?: SortingQuery)
⋮----
// toolsCount and team sorting use a separate query path (see lines 168-267).
// This fallback should never be reached for these sort types.
return direction(schema.agentsTable.createdAt); // Fallback
⋮----
// Default: newest first
⋮----
/**
   * Check if an agent exists without loading related data (teams, labels, tools).
   * Use this for validation to avoid N+1 queries in bulk operations.
   */
static async exists(id: string): Promise<boolean>
/**
   * Batch check if multiple agents exist.
   * Returns a Set of agent IDs that exist.
   */
static async existsBatch(ids: string[]): Promise<Set<string>>
static async findById(
    id: string,
    userId?: string,
    isAgentAdmin?: boolean,
): Promise<Agent | null>
⋮----
// Check access control for non-agent admins
⋮----
static async getAgentOrCreateDefault(name?: string): Promise<Agent>
⋮----
// First, try to find an agent with isDefault=true
⋮----
// Default agent exists, return it
⋮----
// No default agent exists, create one
⋮----
static async update(
    id: string,
    { teams, labels, ...agent }: Partial<UpdateAgent>,
): Promise<Agent | null>
⋮----
// If setting isDefault to true, unset all other agents' isDefault first
⋮----
static async delete(id: string): Promise<boolean>
</file>

<file path="platform/backend/src/models/index.ts">

</file>

<file path="platform/backend/src/models/tool.test.ts">
import { describe, expect, test } from "@/test";
import AgentToolModel from "./agent-tool";
import TeamModel from "./team";
import ToolModel from "./tool";
</file>

<file path="platform/backend/src/routes/proxy/utils/adapters/anthropic.ts">
import { encode as toonEncode } from "@toon-format/toon";
import logger from "@/logging";
import { TokenPriceModel } from "@/models";
import { getTokenizer } from "@/tokenizers";
import type {
  Anthropic,
  CommonMessage,
  CommonToolCall,
  CommonToolResult,
  ToolResultUpdates,
} from "@/types";
import type { CompressionStats } from "../toon-conversion";
type AnthropicMessages = Anthropic.Types.MessagesRequest["messages"];
export function toCommonFormat(messages: AnthropicMessages): CommonMessage[]
export function applyUpdates(
  messages: AnthropicMessages,
  updates: ToolResultUpdates,
): AnthropicMessages
function extractToolNameFromMessages(
  messages: AnthropicMessages,
  toolUseId: string,
): string | null
export function extractUserRequest(messages: AnthropicMessages): string
export function toolCallsToCommon(
  toolUseBlocks: Array<{
    id: string;
    name: string;
    input: Record<string, unknown>;
  }>,
): CommonToolCall[]
export function toolResultsToMessages(
  results: CommonToolResult[],
  convertToToon = false,
): Array<
export async function convertToolResultsToToon(
  messages: AnthropicMessages,
  model: string,
): Promise<
export function getUsageTokens(usage: Anthropic.Types.Usage)
</file>

<file path="platform/backend/src/routes/proxy/utils/adapters/openai.ts">
import { encode as toonEncode } from "@toon-format/toon";
import logger from "@/logging";
import { TokenPriceModel } from "@/models";
import { getTokenizer } from "@/tokenizers";
import type {
  CommonMessage,
  CommonToolCall,
  CommonToolResult,
  OpenAi,
  ToolResultUpdates,
} from "@/types";
import type { CompressionStats } from "../toon-conversion";
type OpenAiMessages = OpenAi.Types.ChatCompletionsRequest["messages"];
export function toCommonFormat(messages: OpenAiMessages): CommonMessage[]
export function applyUpdates(
  messages: OpenAiMessages,
  updates: ToolResultUpdates,
): OpenAiMessages
function extractToolNameFromMessages(
  messages: OpenAiMessages,
  toolCallId: string,
): string | null
export function extractUserRequest(messages: OpenAiMessages): string
export function toolCallsToCommon(
  toolCalls: Array<{
    id: string;
    type: string;
    function?: { name: string; arguments: string };
    custom?: { name: string; input: string };
  }>,
): CommonToolCall[]
export function toolResultsToMessages(
  results: CommonToolResult[],
  convertToToon = false,
): Array<
export async function convertToolResultsToToon(
  messages: OpenAiMessages,
  model: string,
): Promise<
export function getUsageTokens(usage: OpenAi.Types.Usage)
</file>

<file path="platform/backend/src/routes/proxy/utils/cost-optimization.ts">
import { inArray, sql } from "drizzle-orm";
import db, { schema } from "@/database";
import logger from "@/logging";
import {
  AgentTeamModel,
  OptimizationRuleModel,
  TokenPriceModel,
} from "@/models";
import { getTokenizer } from "@/tokenizers";
import type { Agent, Anthropic, OpenAi } from "@/types";
type ProviderMessages = {
  openai: OpenAi.Types.ChatCompletionsRequest["messages"];
  anthropic: Anthropic.Types.MessagesRequest["messages"];
};
export async function getOptimizedModel<
  Provider extends keyof ProviderMessages,
>(
  agent: Agent,
  messages: ProviderMessages[Provider],
  provider: Provider,
  hasTools: boolean,
): Promise<string | null>
export async function calculateCost(
  model: string,
  inputTokens: number | null | undefined,
  outputTokens: number | null | undefined,
): Promise<number | undefined>
</file>

<file path="platform/backend/src/test/fixtures.ts">
import { MEMBER_ROLE_NAME } from "@shared";
import { beforeEach as baseBeforeEach, test as baseTest } from "vitest";
import db, { schema } from "@/database";
import {
  AgentModel,
  AgentToolModel,
  InternalMcpCatalogModel,
  SessionModel,
  ToolInvocationPolicyModel,
  ToolModel,
  TrustedDataPolicyModel,
} from "@/models";
import type {
  Agent,
  AgentTool,
  InsertAccount,
  InsertConversation,
  InsertInteraction,
  InsertInternalMcpCatalog,
  InsertInvitation,
  InsertMcpServer,
  InsertMember,
  InsertOrganization,
  InsertOrganizationRole,
  InsertSession,
  InsertTeam,
  InsertUser,
  OrganizationRole,
  Tool,
  ToolInvocation,
  TrustedData,
} from "@/types";
type MakeUserOverrides = Partial<
  Pick<InsertUser, "email" | "name" | "emailVerified">
>;
interface TestFixtures {
  makeUser: typeof makeUser;
  makeAdmin: typeof makeAdmin;
  makeOrganization: typeof makeOrganization;
  makeTeam: typeof makeTeam;
  makeAgent: typeof makeAgent;
  makeTool: typeof makeTool;
  makeAgentTool: typeof makeAgentTool;
  makeToolPolicy: typeof makeToolPolicy;
  makeTrustedDataPolicy: typeof makeTrustedDataPolicy;
  makeCustomRole: typeof makeCustomRole;
  makeMember: typeof makeMember;
  makeMcpServer: typeof makeMcpServer;
  makeInternalMcpCatalog: typeof makeInternalMcpCatalog;
  makeInvitation: typeof makeInvitation;
  makeAccount: typeof makeAccount;
  makeSession: typeof makeSession;
  makeAuthHeaders: typeof makeAuthHeaders;
  makeConversation: typeof makeConversation;
  makeInteraction: typeof makeInteraction;
  makeSecret: typeof makeSecret;
  makeSsoProvider: typeof makeSsoProvider;
}
async function _makeUser(
  namePrefix: string,
  overrides: MakeUserOverrides = {},
)
async function makeUser(overrides: MakeUserOverrides =
async function makeAdmin(overrides: MakeUserOverrides =
async function makeOrganization(
  overrides: Partial<Pick<InsertOrganization, "name" | "slug">> = {},
)
async function makeTeam(
  organizationId: string,
  createdBy: string,
  overrides: Partial<Pick<InsertTeam, "name" | "description">> = {},
)
async function makeAgent(
  overrides: Partial<Pick<Agent, "name" | "teams" | "labels">> = {},
): Promise<Agent>
async function makeTool(
  overrides: Partial<
    Pick<
      Tool,
      | "name"
      | "description"
      | "parameters"
      | "catalogId"
      | "mcpServerId"
      | "agentId"
    >
  > = {},
): Promise<Tool>
async function makeAgentTool(
  agentId: string,
  toolId: string,
  overrides: Partial<
    Pick<
      AgentTool,
      | "allowUsageWhenUntrustedDataIsPresent"
      | "toolResultTreatment"
      | "credentialSourceMcpServerId"
      | "executionSourceMcpServerId"
    >
  > = {},
)
async function makeToolPolicy(
  agentToolId: string,
  overrides: Partial<
    Pick<
      ToolInvocation.ToolInvocationPolicy,
      "argumentName" | "operator" | "value" | "action" | "reason"
    >
  > = {},
): Promise<ToolInvocation.ToolInvocationPolicy>
async function makeTrustedDataPolicy(
  agentToolId: string,
  overrides: Partial<
    Pick<
      TrustedData.TrustedDataPolicy,
      "description" | "attributePath" | "operator" | "value" | "action"
    >
  > = {},
): Promise<TrustedData.TrustedDataPolicy>
async function makeCustomRole(
  organizationId: string,
  overrides: Partial<
    Pick<InsertOrganizationRole, "role" | "name" | "permission">
  > = {},
): Promise<OrganizationRole>
async function makeMember(
  userId: string,
  organizationId: string,
  overrides: Partial<Pick<InsertMember, "role">> = {},
)
async function makeMcpServer(
  overrides: Partial<
    Pick<InsertMcpServer, "name" | "catalogId" | "ownerId">
  > = {},
)
async function makeInternalMcpCatalog(
  overrides: Partial<
    Pick<
      InsertInternalMcpCatalog,
      | "name"
      | "serverType"
      | "serverUrl"
      | "description"
      | "version"
      | "repository"
      | "installationCommand"
      | "requiresAuth"
      | "authDescription"
      | "authFields"
      | "localConfig"
      | "userConfig"
      | "oauthConfig"
    >
  > = {},
)
async function makeInvitation(
  organizationId: string,
  inviterId: string,
  overrides: Partial<Pick<InsertInvitation, "email" | "role" | "status">> = {},
)
async function makeAccount(
  userId: string,
  overrides: Partial<
    Pick<InsertAccount, "accountId" | "providerId" | "accessToken">
  > = {},
)
async function makeSession(
  userId: string,
  overrides: Partial<
    Pick<
      InsertSession,
      | "token"
      | "expiresAt"
      | "ipAddress"
      | "userAgent"
      | "activeOrganizationId"
      | "impersonatedBy"
    >
  > = {},
)
function makeAuthHeaders(sessionToken: string): HeadersInit
async function makeConversation(
  agentId: string,
  overrides: Partial<
    Pick<
      InsertConversation,
      "userId" | "organizationId" | "title" | "selectedModel"
    >
  > = {},
)
async function makeInteraction(
  agentId: string,
  overrides: Partial<
    Pick<
      InsertInteraction,
      "request" | "response" | "type" | "model" | "inputTokens" | "outputTokens"
    >
  > = {},
)
async function makeSecret(
  overrides: Partial<{ secret: Record<string, unknown> }> = {},
)
async function makeSsoProvider(
  organizationId: string,
  overrides: {
    providerId?: string;
    issuer?: string;
    domain?: string;
    oidcConfig?: Record<string, unknown>;
    samlConfig?: Record<string, unknown>;
    userId?: string | null;
  } = {},
)
</file>

<file path="platform/e2e-tests/auth.setup.ts">
import path from "node:path";
import { expect, test as setup } from "@playwright/test";
import dotenv from "dotenv";
import {
  DEFAULT_ADMIN_EMAIL,
  DEFAULT_ADMIN_PASSWORD,
  UI_BASE_URL,
} from "./consts";
</file>

<file path="platform/frontend/src/app/cost/statistics/page.tsx">
import {
  CategoryScale,
  Chart as ChartJS,
  Filler,
  Legend,
  LinearScale,
  LineElement,
  PointElement,
  Title,
  Tooltip,
  type TooltipItem,
} from "chart.js";
import { format } from "date-fns";
import { Calendar as CalendarIcon, Clock, Info } from "lucide-react";
import { useRouter, useSearchParams } from "next/navigation";
import { useCallback, useEffect, useMemo, useState } from "react";
import { Line } from "react-chartjs-2";
import type { DateRange } from "react-day-picker";
⋮----
import type { archestraApiTypes } from "@shared";
import { type StatisticsTimeFrame, StatisticsTimeFrameSchema } from "@shared";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  useCostSavingsStatistics,
  useModelStatistics,
  useProfileStatistics,
  useTeamStatistics,
} from "@/lib/statistics.query";
type TeamStatisticsData =
  archestraApiTypes.GetTeamStatisticsResponses["200"][number];
type ProfileStatisticsData =
  archestraApiTypes.GetAgentStatisticsResponses["200"][number];
type ModelStatisticsData =
  archestraApiTypes.GetModelStatisticsResponses["200"][number];
type StatisticsData =
  | TeamStatisticsData
  | ProfileStatisticsData
  | ModelStatisticsData;
function isTeamStatistics(data: StatisticsData): data is TeamStatisticsData
function isProfileStatistics(
  data: StatisticsData,
): data is ProfileStatisticsData
function isModelStatistics(data: StatisticsData): data is ModelStatisticsData
⋮----
type ChartInstance = {
  data: {
    datasets: unknown[];
  };
  isDatasetVisible: (index: number) => boolean;
};
type ChartEventArgs = {
  event: {
    type: string;
  };
};
function createVisibilitySyncPlugin<T>(
  id: string,
  data: T[],
  getKey: (item: T) => string,
  setHidden: React.Dispatch<React.SetStateAction<Set<string>>>,
)
⋮----
// Helper function to convert statistics to chart format
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/bulk-assign-agent-dialog.tsx">
import { Search } from "lucide-react";
import { useCallback, useMemo, useState } from "react";
import { toast } from "sonner";
import { InstallationSelect } from "@/components/installation-select";
import { TokenSelect } from "@/components/token-select";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useProfiles } from "@/lib/agent.query";
import { useBulkAssignTools } from "@/lib/agent-tools.query";
import { useMcpServers } from "@/lib/mcp-server.query";
interface BulkAssignProfileDialogProps {
  tools: Array<{
    id: string;
    name: string;
    description: string | null;
    parameters: Record<string, unknown>;
    createdAt: string;
  }> | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  catalogId: string;
}
⋮----
// Determine if tools are from local server by checking catalogId
⋮----
onOpenChange(newOpen);
</file>

<file path="platform/frontend/src/app/profiles/assign-tools-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Loader2, Search, Server } from "lucide-react";
import Link from "next/link";
import { useCallback, useEffect, useMemo, useState } from "react";
import { toast } from "sonner";
import { InstallationSelect } from "@/components/installation-select";
import { TokenSelect } from "@/components/token-select";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  useAllProfileTools,
  useAssignTool,
  useProfileToolPatchMutation,
  useUnassignTool,
} from "@/lib/agent-tools.query";
import { useInternalMcpCatalog } from "@/lib/internal-mcp-catalog.query";
import { useTools } from "@/lib/tool.query";
interface AssignToolsDialogProps {
  agent: archestraApiTypes.GetAllAgentsResponses["200"][number];
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
⋮----
// Filter tools based on search query
⋮----
// Initialize selected tools when agent tools load
⋮----
// Remove the tool
⋮----
// Add the tool
⋮----
// Get current tool IDs and their state
⋮----
// Determine which tools to assign, unassign, and update
⋮----
// Assign new tools
⋮----
// Unassign removed tools
⋮----
// Update credentials and execution source for existing tools
</file>

<file path="platform/frontend/src/app/tools/_parts/assign-agent-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Search } from "lucide-react";
import { useCallback, useMemo, useState } from "react";
import { toast } from "sonner";
import { InstallationSelect } from "@/components/installation-select";
import { TokenSelect } from "@/components/token-select";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useProfiles } from "@/lib/agent.query";
import { useAssignTool } from "@/lib/agent-tools.query";
import { useInternalMcpCatalog } from "@/lib/internal-mcp-catalog.query";
interface AssignProfileDialogProps {
  tool:
    | archestraApiTypes.GetAllAgentToolsResponses["200"]["data"][number]
    | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
⋮----
// Determine if tool is from local server
⋮----
const isDuplicateError = (error: unknown): boolean =>
⋮----
onOpenChange(newOpen);
</file>

<file path="platform/frontend/src/app/tools/_parts/assigned-tools-table.tsx">
import type { archestraApiTypes } from "@shared";
import type {
  ColumnDef,
  RowSelectionState,
  SortingState,
} from "@tanstack/react-table";
import { ChevronDown, ChevronUp, Search, Unplug } from "lucide-react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { useCallback, useMemo, useState } from "react";
import { toast } from "sonner";
import { DebouncedInput } from "@/components/debounced-input";
import { InstallationSelect } from "@/components/installation-select";
import { LoadingSpinner } from "@/components/loading";
import { TokenSelect } from "@/components/token-select";
import { TruncatedText } from "@/components/truncated-text";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { ButtonGroup } from "@/components/ui/button-group";
import { Checkbox } from "@/components/ui/checkbox";
import { DataTable } from "@/components/ui/data-table";
import { PermissionButton } from "@/components/ui/permission-button";
import { SearchableSelect } from "@/components/ui/searchable-select";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useProfiles } from "@/lib/agent.query";
import {
  useAllProfileTools,
  useBulkUpdateProfileTools,
  useProfileToolPatchMutation,
  useUnassignTool,
} from "@/lib/agent-tools.query";
import { useInternalMcpCatalog } from "@/lib/internal-mcp-catalog.query";
import { useMcpServers } from "@/lib/mcp-server.query";
import {
  useToolInvocationPolicies,
  useToolResultPolicies,
} from "@/lib/policy.query";
import { isMcpTool } from "@/lib/tool.utils";
type GetAllProfileToolsQueryParams = NonNullable<
  archestraApiTypes.GetAllAgentToolsData["query"]
>;
type ProfileToolsSortByValues = NonNullable<
  GetAllProfileToolsQueryParams["sortBy"]
> | null;
type ProfileToolsSortDirectionValues = NonNullable<
  GetAllProfileToolsQueryParams["sortDirection"]
> | null;
type ProfileToolData =
  archestraApiTypes.GetAllAgentToolsResponses["200"]["data"][number];
type ToolResultTreatment = ProfileToolData["toolResultTreatment"];
interface AssignedToolsTableProps {
  onToolClick: (tool: ProfileToolData) => void;
}
function SortIcon(
⋮----
onCheckedChange=
⋮----
const handleUnassign = async (e: React.MouseEvent) =>
⋮----
if (!isMcpTool(row.original.tool))
⋮----
onValueChange=
</file>

<file path="platform/frontend/src/app/tools/_parts/tool-details-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { TruncatedText } from "@/components/truncated-text";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useInternalMcpCatalog } from "@/lib/internal-mcp-catalog.query";
import { isMcpTool } from "@/lib/tool.utils";
import { formatDate } from "@/lib/utils";
import { ResponseModifierEditor } from "./response-modifier-editor";
import { ToolCallPolicies } from "./tool-call-policies";
import { ToolReadonlyDetails } from "./tool-readonly-details";
import { ToolResultPolicies } from "./tool-result-policies";
interface ToolDetailsDialogProps {
  agentTool:
    | archestraApiTypes.GetAllAgentToolsResponses["200"]["data"][number]
    | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
</file>

<file path="platform/frontend/src/app/tools/_parts/tool-result-policies.tsx">
import type { archestraApiTypes } from "@shared";
import { toPath } from "lodash-es";
import { ArrowRightIcon, Plus, Trash2Icon } from "lucide-react";
import { CodeText } from "@/components/code-text";
import { DebouncedInput } from "@/components/debounced-input";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useProfileToolPatchMutation } from "@/lib/agent-tools.query";
import {
  useOperators,
  useToolResultPolicies,
  useToolResultPoliciesCreateMutation,
  useToolResultPoliciesDeleteMutation,
  useToolResultPoliciesUpdateMutation,
} from "@/lib/policy.query";
import { PolicyCard } from "./policy-card";
function AttributePathExamples()
⋮----
].map(({ value, label }) => (
                    <SelectItem key={label} value={value}>
                      {label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
        </PolicyCard>
      ))}
      <Button
        variant="outline"
        className="w-full"
onClick=
</file>

<file path="platform/frontend/src/lib/config.ts">
import { env } from "next-runtime-env";
import type { PostHogConfig } from "posthog-js";
⋮----
const getBackendBaseUrl = (): string | undefined
export const getDisplayProxyUrl = (): string =>
const getWebSocketUrl = (): string =>
⋮----
get displayProxyUrl()
⋮----
/**
     * WebSocket URL for real-time communication
     */
get url()
⋮----
get enabled()
⋮----
get baseMcpServerDockerImage()
⋮----
get enableTeamAuth()
⋮----
get enterpriseLicenseActivated()
⋮----
get dsn()
get environment()
</file>

<file path="platform/shared/consts.ts">
export type E2eTestId = (typeof E2eTestId)[keyof typeof E2eTestId];
⋮----
export type SsoProviderId =
  (typeof SSO_PROVIDER_ID)[keyof typeof SSO_PROVIDER_ID];
</file>

<file path="platform/backend/src/auth/better-auth.ts">
import { sso } from "@better-auth/sso";
import {
  ADMIN_ROLE_NAME,
  ac,
  adminRole,
  allAvailableActions,
  MEMBER_ROLE_NAME,
  memberRole,
  SSO_TRUSTED_PROVIDER_IDS,
} from "@shared";
import { APIError, betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { createAuthMiddleware } from "better-auth/api";
import { admin, apiKey, organization, twoFactor } from "better-auth/plugins";
import { eq } from "drizzle-orm";
import { z } from "zod";
import config from "@/config";
import db, { schema } from "@/database";
import logger from "@/logging";
import { InvitationModel, MemberModel, SessionModel } from "@/models";
⋮----
const isHttps = () =>
</file>

<file path="platform/backend/src/models/optimization-rule.ts">
import { and, eq, getTableColumns, or } from "drizzle-orm";
import db, { schema } from "@/database";
import getDefaultModelPrice from "@/default-model-prices";
import type {
  ContentLengthConditions,
  InsertOptimizationRule,
  InsertTokenPrice,
  OptimizationRule,
  SupportedProvider,
  ToolPresenceConditions,
  UpdateOptimizationRule,
} from "@/types";
class OptimizationRuleModel
⋮----
static async create(data: InsertOptimizationRule): Promise<OptimizationRule>
static async findByOrganizationId(
    organizationId: string,
): Promise<OptimizationRule[]>
static async findEnabledByOrganizationAndProvider(
    organizationId: string,
    provider: SupportedProvider,
): Promise<OptimizationRule[]>
static async update(
    id: string,
    data: Partial<UpdateOptimizationRule>,
): Promise<OptimizationRule | undefined>
static async delete(id: string): Promise<boolean>
static matchByRules(
    rules: OptimizationRule[],
    context: {
      tokenCount: number;
      hasTools: boolean;
    },
): string | null
private static async getAllProvidersFromInteractions(): Promise<
    SupportedProvider[]
  > {
    const results = await db
      .select({
        providerDiscriminator: schema.interactionsTable.type,
      })
      .from(schema.interactionsTable)
      .groupBy(schema.interactionsTable.type);
static async ensureDefaultOptimizationRules(
    organizationId: string,
): Promise<void>
</file>

<file path="platform/backend/src/models/prompt.ts">
import { and, desc, eq, inArray } from "drizzle-orm";
import db, { schema } from "@/database";
import type { InsertPrompt, Prompt, UpdatePrompt } from "@/types";
class PromptModel
⋮----
static async create(
    organizationId: string,
    input: InsertPrompt,
): Promise<Prompt>
static async findByOrganizationId(organizationId: string): Promise<Prompt[]>
static async findByOrganizationIdAndAccessibleAgents(
    organizationId: string,
    accessibleAgentIds: string[],
): Promise<Prompt[]>
static async findByAgentId(agentId: string): Promise<Prompt[]>
static async findById(id?: string | null): Promise<Prompt | null>
static async findByIdAndOrganizationId(
    id: string,
    organizationId: string,
): Promise<Prompt | null>
static async findVersions(promptId: string): Promise<Prompt[]>
static async update(id: string, input: UpdatePrompt): Promise<Prompt | null>
static async rollback(
    id: string,
    targetVersionId: string,
): Promise<Prompt | null>
static async delete(id: string): Promise<boolean>
</file>

<file path="platform/backend/src/routes/agent-tool.ts">
import { RouteId } from "@shared";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { groupBy } from "lodash-es";
import { z } from "zod";
import { hasPermission } from "@/auth";
import { clearChatMcpClient } from "@/clients/chat-mcp-client";
import {
  AgentModel,
  AgentTeamModel,
  AgentToolModel,
  InternalMcpCatalogModel,
  McpServerModel,
  ToolModel,
  UserModel,
} from "@/models";
import type { InternalMcpCatalog, Tool } from "@/types";
import {
  AgentToolFilterSchema,
  AgentToolSortBySchema,
  AgentToolSortDirectionSchema,
  ApiError,
  BulkUpdateAgentToolsRequestSchema,
  BulkUpdateAgentToolsResponseSchema,
  constructResponseSchema,
  createPaginatedResponseSchema,
  DeleteObjectResponseSchema,
  PaginationQuerySchema,
  SelectAgentToolSchema,
  SelectToolSchema,
  UpdateAgentToolSchema,
  UuidIdSchema,
} from "@/types";
const agentToolRoutes: FastifyPluginAsyncZod = async (fastify) =>
export async function assignToolToAgent(
  agentId: string,
  toolId: string,
  credentialSourceMcpServerId: string | null | undefined,
  executionSourceMcpServerId: string | null | undefined,
  preFetchedData?: {
    existingAgentIds?: Set<string>;
    toolsMap?: Map<string, Tool>;
    catalogItemsMap?: Map<string, InternalMcpCatalog>;
  },
): Promise<
  | {
      status: 400 | 404;
      error: { message: string; type: string };
    }
  | "duplicate"
  | "updated"
  | null
> {
  let agentExists: boolean;
if (preFetchedData?.existingAgentIds)
async function validateCredentialSource(
  agentId: string,
  credentialSourceMcpServerId: string,
): Promise<
async function validateExecutionSource(
  toolId: string,
  executionSourceMcpServerId: string,
): Promise<
</file>

<file path="platform/backend/src/types/index.ts">

</file>

<file path="platform/frontend/src/app/_parts/with-auth-check.tsx">
import { usePathname, useRouter } from "next/navigation";
import type React from "react";
import { useEffect, useState } from "react";
import { authClient } from "@/lib/clients/auth/auth-client";
const pathCorrespondsToAnAuthPage = (pathname: string) =>
const isSpecialAuthPage = (pathname: string) =>
export const WithAuthCheck: React.FC<React.PropsWithChildren> = ({
  children,
}) =>
</file>

<file path="platform/frontend/src/components/chat/mcp-tools-display.tsx">
import { MCP_SERVER_TOOL_NAME_SEPARATOR } from "@shared";
import { Loader2, Plus } from "lucide-react";
import { useMemo, useState } from "react";
import { AssignToolsDialog } from "@/app/profiles/assign-tools-dialog";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useProfile } from "@/lib/agent.query";
import { useChatProfileMcpTools } from "@/lib/chat.query";
import { Button } from "../ui/button";
interface McpToolsDisplayProps {
  agentId: string;
  className?: string;
}
⋮----
onTouchMove=
</file>

<file path="platform/frontend/src/components/chat/prompt-version-history-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Check, Loader2, RotateCcw } from "lucide-react";
import { toast } from "sonner";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { usePromptVersions, useRollbackPrompt } from "@/lib/prompts.query";
import { formatDate } from "@/lib/utils";
import { TruncatedText } from "../truncated-text";
type Prompt = archestraApiTypes.GetPromptsResponses["200"][number];
interface PromptVersionHistoryDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  prompt: Prompt | null;
}
⋮----
const handleRollback = async (versionId: string) =>
</file>

<file path="platform/backend/src/routes/proxy/anthropic.ts">
import AnthropicProvider from "@anthropic-ai/sdk";
import fastifyHttpProxy from "@fastify/http-proxy";
import { RouteId } from "@shared";
import type { FastifyReply } from "fastify";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import { get } from "lodash-es";
import { z } from "zod";
import config from "@/config";
import getDefaultPricing from "@/default-model-prices";
import {
  getObservableFetch,
  reportBlockedTools,
  reportLLMTokens,
} from "@/llm-metrics";
import {
  AgentModel,
  InteractionModel,
  LimitValidationService,
  TokenPriceModel,
} from "@/models";
import {
  type Agent,
  Anthropic,
  constructResponseSchema,
  UuidIdSchema,
} from "@/types";
import { PROXY_API_PREFIX } from "./common";
import { MockAnthropicClient } from "./mock-anthropic-client";
</file>

<file path="platform/backend/src/routes/proxy/openai.ts">
import fastifyHttpProxy from "@fastify/http-proxy";
import { RouteId } from "@shared";
import type { FastifyReply } from "fastify";
import type { FastifyPluginAsyncZod } from "fastify-type-provider-zod";
import OpenAIProvider from "openai";
import { z } from "zod";
import config from "@/config";
import getDefaultPricing from "@/default-model-prices";
import {
  getObservableFetch,
  reportBlockedTools,
  reportLLMTokens,
} from "@/llm-metrics";
import {
  AgentModel,
  InteractionModel,
  LimitValidationService,
  TokenPriceModel,
} from "@/models";
import {
  type Agent,
  constructResponseSchema,
  OpenAi,
  UuidIdSchema,
} from "@/types";
import { PROXY_API_PREFIX } from "./common";
import { MockOpenAIClient } from "./mock-openai-client";
</file>

<file path="platform/backend/src/routes/index.ts">

</file>

<file path="platform/frontend/src/app/_parts/sidebar.tsx">
import { SignedIn, SignedOut, UserButton } from "@daveyplate/better-auth-ui";
import { requiredPagePermissionsMap } from "@shared";
import {
  BookOpen,
  Bot,
  Bug,
  DollarSign,
  Github,
  LogIn,
  type LucideIcon,
  MessageCircle,
  MessagesSquare,
  Router,
  Settings,
  Slack,
  Star,
  Wrench,
} from "lucide-react";
import Image from "next/image";
import Link from "next/link";
import { usePathname, useSearchParams } from "next/navigation";
import { ChatSidebarSection } from "@/app/_parts/chat-sidebar-section";
import { DefaultCredentialsWarning } from "@/components/default-credentials-warning";
import { WithPermissions } from "@/components/roles/with-permissions";
import { Badge } from "@/components/ui/badge";
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import { useIsAuthenticated } from "@/lib/auth.hook";
import { usePermissionMap } from "@/lib/auth.query";
import config from "@/lib/config";
import { useGithubStars } from "@/lib/github.query";
import { useOrgTheme } from "@/lib/theme.hook";
interface MenuItem {
  title: string;
  url: string;
  icon: LucideIcon;
  customIsActive?: (pathname: string, searchParams: URLSearchParams) => boolean;
}
const getNavigationItems = (isAuthenticated: boolean): MenuItem[] =>
⋮----
const CommunitySideBarSection = ({ starCount }: { starCount: number }) => (
  <SidebarGroup className="px-4 py-0">
    <SidebarGroupLabel>Community</SidebarGroupLabel>
    <SidebarGroupContent>
      <SidebarMenu>
        <SidebarMenuItem>
          <SidebarMenuButton asChild>
            <a
              href="https://github.com/archestra-ai/archestra"
              target="_blank"
              rel="noopener noreferrer"
            >
              <Github />
              <span className="flex items-center gap-2">
                Star us on GitHub
                <span className="flex items-center gap-1 text-xs">
                  <Star className="h-3 w-3" />
                  {starCount}
                </span>
              </span>
            </a>
          </SidebarMenuButton>
        </SidebarMenuItem>
        <SidebarMenuItem>
          <SidebarMenuButton asChild>
            <a
              href="https://archestra.ai/docs/"
              target="_blank"
              rel="noopener noreferrer"
            >
              <BookOpen />
              <span>Documentation</span>
            </a>
          </SidebarMenuButton>
        </SidebarMenuItem>
        <SidebarMenuItem>
          <SidebarMenuButton asChild>
            <a
              href="https://join.slack.com/t/archestracommunity/shared_invite/zt-39yk4skox-zBF1NoJ9u4t59OU8XxQChg"
              target="_blank"
              rel="noopener noreferrer"
            >
              <Slack />
              <span>Talk to developers</span>
            </a>
          </SidebarMenuButton>
        </SidebarMenuItem>
        <SidebarMenuItem>
          <SidebarMenuButton asChild>
            <a
              href="https://github.com/archestra-ai/archestra/issues/new"
              target="_blank"
              rel="noopener noreferrer"
            >
              <Bug />
              <span>Report a bug</span>
            </a>
          </SidebarMenuButton>
        </SidebarMenuItem>
      </SidebarMenu>
    </SidebarGroupContent>
  </SidebarGroup>
);
⋮----
item.customIsActive?.(pathname, searchParams) ??
pathname.startsWith(item.url)
</file>

<file path="platform/frontend/src/app/cost/optimization-rules/page.tsx">
import { Edit, Info, Plus, Save, Trash2, X } from "lucide-react";
import Link from "next/link";
import { useCallback, useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import { WithPermissions } from "@/components/roles/with-permissions";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import type {
  CreateOptimizationRuleInput,
  OptimizationRule,
} from "@/lib/optimization-rule.query";
import {
  useCreateOptimizationRule,
  useDeleteOptimizationRule,
  useOptimizationRules,
  useUpdateOptimizationRule,
} from "@/lib/optimization-rule.query";
import { useOrganization } from "@/lib/organization.query";
import { useTeams } from "@/lib/team.query";
import { useTokenPrices } from "@/lib/token-price.query";
type RuleFormData = {
  id?: string;
  entityType: OptimizationRule["entityType"];
  entityId: string;
  ruleType: OptimizationRule["ruleType"];
  maxLength?: string;
  hasTools?: boolean;
  provider: OptimizationRule["provider"];
  targetModel: string;
  enabled: boolean;
};
function LoadingSkeleton(
⋮----
// Inline Form Component for adding/editing optimization rules
⋮----
setFormData(
⋮----
if (isValid) handleSubmit();
⋮----
onClick=
⋮----
{orderedRules.map((rule) => (
                    <OptimizationRuleRow
                      key={rule.id}
                      rule={rule}
                      isEditing={editingRuleId === rule.id}
                      isAddingRule={isAddingRule}
                      onEdit={() => setEditingRuleId(rule.id)}
                      onSave={(data) => handleUpdateRule(rule.id, data)}
                      onCancel={handleCancelEdit}
                      onDelete={() => handleDeleteRule(rule.id)}
onToggleEnabled=
⋮----
onToggleEnabled=
</file>

<file path="platform/frontend/src/app/mcp-catalog/_parts/mcp-server-card.tsx">
import type { archestraApiTypes } from "@shared";
import {
  Building2,
  FileText,
  Info,
  MoreVertical,
  Pencil,
  RefreshCw,
  Trash2,
  User,
  Wrench,
} from "lucide-react";
import { useCallback, useState } from "react";
import { AssignProfileDialog } from "@/app/tools/_parts/assign-agent-dialog";
import { LoadingSpinner } from "@/components/loading";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { LOCAL_MCP_DISABLED_MESSAGE } from "@/consts";
import { useHasPermissions } from "@/lib/auth.query";
import { authClient } from "@/lib/clients/auth/auth-client";
import config from "@/lib/config";
import { useFeatureFlag } from "@/lib/features.hook";
import {
  useMcpServers,
  useMcpServerTools,
  useRevokeAllTeamsMcpServerAccess,
  useRevokeUserMcpServerAccess,
} from "@/lib/mcp-server.query";
import { BulkAssignProfileDialog } from "./bulk-assign-agent-dialog";
import { ManageLocalInstallationsDialog } from "./manage-local-installations-dialog";
import { ManageTeamsDialog } from "./manage-teams-dialog";
import { ManageUsersDialog } from "./manage-users-dialog";
import { McpLogsDialog } from "./mcp-logs-dialog";
import { McpToolsDialog } from "./mcp-tools-dialog";
import { TransportBadges } from "./transport-badges";
import { UninstallServerDialog } from "./uninstall-server-dialog";
export type CatalogItem =
  archestraApiTypes.GetInternalMcpCatalogResponses["200"][number];
export type CatalogItemWithOptionalLabel = CatalogItem & {
  label?: string | null;
};
export type InstalledServer =
  archestraApiTypes.GetMcpServersResponses["200"][number];
type ToolForAssignment = {
  id: string;
  name: string;
  description: string | null;
  parameters: Record<string, unknown>;
  createdAt: string;
  mcpServerId: string | null;
  mcpServerName: string | null;
};
type SimpleTool = {
  id: string;
  name: string;
  description: string | null;
  parameters: Record<string, unknown>;
  createdAt: string;
};
export type McpServerCardProps = {
  item: CatalogItemWithOptionalLabel;
  installedServer?:
    | (InstalledServer & {
        currentUserHasTeamAuth?: boolean;
      })
    | null;
  installingItemId: string | null;
  installationStatus?:
    | "error"
    | "pending"
    | "success"
    | "idle"
    | "discovering-tools"
    | null;
  onInstallRemoteServer: () => void;
  onInstallRemoteServerTeam: () => void;
  onInstallLocalServer: () => void;
  onInstallLocalServerTeam: () => void;
  onReinstall: () => void;
  onDetails: () => void;
  onEdit: () => void;
  onDelete: () => void;
  onCancelInstallation?: (serverId: string) => void;
  currentUserInstalledLocalServer?: boolean;
  currentUserHasLocalTeamInstallation?: boolean;
  currentUserLocalServerInstallation?: InstalledServer;
};
export type McpServerCardVariant = "remote" | "local";
export type McpServerCardBaseProps = McpServerCardProps & {
  variant: McpServerCardVariant;
};
⋮----
const getToolsAssignedCount = () =>
⋮----
onClick=
⋮----

⋮----
setUninstallingServer({
                id: serverToUninstall.id,
                name: item.label || item.name,
              });
⋮----
setIsToolsDialogOpen(open);
⋮----
// Reset the tools dialog to clear selections
</file>

<file path="platform/frontend/src/app/profiles/agent-actions.tsx">
import { E2eTestId } from "@shared";
import { Pencil, Plug, Trash2 } from "lucide-react";
import { ButtonGroup } from "@/components/ui/button-group";
import { PermissionButton } from "@/components/ui/permission-button";
import type { useProfilesPaginated } from "@/lib/agent.query";
type Profile = NonNullable<
  ReturnType<typeof useProfilesPaginated>["data"]
>["data"][number];
type ProfileActionsProps = {
  agent: Profile;
  onConnect: (agent: Pick<Profile, "id" | "name">) => void;
  onEdit: (agent: Omit<Profile, "tools">) => void;
  onDelete: (agentId: string) => void;
};
⋮----
onClick=
</file>

<file path="platform/shared/access-control.ts">
import { createAccessControl } from "better-auth/plugins/access";
import { defaultStatements } from "better-auth/plugins/organization/access";
import { z } from "zod";
⋮----
export type Resource = z.infer<typeof ResourceSchema>;
export type Action = z.infer<typeof ActionSchema>;
export type Permission =
  | `${Resource}:${"create" | "read" | "update" | "delete"}`
  | "profile:admin"
  | "mcpServer:admin"
  | "mcpServerInstallationRequest:admin"
  | "invitation:cancel";
export type Permissions = z.infer<typeof PermissionsSchema>;
export type PredefinedRoleName = z.infer<typeof PredefinedRoleNameSchema>;
export type AnyRoleName = z.infer<typeof AnyRoleName>;
⋮----
export type RouteId = (typeof RouteId)[keyof typeof RouteId];
</file>

<file path="platform/frontend/src/app/chat/page.tsx">
import type { UIMessage } from "@ai-sdk/react";
import { Eye, EyeOff, Plus } from "lucide-react";
import Link from "next/link";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import {
  type FormEvent,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";
import { CustomServerRequestDialog } from "@/app/mcp-catalog/_parts/custom-server-request-dialog";
import {
  PromptInput,
  PromptInputBody,
  PromptInputSubmit,
  PromptInputTextarea,
  PromptInputToolbar,
  PromptInputTools,
} from "@/components/ai-elements/prompt-input";
import { ChatError } from "@/components/chat/chat-error";
import { ChatMessages } from "@/components/chat/chat-messages";
import { McpToolsDisplay } from "@/components/chat/mcp-tools-display";
import { PromptDialog } from "@/components/chat/prompt-dialog";
import { PromptLibraryGrid } from "@/components/chat/prompt-library-grid";
import { PromptVersionHistoryDialog } from "@/components/chat/prompt-version-history-dialog";
import { StreamTimeoutWarning } from "@/components/chat/stream-timeout-warning";
import { PageLayout } from "@/components/page-layout";
import { WithPermissions } from "@/components/roles/with-permissions";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useChatSession } from "@/contexts/global-chat-context";
import { useProfiles } from "@/lib/agent.query";
import { useConversation, useCreateConversation } from "@/lib/chat.query";
import { useChatSettingsOptional } from "@/lib/chat-settings.query";
import { useDeletePrompt, usePrompt, usePrompts } from "@/lib/prompts.query";
⋮----
// Check if API key is configured
⋮----
// Sync conversation ID with URL
⋮----
// Update URL when conversation changes
⋮----
// Fetch conversation with messages
⋮----
// Find the specific prompt for this conversation (if any)
⋮----
// Get current agent info
⋮----
// Clear MCP Gateway sessions when opening a NEW conversation
⋮----
// Only clear sessions if this is a newly created conversation
⋮----
// Clear sessions for this agent to ensure fresh MCP state
⋮----
const handleOpenDialog = () =>
⋮----
setIsPromptDialogOpen(open);
</file>

<file path="platform/frontend/src/components/chat/prompt-dialog.tsx">
import type { archestraApiTypes } from "@shared";
import { Loader2 } from "lucide-react";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { McpToolsDisplay } from "@/components/chat/mcp-tools-display";
import { WithPermissions } from "@/components/roles/with-permissions";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { useProfiles } from "@/lib/agent.query";
import { useCreatePrompt, useUpdatePrompt } from "@/lib/prompts.query";
type Prompt = archestraApiTypes.GetPromptsResponses["200"][number];
interface PromptDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  prompt?: Prompt | null;
  onViewVersionHistory?: (prompt: Prompt) => void;
}
⋮----
// Reset form when dialog opens/closes or prompt changes
⋮----
// edit
⋮----
// create
⋮----
// reset form
⋮----
// if on create and no agentId, set the first agent
⋮----
const handleSave = async () =>
</file>

<file path="platform/Dockerfile">
FROM node:24.11.1-alpine3.22 AS base

# Enable pnpm
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable

# Dependencies stage
FROM base AS deps
WORKDIR /app

# Copy package files for all workspaces
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml turbo.json ./
COPY backend/package.json backend/
COPY frontend/package.json frontend/
COPY shared/package.json shared/

# Install all dependencies
RUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --frozen-lockfile

# <----- Builder stage ----->
FROM base AS builder
WORKDIR /app

# Copy dependencies from deps stage
COPY --from=deps /app/node_modules ./node_modules
COPY --from=deps /app/backend/node_modules ./backend/node_modules
COPY --from=deps /app/frontend/node_modules ./frontend/node_modules
COPY --from=deps /app/shared/node_modules ./shared/node_modules

# Copy source files
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml turbo.json ./
COPY backend ./backend
COPY frontend ./frontend
COPY shared ./shared

# Build all workspace
ENV NEXT_TELEMETRY_DISABLED=1

# Use Docker secrets to securely pass various sensitive environment variables during build
# These environment variables are NOT persisted in the final image
#
# TURBO_TEAM and TURBO_TOKEN are used for Turbo remote caching
# https://turborepo.com/docs/guides/tools/docker#example
#
# https://docs.docker.com/build/building/secrets/#using-build-secrets
# https://docs.docker.com/build/building/secrets/#target
RUN --mount=type=secret,id=turbo_team,env=TURBO_TEAM \
    --mount=type=secret,id=turbo_token,env=TURBO_TOKEN \
    --mount=type=secret,id=sentry_auth_token,env=SENTRY_AUTH_TOKEN \
    pnpm build

# <----- Final unified stage ----->
FROM base AS unified
WORKDIR /app

ARG VERSION=dev

ENV NODE_ENV=production
# disable telemetry for next.js
ENV NEXT_TELEMETRY_DISABLED=1

ENV ARCHESTRA_VERSION=${VERSION}
ENV ARCHESTRA_API_BASE_URL="http://localhost:9000"
ENV ARCHESTRA_ANALYTICS="enabled"
ENV ARCHESTRA_ORCHESTRATOR_MCP_SERVER_BASE_IMAGE="europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-base:0.0.3"
ENV ARCHESTRA_ENTERPRISE_LICENSE_ACTIVATED="false"
ENV ARCHESTRA_SENTRY_FRONTEND_DSN=""
ENV ARCHESTRA_SENTRY_ENVIRONMENT=""

RUN apk --no-cache upgrade && \
    # Install PostgreSQL 17 and supervisord
    apk add --no-cache postgresql17 postgresql17-contrib su-exec && \
    # Remove NPM-related files and directories (as we do not use npm and it just brings extra dependencies/vulnerabilities)
    # See https://github.com/grafana/grafana-image-renderer/pull/625
    rm -rf /usr/local/lib/node_modules/npm && \
    rm -rf /usr/local/bin/npm && \
    rm -rf /usr/local/bin/npx && \
    rm -rf /root/.npm && \
    rm -rf /root/.node-gyp && \
    mkdir -p /var/log/supervisor && \
    # Clean up
    rm -rf /tmp/*

# Install supervisor from edge repository to address CVE-2023-27482
# https://nvd.nist.gov/vuln/detail/cve-2023-27482
RUN apk add --no-cache supervisor=4.3.0-r0 --repository=http://dl-cdn.alpinelinux.org/alpine/edge/main

# Create postgres directories (user already exists from postgresql package)
RUN mkdir -p /var/lib/postgresql/data /run/postgresql && \
    chown -R postgres:postgres /var/lib/postgresql /run/postgresql

# Mark PostgreSQL data directory as a volume for data persistence
VOLUME /var/lib/postgresql/data /app/data

# Copy package files
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json backend/
COPY frontend/package.json frontend/
COPY docker-banner.sh ./

# Install production dependencies for both workspaces
RUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --frozen-lockfile --prod --filter=@backend --filter=@frontend

# Copy built backend
COPY --from=builder /app/backend/dist ./backend/dist
COPY --from=builder /app/backend/drizzle.config.ts ./backend/
COPY --from=builder /app/backend/src/database/migrations ./backend/src/database/migrations

# Copy built frontend
COPY --from=builder /app/frontend/public ./frontend/public
COPY --from=builder /app/frontend/.next/standalone ./
COPY --from=builder /app/frontend/.next/static ./frontend/.next/static

# Create base supervisord configuration (without postgres)
#
# Important notes about supervisord environment variable handling:
# - Subprocesses automatically inherit ALL environment variables from the shell that starts supervisord
#   See: https://supervisord.org/subprocess.html#subprocess-environment
# - You ONLY need to explicitly set environment variables in the config when:
#   1. Using placeholder substitution (e.g., DATABASE_URL="placeholder" that gets replaced via sed)
#   2. Mapping ENV variables to different names (e.g., ARCHESTRA_* -> NEXT_PUBLIC_*)
#   3. Setting hardcoded values not in ENV (e.g., HOSTNAME="0.0.0.0")
# - All ENV variables declared in the Dockerfile are automatically available to all programs
#   See: https://supervisord.org/configuration.html#supervisord-section-values
RUN cat > /etc/supervisord.conf <<'EOF'
[supervisord]
nodaemon=true
user=root
logfile=/var/log/supervisor/supervisord.log
pidfile=/var/run/supervisord.pid

[program:backend]
directory=/app/backend
command=/bin/sh -c "sleep 5 && pnpm db:migrate && node dist/server.mjs"
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
priority=10
# DATABASE_URL is set to a placeholder here and replaced via sed in docker-entrypoint.sh
# All other environment variables (NODE_ENV, ARCHESTRA_*, etc.) are inherited automatically
environment=DATABASE_URL="placeholder"

[program:frontend]
directory=/app/frontend
command=/bin/sh -c "sleep 8 && node server.js"
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
priority=20
# NEXT_PUBLIC_* variables are mapped from ARCHESTRA_* ENV variables
# All other environment variables (NODE_ENV, etc.) are inherited automatically
environment=NEXT_PUBLIC_ARCHESTRA_API_BASE_URL="%(ENV_ARCHESTRA_API_BASE_URL)s",NEXT_PUBLIC_ARCHESTRA_ANALYTICS="%(ENV_ARCHESTRA_ANALYTICS)s",NEXT_PUBLIC_ARCHESTRA_ORCHESTRATOR_MCP_SERVER_BASE_IMAGE="%(ENV_ARCHESTRA_ORCHESTRATOR_MCP_SERVER_BASE_IMAGE)s",NEXT_PUBLIC_ARCHESTRA_SENTRY_FRONTEND_DSN="%(ENV_ARCHESTRA_SENTRY_FRONTEND_DSN)s",NEXT_PUBLIC_ARCHESTRA_SENTRY_ENVIRONMENT="%(ENV_ARCHESTRA_SENTRY_ENVIRONMENT)s",NEXT_PUBLIC_ARCHESTRA_ENTERPRISE_LICENSE_ACTIVATED="%(ENV_ARCHESTRA_ENTERPRISE_LICENSE_ACTIVATED)s"
EOF

# Create postgres program configuration (to be conditionally included)
RUN cat > /etc/supervisord.postgres.conf <<'EOF'

[program:postgres]
user=postgres
command=postgres -D /var/lib/postgresql/data
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
priority=1
EOF

# Create initialization script
RUN cat > /docker-entrypoint.sh <<'EOF'
#!/bin/sh
set -e

# Generate and persist ARCHESTRA_AUTH_SECRET if not set
if [ -z "$ARCHESTRA_AUTH_SECRET" ]; then
    SECRET_FILE="/app/data/.auth_secret"

    if [ -f "$SECRET_FILE" ]; then
        # Load existing secret
        export ARCHESTRA_AUTH_SECRET=$(cat "$SECRET_FILE")
        echo "Loaded existing ARCHESTRA_AUTH_SECRET from $SECRET_FILE"
    else
        # Generate new random secret (64 characters)
        export ARCHESTRA_AUTH_SECRET=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 1)

        # Persist it
        mkdir -p /app/data
        echo "$ARCHESTRA_AUTH_SECRET" > "$SECRET_FILE"
        chmod 600 "$SECRET_FILE"
        echo "Generated and saved new ARCHESTRA_AUTH_SECRET to $SECRET_FILE"
    fi
fi

# Check if using external database (ARCHESTRA_DATABASE_URL or DATABASE_URL is set)
USE_EXTERNAL_DB=false
if [ -n "$ARCHESTRA_DATABASE_URL" ] || [ -n "$DATABASE_URL" ]; then
    USE_EXTERNAL_DB=true
fi

# Parse DATABASE_URL (prefer ARCHESTRA_DATABASE_URL, fallback to DATABASE_URL)
EFFECTIVE_DATABASE_URL="${ARCHESTRA_DATABASE_URL:-$DATABASE_URL}"

if [ "$USE_EXTERNAL_DB" = "false" ]; then
    echo "Using internal PostgreSQL database"

    # Use defaults for internal database
    POSTGRES_USER=${POSTGRES_USER:-archestra}
    POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-archestra_dev_password}
    POSTGRES_DB=${POSTGRES_DB:-archestra_dev}
    EFFECTIVE_DATABASE_URL="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:5432/${POSTGRES_DB}?schema=public"

    # Append postgres program to supervisord config
    cat /etc/supervisord.postgres.conf >> /etc/supervisord.conf

    # Initialize PostgreSQL if data directory is empty
    if [ ! -s /var/lib/postgresql/data/PG_VERSION ]; then
        echo "Initializing PostgreSQL database..."
        su-exec postgres initdb -D /var/lib/postgresql/data

        # Configure PostgreSQL
        echo "host all all all md5" >> /var/lib/postgresql/data/pg_hba.conf
        echo "listen_addresses='*'" >> /var/lib/postgresql/data/postgresql.conf

        # Start PostgreSQL temporarily to create user and database
        su-exec postgres pg_ctl -D /var/lib/postgresql/data -o "-c listen_addresses=''" -w start

        # Create user and database
        psql -v ON_ERROR_STOP=1 --username postgres <<-EOSQL
            CREATE USER ${POSTGRES_USER} WITH PASSWORD '${POSTGRES_PASSWORD}';
            CREATE DATABASE ${POSTGRES_DB} OWNER ${POSTGRES_USER};
            GRANT ALL PRIVILEGES ON DATABASE ${POSTGRES_DB} TO ${POSTGRES_USER};
EOSQL

        # Stop PostgreSQL
        su-exec postgres pg_ctl -D /var/lib/postgresql/data -m fast -w stop

        echo "PostgreSQL initialized successfully"
    fi
else
    echo "Using external PostgreSQL database"
    # Extract credentials from DATABASE_URL if needed (postgresql://user:pass@host:port/db)
    POSTGRES_USER=$(echo "$EFFECTIVE_DATABASE_URL" | sed -n 's|.*://\([^:]*\):.*|\1|p')
    POSTGRES_PASSWORD=$(echo "$EFFECTIVE_DATABASE_URL" | sed -n 's|.*://[^:]*:\([^@]*\)@.*|\1|p')
    POSTGRES_DB=$(echo "$EFFECTIVE_DATABASE_URL" | sed -n 's|.*/\([^?]*\).*|\1|p')
fi

# Update supervisord config with actual environment variables
sed -i "s|DATABASE_URL=\"[^\"]*\"|DATABASE_URL=\"${EFFECTIVE_DATABASE_URL}\"|" /etc/supervisord.conf

# Propagate analytics setting to frontend (enabled by default, set to "disabled" to opt-out)
if [ -n "$ARCHESTRA_ANALYTICS" ]; then
  sed -i "s|environment=\(.*\)|environment=\1,NEXT_PUBLIC_ARCHESTRA_ANALYTICS=\"${ARCHESTRA_ANALYTICS}\"|g" /etc/supervisord.conf
fi

# Add startup banner to supervisord (sleeps 12s to ensure it prints after Next.js logs)
cat >> /etc/supervisord.conf <<CONF

[program:startup-banner]
command=/bin/sh -c "sleep 12 && /app/docker-banner.sh"
autostart=true
autorestart=false
startsecs=0
priority=999
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
CONF

# Start supervisord
exec /usr/bin/supervisord -c /etc/supervisord.conf
EOF

RUN chmod +x /docker-entrypoint.sh
RUN chmod +x /app/docker-banner.sh

# Expose ports
EXPOSE 5432 9000 9050 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/ || exit 1

ENTRYPOINT ["/docker-entrypoint.sh"]
</file>

<file path="platform/frontend/src/app/profiles/page.client.tsx">
import { archestraApiSdk, E2eTestId } from "@shared";
import { useQuery } from "@tanstack/react-query";
import type { ColumnDef, SortingState } from "@tanstack/react-table";
import {
  ChevronDown,
  ChevronUp,
  Plus,
  Search,
  Tag,
  Wrench,
  X,
} from "lucide-react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { Suspense, useCallback, useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import { ErrorBoundary } from "@/app/_parts/error-boundary";
import {
  type ProfileLabel,
  ProfileLabels,
  type ProfileLabelsRef,
} from "@/components/agent-labels";
import { DebouncedInput } from "@/components/debounced-input";
import { LoadingSpinner } from "@/components/loading";
import { McpConnectionInstructions } from "@/components/mcp-connection-instructions";
import { PageLayout } from "@/components/page-layout";
import { ProxyConnectionInstructions } from "@/components/proxy-connection-instructions";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { DataTable } from "@/components/ui/data-table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { PermissionButton } from "@/components/ui/permission-button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  useCreateProfile,
  useDeleteProfile,
  useLabelKeys,
  useProfilesPaginated,
  useUpdateProfile,
} from "@/lib/agent.query";
import { formatDate } from "@/lib/utils";
import { ProfileActions } from "./agent-actions";
import { AssignToolsDialog } from "./assign-tools-dialog";
⋮----
const getTeamById = (teamId: string) =>
⋮----
type ProfileData = (typeof agents)[number];
⋮----
onClick={() => setAssigningToolsProfile(agent)}
            >
              <Wrench className="h-4 w-4" />
            </PermissionButton>
          </div>
        );
⋮----
onOpenChange=
</file>

<file path="platform/frontend/src/components/chat/prompt-library-grid.tsx">
import {
  type archestraApiTypes,
  MCP_SERVER_TOOL_NAME_SEPARATOR,
} from "@shared";
import {
  History as HistoryIcon,
  MessageSquarePlus,
  MoreVertical,
  Pencil,
  Search,
  Trash2,
} from "lucide-react";
import { useEffect, useMemo, useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useProfiles } from "@/lib/agent.query";
import { useChatProfileMcpTools } from "@/lib/chat.query";
import { WithPermissions } from "../roles/with-permissions";
import { TruncatedText } from "../truncated-text";
import { McpToolsDisplay } from "./mcp-tools-display";
type Prompt = archestraApiTypes.GetPromptsResponses["200"][number];
interface PromptLibraryGridProps {
  prompts: Prompt[];
  onSelectPrompt: (agentId: string, promptId?: string) => void;
  onEdit: (prompt: Prompt) => void;
  onDelete: (promptId: string) => void;
  onViewVersionHistory: (prompt: Prompt) => void;
}
⋮----
// Filter prompts based on search query
⋮----
const handleFreeChatStart = () =>
const handlePromptClick = (prompt: Prompt) =>
⋮----
onChange=
⋮----
onClick=
⋮----
{/* Delete Confirmation Dialog */}
⋮----
e.stopPropagation();
onEdit(prompt);
</file>

</files>



<instruction>
Build hierarchical model C4.
Create detailed codemap for coding agent with all files present.

- Start from the **high-level modules/packages**.
- Drill down into **submodules, classes, and functions**.
- Follow **C4 model principles** (System → Container → Component → Code).

For **best results** you want a C4-aligned JSON schema that works from
**System → Container → Component → Code** while staying practical for a codebase.

Output only with JSON, no comments or explanations.

- **system** → project-wide context (name, purpose).
- **containers** → deployable units (API service, CLI tool, worker, database wrapper).
- **components** → logical modules within a container (auth, storage, API routes, indexer, etc.).
- **files** → mapped directly from filesystem tree (use shell command `tree`).
- **classes / functions** → code-level breakdown for traceability.

</instruction>
